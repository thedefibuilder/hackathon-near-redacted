"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@near-js+wallet-account@1.3.1";
exports.ids = ["vendor-chunks/@near-js+wallet-account@1.3.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@near-js+wallet-account@1.3.1/node_modules/@near-js/wallet-account/lib/commonjs/index.cjs":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+wallet-account@1.3.1/node_modules/@near-js/wallet-account/lib/commonjs/index.cjs ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WalletConnection = exports.ConnectedWalletAccount = exports.Near = void 0;\nvar near_1 = __webpack_require__(/*! ./near.cjs */ \"(ssr)/./node_modules/.pnpm/@near-js+wallet-account@1.3.1/node_modules/@near-js/wallet-account/lib/commonjs/near.cjs\");\nObject.defineProperty(exports, \"Near\", ({ enumerable: true, get: function () { return near_1.Near; } }));\nvar wallet_account_1 = __webpack_require__(/*! ./wallet_account.cjs */ \"(ssr)/./node_modules/.pnpm/@near-js+wallet-account@1.3.1/node_modules/@near-js/wallet-account/lib/commonjs/wallet_account.cjs\");\nObject.defineProperty(exports, \"ConnectedWalletAccount\", ({ enumerable: true, get: function () { return wallet_account_1.ConnectedWalletAccount; } }));\nObject.defineProperty(exports, \"WalletConnection\", ({ enumerable: true, get: function () { return wallet_account_1.WalletConnection; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrd2FsbGV0LWFjY291bnRAMS4zLjEvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL3dhbGxldC1hY2NvdW50L2xpYi9jb21tb25qcy9pbmRleC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLEdBQUcsOEJBQThCLEdBQUcsWUFBWTtBQUN4RSxhQUFhLG1CQUFPLENBQUMsdUlBQVk7QUFDakMsd0NBQXVDLEVBQUUscUNBQXFDLHVCQUF1QixFQUFDO0FBQ3RHLHVCQUF1QixtQkFBTyxDQUFDLDJKQUFzQjtBQUNyRCwwREFBeUQsRUFBRSxxQ0FBcUMsbURBQW1ELEVBQUM7QUFDcEosb0RBQW1ELEVBQUUscUNBQXFDLDZDQUE2QyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGFja2F0aG9uLW5lYXItcmVkYWN0ZWQvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrd2FsbGV0LWFjY291bnRAMS4zLjEvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL3dhbGxldC1hY2NvdW50L2xpYi9jb21tb25qcy9pbmRleC5janM/NTJjYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV2FsbGV0Q29ubmVjdGlvbiA9IGV4cG9ydHMuQ29ubmVjdGVkV2FsbGV0QWNjb3VudCA9IGV4cG9ydHMuTmVhciA9IHZvaWQgMDtcbnZhciBuZWFyXzEgPSByZXF1aXJlKFwiLi9uZWFyLmNqc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5lYXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5lYXJfMS5OZWFyOyB9IH0pO1xudmFyIHdhbGxldF9hY2NvdW50XzEgPSByZXF1aXJlKFwiLi93YWxsZXRfYWNjb3VudC5janNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb25uZWN0ZWRXYWxsZXRBY2NvdW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB3YWxsZXRfYWNjb3VudF8xLkNvbm5lY3RlZFdhbGxldEFjY291bnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXYWxsZXRDb25uZWN0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB3YWxsZXRfYWNjb3VudF8xLldhbGxldENvbm5lY3Rpb247IH0gfSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+wallet-account@1.3.1/node_modules/@near-js/wallet-account/lib/commonjs/index.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@near-js+wallet-account@1.3.1/node_modules/@near-js/wallet-account/lib/commonjs/near.cjs":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+wallet-account@1.3.1/node_modules/@near-js/wallet-account/lib/commonjs/near.cjs ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Near = void 0;\n/**\n * This module contains the main class developers will use to interact with NEAR.\n * The {@link Near} class is used to interact with {@link \"@near-js/accounts\".account.Account | Account} through the {@link \"@near-js/providers\".json-rpc-provider.JsonRpcProvider | JsonRpcProvider}.\n * It is configured via the {@link NearConfig}.\n *\n * @see [https://docs.near.org/tools/near-api-js/quick-reference#account](https://docs.near.org/tools/near-api-js/quick-reference#account)\n *\n * @module near\n */\nconst accounts_1 = __webpack_require__(/*! @near-js/accounts */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/index.cjs\");\n/**\n * This is the main class developers should use to interact with NEAR.\n * @example\n * ```js\n * const near = new Near(config);\n * ```\n */\nclass Near {\n    config;\n    connection;\n    accountCreator;\n    constructor(config) {\n        this.config = config;\n        this.connection = accounts_1.Connection.fromConfig({\n            networkId: config.networkId,\n            provider: config.provider || { type: 'JsonRpcProvider', args: { url: config.nodeUrl, headers: config.headers } },\n            signer: config.signer || { type: 'InMemorySigner', keyStore: config.keyStore || config.deps?.keyStore },\n            jsvmAccountId: config.jsvmAccountId || `jsvm.${config.networkId}`\n        });\n        if (config.masterAccount) {\n            // TODO: figure out better way of specifiying initial balance.\n            // Hardcoded number below must be enough to pay the gas cost to dev-deploy with near-shell for multiple times\n            const initialBalance = config.initialBalance ? BigInt(config.initialBalance) : 500000000000000000000000000n;\n            this.accountCreator = new accounts_1.LocalAccountCreator(new accounts_1.Account(this.connection, config.masterAccount), initialBalance);\n        }\n        else if (config.helperUrl) {\n            this.accountCreator = new accounts_1.UrlAccountCreator(this.connection, config.helperUrl);\n        }\n        else {\n            this.accountCreator = null;\n        }\n    }\n    /**\n     * @param accountId near accountId used to interact with the network.\n     */\n    async account(accountId) {\n        const account = new accounts_1.Account(this.connection, accountId);\n        return account;\n    }\n    /**\n     * Create an account using the {@link AccountCreator}. Either:\n     * * using a masterAccount with {@link LocalAccountCreator}\n     * * using the helperUrl with {@link UrlAccountCreator}\n     * @see {@link NearConfig#masterAccount} and {@link NearConfig#helperUrl}\n     *\n     * @param accountId\n     * @param publicKey\n     */\n    async createAccount(accountId, publicKey) {\n        if (!this.accountCreator) {\n            throw new Error('Must specify account creator, either via masterAccount or helperUrl configuration settings.');\n        }\n        await this.accountCreator.createAccount(accountId, publicKey);\n        return new accounts_1.Account(this.connection, accountId);\n    }\n}\nexports.Near = Near;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrd2FsbGV0LWFjY291bnRAMS4zLjEvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL3dhbGxldC1hY2NvdW50L2xpYi9jb21tb25qcy9uZWFyLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZO0FBQ1o7QUFDQTtBQUNBLFFBQVEsWUFBWSxnQ0FBZ0MscURBQXFELGFBQWEsK0VBQStFO0FBQ3JNLDZCQUE2QixpQkFBaUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLG1JQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsaUNBQWlDLGdEQUFnRDtBQUM1SCx1Q0FBdUMsNEVBQTRFO0FBQ25ILDJEQUEyRCxpQkFBaUI7QUFDNUUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxxQkFBcUI7QUFDekQscUNBQXFDO0FBQ3JDLG1DQUFtQztBQUNuQyxhQUFhLGdDQUFnQyxLQUFLO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oYWNrYXRob24tbmVhci1yZWRhY3RlZC8uL25vZGVfbW9kdWxlcy8ucG5wbS9AbmVhci1qcyt3YWxsZXQtYWNjb3VudEAxLjMuMS9ub2RlX21vZHVsZXMvQG5lYXItanMvd2FsbGV0LWFjY291bnQvbGliL2NvbW1vbmpzL25lYXIuY2pzPzBjZDIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5lYXIgPSB2b2lkIDA7XG4vKipcbiAqIFRoaXMgbW9kdWxlIGNvbnRhaW5zIHRoZSBtYWluIGNsYXNzIGRldmVsb3BlcnMgd2lsbCB1c2UgdG8gaW50ZXJhY3Qgd2l0aCBORUFSLlxuICogVGhlIHtAbGluayBOZWFyfSBjbGFzcyBpcyB1c2VkIHRvIGludGVyYWN0IHdpdGgge0BsaW5rIFwiQG5lYXItanMvYWNjb3VudHNcIi5hY2NvdW50LkFjY291bnQgfCBBY2NvdW50fSB0aHJvdWdoIHRoZSB7QGxpbmsgXCJAbmVhci1qcy9wcm92aWRlcnNcIi5qc29uLXJwYy1wcm92aWRlci5Kc29uUnBjUHJvdmlkZXIgfCBKc29uUnBjUHJvdmlkZXJ9LlxuICogSXQgaXMgY29uZmlndXJlZCB2aWEgdGhlIHtAbGluayBOZWFyQ29uZmlnfS5cbiAqXG4gKiBAc2VlIFtodHRwczovL2RvY3MubmVhci5vcmcvdG9vbHMvbmVhci1hcGktanMvcXVpY2stcmVmZXJlbmNlI2FjY291bnRdKGh0dHBzOi8vZG9jcy5uZWFyLm9yZy90b29scy9uZWFyLWFwaS1qcy9xdWljay1yZWZlcmVuY2UjYWNjb3VudClcbiAqXG4gKiBAbW9kdWxlIG5lYXJcbiAqL1xuY29uc3QgYWNjb3VudHNfMSA9IHJlcXVpcmUoXCJAbmVhci1qcy9hY2NvdW50c1wiKTtcbi8qKlxuICogVGhpcyBpcyB0aGUgbWFpbiBjbGFzcyBkZXZlbG9wZXJzIHNob3VsZCB1c2UgdG8gaW50ZXJhY3Qgd2l0aCBORUFSLlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBjb25zdCBuZWFyID0gbmV3IE5lYXIoY29uZmlnKTtcbiAqIGBgYFxuICovXG5jbGFzcyBOZWFyIHtcbiAgICBjb25maWc7XG4gICAgY29ubmVjdGlvbjtcbiAgICBhY2NvdW50Q3JlYXRvcjtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IGFjY291bnRzXzEuQ29ubmVjdGlvbi5mcm9tQ29uZmlnKHtcbiAgICAgICAgICAgIG5ldHdvcmtJZDogY29uZmlnLm5ldHdvcmtJZCxcbiAgICAgICAgICAgIHByb3ZpZGVyOiBjb25maWcucHJvdmlkZXIgfHwgeyB0eXBlOiAnSnNvblJwY1Byb3ZpZGVyJywgYXJnczogeyB1cmw6IGNvbmZpZy5ub2RlVXJsLCBoZWFkZXJzOiBjb25maWcuaGVhZGVycyB9IH0sXG4gICAgICAgICAgICBzaWduZXI6IGNvbmZpZy5zaWduZXIgfHwgeyB0eXBlOiAnSW5NZW1vcnlTaWduZXInLCBrZXlTdG9yZTogY29uZmlnLmtleVN0b3JlIHx8IGNvbmZpZy5kZXBzPy5rZXlTdG9yZSB9LFxuICAgICAgICAgICAganN2bUFjY291bnRJZDogY29uZmlnLmpzdm1BY2NvdW50SWQgfHwgYGpzdm0uJHtjb25maWcubmV0d29ya0lkfWBcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjb25maWcubWFzdGVyQWNjb3VudCkge1xuICAgICAgICAgICAgLy8gVE9ETzogZmlndXJlIG91dCBiZXR0ZXIgd2F5IG9mIHNwZWNpZml5aW5nIGluaXRpYWwgYmFsYW5jZS5cbiAgICAgICAgICAgIC8vIEhhcmRjb2RlZCBudW1iZXIgYmVsb3cgbXVzdCBiZSBlbm91Z2ggdG8gcGF5IHRoZSBnYXMgY29zdCB0byBkZXYtZGVwbG95IHdpdGggbmVhci1zaGVsbCBmb3IgbXVsdGlwbGUgdGltZXNcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxCYWxhbmNlID0gY29uZmlnLmluaXRpYWxCYWxhbmNlID8gQmlnSW50KGNvbmZpZy5pbml0aWFsQmFsYW5jZSkgOiA1MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBuO1xuICAgICAgICAgICAgdGhpcy5hY2NvdW50Q3JlYXRvciA9IG5ldyBhY2NvdW50c18xLkxvY2FsQWNjb3VudENyZWF0b3IobmV3IGFjY291bnRzXzEuQWNjb3VudCh0aGlzLmNvbm5lY3Rpb24sIGNvbmZpZy5tYXN0ZXJBY2NvdW50KSwgaW5pdGlhbEJhbGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbmZpZy5oZWxwZXJVcmwpIHtcbiAgICAgICAgICAgIHRoaXMuYWNjb3VudENyZWF0b3IgPSBuZXcgYWNjb3VudHNfMS5VcmxBY2NvdW50Q3JlYXRvcih0aGlzLmNvbm5lY3Rpb24sIGNvbmZpZy5oZWxwZXJVcmwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hY2NvdW50Q3JlYXRvciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGFjY291bnRJZCBuZWFyIGFjY291bnRJZCB1c2VkIHRvIGludGVyYWN0IHdpdGggdGhlIG5ldHdvcmsuXG4gICAgICovXG4gICAgYXN5bmMgYWNjb3VudChhY2NvdW50SWQpIHtcbiAgICAgICAgY29uc3QgYWNjb3VudCA9IG5ldyBhY2NvdW50c18xLkFjY291bnQodGhpcy5jb25uZWN0aW9uLCBhY2NvdW50SWQpO1xuICAgICAgICByZXR1cm4gYWNjb3VudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGFjY291bnQgdXNpbmcgdGhlIHtAbGluayBBY2NvdW50Q3JlYXRvcn0uIEVpdGhlcjpcbiAgICAgKiAqIHVzaW5nIGEgbWFzdGVyQWNjb3VudCB3aXRoIHtAbGluayBMb2NhbEFjY291bnRDcmVhdG9yfVxuICAgICAqICogdXNpbmcgdGhlIGhlbHBlclVybCB3aXRoIHtAbGluayBVcmxBY2NvdW50Q3JlYXRvcn1cbiAgICAgKiBAc2VlIHtAbGluayBOZWFyQ29uZmlnI21hc3RlckFjY291bnR9IGFuZCB7QGxpbmsgTmVhckNvbmZpZyNoZWxwZXJVcmx9XG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWNjb3VudElkXG4gICAgICogQHBhcmFtIHB1YmxpY0tleVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUFjY291bnQoYWNjb3VudElkLCBwdWJsaWNLZXkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjY291bnRDcmVhdG9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3Qgc3BlY2lmeSBhY2NvdW50IGNyZWF0b3IsIGVpdGhlciB2aWEgbWFzdGVyQWNjb3VudCBvciBoZWxwZXJVcmwgY29uZmlndXJhdGlvbiBzZXR0aW5ncy4nKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLmFjY291bnRDcmVhdG9yLmNyZWF0ZUFjY291bnQoYWNjb3VudElkLCBwdWJsaWNLZXkpO1xuICAgICAgICByZXR1cm4gbmV3IGFjY291bnRzXzEuQWNjb3VudCh0aGlzLmNvbm5lY3Rpb24sIGFjY291bnRJZCk7XG4gICAgfVxufVxuZXhwb3J0cy5OZWFyID0gTmVhcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+wallet-account@1.3.1/node_modules/@near-js/wallet-account/lib/commonjs/near.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@near-js+wallet-account@1.3.1/node_modules/@near-js/wallet-account/lib/commonjs/wallet_account.cjs":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+wallet-account@1.3.1/node_modules/@near-js/wallet-account/lib/commonjs/wallet_account.cjs ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConnectedWalletAccount = exports.WalletConnection = void 0;\n/**\n * This module exposes two classes:\n * * {@link WalletConnection} which redirects users to [NEAR Wallet](https://wallet.near.org/) for key management.\n * * {@link ConnectedWalletAccount} is an {@link \"@near-js/accounts\".account.Account | Account} implementation that uses {@link WalletConnection} to get keys\n *\n * @module walletAccount\n */\nconst accounts_1 = __webpack_require__(/*! @near-js/accounts */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/index.cjs\");\nconst crypto_1 = __webpack_require__(/*! @near-js/crypto */ \"(ssr)/./node_modules/.pnpm/@near-js+crypto@1.4.1/node_modules/@near-js/crypto/lib/commonjs/index.cjs\");\nconst utils_1 = __webpack_require__(/*! @near-js/utils */ \"(ssr)/./node_modules/.pnpm/@near-js+utils@1.0.1/node_modules/@near-js/utils/lib/commonjs/index.cjs\");\nconst transactions_1 = __webpack_require__(/*! @near-js/transactions */ \"(ssr)/./node_modules/.pnpm/@near-js+transactions@1.3.1/node_modules/@near-js/transactions/lib/commonjs/index.cjs\");\nconst borsh_1 = __webpack_require__(/*! borsh */ \"(ssr)/./node_modules/.pnpm/borsh@1.0.0/node_modules/borsh/lib/cjs/index.js\");\nconst LOGIN_WALLET_URL_SUFFIX = '/login/';\nconst MULTISIG_HAS_METHOD = 'add_request_and_confirm';\nconst LOCAL_STORAGE_KEY_SUFFIX = '_wallet_auth_key';\nconst PENDING_ACCESS_KEY_PREFIX = 'pending_key'; // browser storage key for a pending access key (i.e. key has been generated but we are not sure it was added yet)\n/**\n * This class is not intended for use outside the browser. Without `window` (i.e. in server contexts), it will instantiate but will throw a clear error when used.\n *\n * @see [https://docs.near.org/tools/near-api-js/quick-reference#wallet](https://docs.near.org/tools/near-api-js/quick-reference#wallet)\n * @example\n * ```js\n * // create new WalletConnection instance\n * const wallet = new WalletConnection(near, 'my-app');\n *\n * // If not signed in redirect to the NEAR wallet to sign in\n * // keys will be stored in the BrowserLocalStorageKeyStore\n * if(!wallet.isSignedIn()) return wallet.requestSignIn()\n * ```\n */\nclass WalletConnection {\n    /** @hidden */\n    _walletBaseUrl;\n    /** @hidden */\n    _authDataKey;\n    /** @hidden */\n    _keyStore;\n    /** @hidden */\n    _authData;\n    /** @hidden */\n    _networkId;\n    /** @hidden */\n    // _near: Near;\n    _near;\n    /** @hidden */\n    _connectedAccount;\n    /** @hidden */\n    _completeSignInPromise;\n    constructor(near, appKeyPrefix) {\n        if (typeof (appKeyPrefix) !== 'string') {\n            throw new Error('Please define a clear appKeyPrefix for this WalletConnection instance as the second argument to the constructor');\n        }\n        if (typeof window === 'undefined') {\n            return new Proxy(this, {\n                get(target, property) {\n                    if (property === 'isSignedIn') {\n                        return () => false;\n                    }\n                    if (property === 'getAccountId') {\n                        return () => '';\n                    }\n                    if (target[property] && typeof target[property] === 'function') {\n                        return () => {\n                            throw new Error('No window found in context, please ensure you are using WalletConnection on the browser');\n                        };\n                    }\n                    return target[property];\n                }\n            });\n        }\n        this._near = near;\n        const authDataKey = appKeyPrefix + LOCAL_STORAGE_KEY_SUFFIX;\n        const authData = JSON.parse(window.localStorage.getItem(authDataKey));\n        this._networkId = near.config.networkId;\n        this._walletBaseUrl = near.config.walletUrl;\n        appKeyPrefix = appKeyPrefix || near.config.contractName || 'default';\n        this._keyStore = near.connection.signer.keyStore;\n        this._authData = authData || { allKeys: [] };\n        this._authDataKey = authDataKey;\n        if (!this.isSignedIn()) {\n            this._completeSignInPromise = this._completeSignInWithAccessKey();\n        }\n    }\n    /**\n     * Returns true, if this WalletConnection is authorized with the wallet.\n     * @example\n     * ```js\n     * const wallet = new WalletConnection(near, 'my-app');\n     * wallet.isSignedIn();\n     * ```\n     */\n    isSignedIn() {\n        return !!this._authData.accountId;\n    }\n    /**\n     * Returns promise of completing signing in after redirecting from wallet\n     * @example\n     * ```js\n     * // on login callback page\n     * const wallet = new WalletConnection(near, 'my-app');\n     * wallet.isSignedIn(); // false\n     * await wallet.isSignedInAsync(); // true\n     * ```\n     */\n    async isSignedInAsync() {\n        if (!this._completeSignInPromise) {\n            return this.isSignedIn();\n        }\n        await this._completeSignInPromise;\n        return this.isSignedIn();\n    }\n    /**\n     * Returns authorized Account ID.\n     * @example\n     * ```js\n     * const wallet = new WalletConnection(near, 'my-app');\n     * wallet.getAccountId();\n     * ```\n     */\n    getAccountId() {\n        return this._authData.accountId || '';\n    }\n    /**\n     * Constructs string URL to the wallet authentication page.\n     * @param options An optional options object\n     * @param options.contractId The NEAR account where the contract is deployed\n     * @param options.successUrl URL to redirect upon success. Default: current url\n     * @param options.failureUrl URL to redirect upon failure. Default: current url\n     *\n     * @example\n     * ```js\n     * const wallet = new WalletConnection(near, 'my-app');\n     * // return string URL to the NEAR Wallet\n     * const url = await wallet.requestSignInUrl({ contractId: 'account-with-deploy-contract.near' });\n     * ```\n     */\n    async requestSignInUrl({ contractId, methodNames, successUrl, failureUrl, keyType = 'ed25519' }) {\n        const currentUrl = new URL(window.location.href);\n        const newUrl = new URL(this._walletBaseUrl + LOGIN_WALLET_URL_SUFFIX);\n        newUrl.searchParams.set('success_url', successUrl || currentUrl.href);\n        newUrl.searchParams.set('failure_url', failureUrl || currentUrl.href);\n        if (contractId) {\n            /* Throws exception if contract account does not exist */\n            const contractAccount = await this._near.account(contractId);\n            await contractAccount.state();\n            newUrl.searchParams.set('contract_id', contractId);\n            const accessKey = crypto_1.KeyPair.fromRandom(keyType);\n            newUrl.searchParams.set('public_key', accessKey.getPublicKey().toString());\n            await this._keyStore.setKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + accessKey.getPublicKey(), accessKey);\n        }\n        if (methodNames) {\n            methodNames.forEach(methodName => {\n                newUrl.searchParams.append('methodNames', methodName);\n            });\n        }\n        return newUrl.toString();\n    }\n    /**\n     * Redirects current page to the wallet authentication page.\n     * @param options An optional options object\n     * @param options.contractId The NEAR account where the contract is deployed\n     * @param options.successUrl URL to redirect upon success. Default: current url\n     * @param options.failureUrl URL to redirect upon failure. Default: current url\n     *\n     * @example\n     * ```js\n     * const wallet = new WalletConnection(near, 'my-app');\n     * // redirects to the NEAR Wallet\n     * wallet.requestSignIn({ contractId: 'account-with-deploy-contract.near' });\n     * ```\n     */\n    async requestSignIn(options) {\n        const url = await this.requestSignInUrl(options);\n        window.location.assign(url);\n    }\n    /**\n     * Constructs string URL to the wallet to sign a transaction or batch of transactions.\n     *\n     * @param options A required options object\n     * @param options.transactions List of transactions to sign\n     * @param options.callbackUrl URL to redirect upon success. Default: current url\n     * @param options.meta Meta information the wallet will send back to the application. `meta` will be attached to the `callbackUrl` as a url search param\n     *\n     */\n    requestSignTransactionsUrl({ transactions, meta, callbackUrl }) {\n        const currentUrl = new URL(window.location.href);\n        const newUrl = new URL('sign', this._walletBaseUrl);\n        newUrl.searchParams.set('transactions', transactions\n            .map(transaction => (0, borsh_1.serialize)(transactions_1.SCHEMA.Transaction, transaction))\n            .map(serialized => Buffer.from(serialized).toString('base64'))\n            .join(','));\n        newUrl.searchParams.set('callbackUrl', callbackUrl || currentUrl.href);\n        if (meta)\n            newUrl.searchParams.set('meta', meta);\n        return newUrl.toString();\n    }\n    /**\n     * Requests the user to quickly sign for a transaction or batch of transactions by redirecting to the wallet.\n     *\n     * @param options A required options object\n     * @param options.transactions List of transactions to sign\n     * @param options.callbackUrl URL to redirect upon success. Default: current url\n     * @param options.meta Meta information the wallet will send back to the application. `meta` will be attached to the `callbackUrl` as a url search param\n     *\n     */\n    requestSignTransactions(options) {\n        const url = this.requestSignTransactionsUrl(options);\n        window.location.assign(url);\n    }\n    /**\n     * @hidden\n     * Complete sign in for a given account id and public key. To be invoked by the app when getting a callback from the wallet.\n     */\n    async _completeSignInWithAccessKey() {\n        const currentUrl = new URL(window.location.href);\n        const publicKey = currentUrl.searchParams.get('public_key') || '';\n        const allKeys = (currentUrl.searchParams.get('all_keys') || '').split(',');\n        const accountId = currentUrl.searchParams.get('account_id') || '';\n        // TODO: Handle errors during login\n        if (accountId) {\n            const authData = {\n                accountId,\n                allKeys\n            };\n            window.localStorage.setItem(this._authDataKey, JSON.stringify(authData));\n            if (publicKey) {\n                await this._moveKeyFromTempToPermanent(accountId, publicKey);\n            }\n            this._authData = authData;\n        }\n        currentUrl.searchParams.delete('public_key');\n        currentUrl.searchParams.delete('all_keys');\n        currentUrl.searchParams.delete('account_id');\n        currentUrl.searchParams.delete('meta');\n        currentUrl.searchParams.delete('transactionHashes');\n        window.history.replaceState({}, document.title, currentUrl.toString());\n    }\n    /**\n     * @hidden\n     * @param accountId The NEAR account owning the given public key\n     * @param publicKey The public key being set to the key store\n     */\n    async _moveKeyFromTempToPermanent(accountId, publicKey) {\n        const keyPair = await this._keyStore.getKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + publicKey);\n        await this._keyStore.setKey(this._networkId, accountId, keyPair);\n        await this._keyStore.removeKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + publicKey);\n    }\n    /**\n     * Sign out from the current account\n     * @example\n     * walletConnection.signOut();\n     */\n    signOut() {\n        this._authData = {};\n        window.localStorage.removeItem(this._authDataKey);\n    }\n    /**\n     * Returns the current connected wallet account\n     */\n    account() {\n        if (!this._connectedAccount) {\n            this._connectedAccount = new ConnectedWalletAccount(this, this._near.connection, this._authData.accountId);\n        }\n        return this._connectedAccount;\n    }\n}\nexports.WalletConnection = WalletConnection;\n/**\n * {@link Account} implementation which redirects to wallet using {@link WalletConnection} when no local key is available.\n */\nclass ConnectedWalletAccount extends accounts_1.Account {\n    walletConnection;\n    constructor(walletConnection, connection, accountId) {\n        super(connection, accountId);\n        this.walletConnection = walletConnection;\n    }\n    // Overriding Account methods\n    /**\n     * Sign a transaction by redirecting to the NEAR Wallet\n     * @see {@link WalletConnection#requestSignTransactions}\n     * @param options An optional options object\n     * @param options.receiverId The NEAR account ID of the transaction receiver.\n     * @param options.actions An array of transaction actions to be performed.\n     * @param options.walletMeta Additional metadata to be included in the wallet signing request.\n     * @param options.walletCallbackUrl URL to redirect upon completion of the wallet signing process. Default: current URL.\n     */\n    async signAndSendTransaction({ receiverId, actions, walletMeta, walletCallbackUrl = window.location.href }) {\n        const localKey = await this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);\n        let accessKey = await this.accessKeyForTransaction(receiverId, actions, localKey);\n        if (!accessKey) {\n            throw new Error(`Cannot find matching key for transaction sent to ${receiverId}`);\n        }\n        if (localKey && localKey.toString() === accessKey.public_key) {\n            try {\n                return await super.signAndSendTransaction({ receiverId, actions });\n            }\n            catch (e) {\n                if (e.type === 'NotEnoughAllowance') {\n                    accessKey = await this.accessKeyForTransaction(receiverId, actions);\n                }\n                else {\n                    throw e;\n                }\n            }\n        }\n        const block = await this.connection.provider.block({ finality: 'final' });\n        const blockHash = (0, utils_1.baseDecode)(block.header.hash);\n        const publicKey = crypto_1.PublicKey.from(accessKey.public_key);\n        // TODO: Cache & listen for nonce updates for given access key\n        const nonce = accessKey.access_key.nonce + 1n;\n        const transaction = (0, transactions_1.createTransaction)(this.accountId, publicKey, receiverId, nonce, actions, blockHash);\n        await this.walletConnection.requestSignTransactions({\n            transactions: [transaction],\n            meta: walletMeta,\n            callbackUrl: walletCallbackUrl\n        });\n        return new Promise((resolve, reject) => {\n            setTimeout(() => {\n                reject(new Error('Failed to redirect to sign transaction'));\n            }, 1000);\n        });\n        // TODO: Aggregate multiple transaction request with \"debounce\".\n        // TODO: Introduce TransactionQueue which also can be used to watch for status?\n    }\n    /**\n     * Check if given access key allows the function call or method attempted in transaction\n     * @param accessKey Array of \\{access_key: AccessKey, public_key: PublicKey\\} items\n     * @param receiverId The NEAR account attempting to have access\n     * @param actions The action(s) needed to be checked for access\n     */\n    async accessKeyMatchesTransaction(accessKey, receiverId, actions) {\n        const { access_key: { permission } } = accessKey;\n        if (permission === 'FullAccess') {\n            return true;\n        }\n        if (permission.FunctionCall) {\n            const { receiver_id: allowedReceiverId, method_names: allowedMethods } = permission.FunctionCall;\n            /********************************\n            Accept multisig access keys and let wallets attempt to signAndSendTransaction\n            If an access key has itself as receiverId and method permission add_request_and_confirm, then it is being used in a wallet with multisig contract: https://github.com/near/core-contracts/blob/671c05f09abecabe7a7e58efe942550a35fc3292/multisig/src/lib.rs#L149-L153\n            ********************************/\n            if (allowedReceiverId === this.accountId && allowedMethods.includes(MULTISIG_HAS_METHOD)) {\n                return true;\n            }\n            if (allowedReceiverId === receiverId) {\n                if (actions.length !== 1) {\n                    return false;\n                }\n                const [{ functionCall }] = actions;\n                return functionCall &&\n                    (!functionCall.deposit || functionCall.deposit.toString() === '0') && // TODO: Should support charging amount smaller than allowance?\n                    (allowedMethods.length === 0 || allowedMethods.includes(functionCall.methodName));\n                // TODO: Handle cases when allowance doesn't have enough to pay for gas\n            }\n        }\n        // TODO: Support other permissions than FunctionCall\n        return false;\n    }\n    /**\n     * Helper function returning the access key (if it exists) to the receiver that grants the designated permission\n     * @param receiverId The NEAR account seeking the access key for a transaction\n     * @param actions The action(s) sought to gain access to\n     * @param localKey A local public key provided to check for access\n     */\n    async accessKeyForTransaction(receiverId, actions, localKey) {\n        const accessKeys = await this.getAccessKeys();\n        if (localKey) {\n            const accessKey = accessKeys.find(key => key.public_key.toString() === localKey.toString());\n            if (accessKey && await this.accessKeyMatchesTransaction(accessKey, receiverId, actions)) {\n                return accessKey;\n            }\n        }\n        const walletKeys = this.walletConnection._authData.allKeys;\n        for (const accessKey of accessKeys) {\n            if (walletKeys.indexOf(accessKey.public_key) !== -1 && await this.accessKeyMatchesTransaction(accessKey, receiverId, actions)) {\n                return accessKey;\n            }\n        }\n        return null;\n    }\n}\nexports.ConnectedWalletAccount = ConnectedWalletAccount;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrd2FsbGV0LWFjY291bnRAMS4zLjEvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL3dhbGxldC1hY2NvdW50L2xpYi9jb21tb25qcy93YWxsZXRfYWNjb3VudC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsOEJBQThCLEdBQUcsd0JBQXdCO0FBQ3pEO0FBQ0E7QUFDQSxNQUFNLHdCQUF3QjtBQUM5QixNQUFNLDhCQUE4QixPQUFPLHFEQUFxRCwwQkFBMEIsd0JBQXdCO0FBQ2xKO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLG1JQUFtQjtBQUM5QyxpQkFBaUIsbUJBQU8sQ0FBQyw2SEFBaUI7QUFDMUMsZ0JBQWdCLG1CQUFPLENBQUMsMEhBQWdCO0FBQ3hDLHVCQUF1QixtQkFBTyxDQUFDLCtJQUF1QjtBQUN0RCxnQkFBZ0IsbUJBQU8sQ0FBQyx5RkFBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qix1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsaURBQWlEO0FBQ3BHO0FBQ0E7QUFDQSw2QkFBNkIsc0VBQXNFO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaURBQWlEO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpQ0FBaUM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxJQUFJLGVBQWUsZ0RBQWdELHdCQUF3QjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsMkVBQTJFO0FBQzlHO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixXQUFXO0FBQzNGO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxxQkFBcUI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsbUJBQW1CO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsK0NBQStDO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWMsZUFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwrREFBK0Q7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixjQUFjO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oYWNrYXRob24tbmVhci1yZWRhY3RlZC8uL25vZGVfbW9kdWxlcy8ucG5wbS9AbmVhci1qcyt3YWxsZXQtYWNjb3VudEAxLjMuMS9ub2RlX21vZHVsZXMvQG5lYXItanMvd2FsbGV0LWFjY291bnQvbGliL2NvbW1vbmpzL3dhbGxldF9hY2NvdW50LmNqcz9kZmI0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db25uZWN0ZWRXYWxsZXRBY2NvdW50ID0gZXhwb3J0cy5XYWxsZXRDb25uZWN0aW9uID0gdm9pZCAwO1xuLyoqXG4gKiBUaGlzIG1vZHVsZSBleHBvc2VzIHR3byBjbGFzc2VzOlxuICogKiB7QGxpbmsgV2FsbGV0Q29ubmVjdGlvbn0gd2hpY2ggcmVkaXJlY3RzIHVzZXJzIHRvIFtORUFSIFdhbGxldF0oaHR0cHM6Ly93YWxsZXQubmVhci5vcmcvKSBmb3Iga2V5IG1hbmFnZW1lbnQuXG4gKiAqIHtAbGluayBDb25uZWN0ZWRXYWxsZXRBY2NvdW50fSBpcyBhbiB7QGxpbmsgXCJAbmVhci1qcy9hY2NvdW50c1wiLmFjY291bnQuQWNjb3VudCB8IEFjY291bnR9IGltcGxlbWVudGF0aW9uIHRoYXQgdXNlcyB7QGxpbmsgV2FsbGV0Q29ubmVjdGlvbn0gdG8gZ2V0IGtleXNcbiAqXG4gKiBAbW9kdWxlIHdhbGxldEFjY291bnRcbiAqL1xuY29uc3QgYWNjb3VudHNfMSA9IHJlcXVpcmUoXCJAbmVhci1qcy9hY2NvdW50c1wiKTtcbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcIkBuZWFyLWpzL2NyeXB0b1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG5lYXItanMvdXRpbHNcIik7XG5jb25zdCB0cmFuc2FjdGlvbnNfMSA9IHJlcXVpcmUoXCJAbmVhci1qcy90cmFuc2FjdGlvbnNcIik7XG5jb25zdCBib3JzaF8xID0gcmVxdWlyZShcImJvcnNoXCIpO1xuY29uc3QgTE9HSU5fV0FMTEVUX1VSTF9TVUZGSVggPSAnL2xvZ2luLyc7XG5jb25zdCBNVUxUSVNJR19IQVNfTUVUSE9EID0gJ2FkZF9yZXF1ZXN0X2FuZF9jb25maXJtJztcbmNvbnN0IExPQ0FMX1NUT1JBR0VfS0VZX1NVRkZJWCA9ICdfd2FsbGV0X2F1dGhfa2V5JztcbmNvbnN0IFBFTkRJTkdfQUNDRVNTX0tFWV9QUkVGSVggPSAncGVuZGluZ19rZXknOyAvLyBicm93c2VyIHN0b3JhZ2Uga2V5IGZvciBhIHBlbmRpbmcgYWNjZXNzIGtleSAoaS5lLiBrZXkgaGFzIGJlZW4gZ2VuZXJhdGVkIGJ1dCB3ZSBhcmUgbm90IHN1cmUgaXQgd2FzIGFkZGVkIHlldClcbi8qKlxuICogVGhpcyBjbGFzcyBpcyBub3QgaW50ZW5kZWQgZm9yIHVzZSBvdXRzaWRlIHRoZSBicm93c2VyLiBXaXRob3V0IGB3aW5kb3dgIChpLmUuIGluIHNlcnZlciBjb250ZXh0cyksIGl0IHdpbGwgaW5zdGFudGlhdGUgYnV0IHdpbGwgdGhyb3cgYSBjbGVhciBlcnJvciB3aGVuIHVzZWQuXG4gKlxuICogQHNlZSBbaHR0cHM6Ly9kb2NzLm5lYXIub3JnL3Rvb2xzL25lYXItYXBpLWpzL3F1aWNrLXJlZmVyZW5jZSN3YWxsZXRdKGh0dHBzOi8vZG9jcy5uZWFyLm9yZy90b29scy9uZWFyLWFwaS1qcy9xdWljay1yZWZlcmVuY2Ujd2FsbGV0KVxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiAvLyBjcmVhdGUgbmV3IFdhbGxldENvbm5lY3Rpb24gaW5zdGFuY2VcbiAqIGNvbnN0IHdhbGxldCA9IG5ldyBXYWxsZXRDb25uZWN0aW9uKG5lYXIsICdteS1hcHAnKTtcbiAqXG4gKiAvLyBJZiBub3Qgc2lnbmVkIGluIHJlZGlyZWN0IHRvIHRoZSBORUFSIHdhbGxldCB0byBzaWduIGluXG4gKiAvLyBrZXlzIHdpbGwgYmUgc3RvcmVkIGluIHRoZSBCcm93c2VyTG9jYWxTdG9yYWdlS2V5U3RvcmVcbiAqIGlmKCF3YWxsZXQuaXNTaWduZWRJbigpKSByZXR1cm4gd2FsbGV0LnJlcXVlc3RTaWduSW4oKVxuICogYGBgXG4gKi9cbmNsYXNzIFdhbGxldENvbm5lY3Rpb24ge1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgX3dhbGxldEJhc2VVcmw7XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBfYXV0aERhdGFLZXk7XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBfa2V5U3RvcmU7XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBfYXV0aERhdGE7XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBfbmV0d29ya0lkO1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgLy8gX25lYXI6IE5lYXI7XG4gICAgX25lYXI7XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBfY29ubmVjdGVkQWNjb3VudDtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIF9jb21wbGV0ZVNpZ25JblByb21pc2U7XG4gICAgY29uc3RydWN0b3IobmVhciwgYXBwS2V5UHJlZml4KSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGFwcEtleVByZWZpeCkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBkZWZpbmUgYSBjbGVhciBhcHBLZXlQcmVmaXggZm9yIHRoaXMgV2FsbGV0Q29ubmVjdGlvbiBpbnN0YW5jZSBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIHRoZSBjb25zdHJ1Y3RvcicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm94eSh0aGlzLCB7XG4gICAgICAgICAgICAgICAgZ2V0KHRhcmdldCwgcHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5ID09PSAnaXNTaWduZWRJbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydHkgPT09ICdnZXRBY2NvdW50SWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldFtwcm9wZXJ0eV0gJiYgdHlwZW9mIHRhcmdldFtwcm9wZXJ0eV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB3aW5kb3cgZm91bmQgaW4gY29udGV4dCwgcGxlYXNlIGVuc3VyZSB5b3UgYXJlIHVzaW5nIFdhbGxldENvbm5lY3Rpb24gb24gdGhlIGJyb3dzZXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldFtwcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbmVhciA9IG5lYXI7XG4gICAgICAgIGNvbnN0IGF1dGhEYXRhS2V5ID0gYXBwS2V5UHJlZml4ICsgTE9DQUxfU1RPUkFHRV9LRVlfU1VGRklYO1xuICAgICAgICBjb25zdCBhdXRoRGF0YSA9IEpTT04ucGFyc2Uod2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKGF1dGhEYXRhS2V5KSk7XG4gICAgICAgIHRoaXMuX25ldHdvcmtJZCA9IG5lYXIuY29uZmlnLm5ldHdvcmtJZDtcbiAgICAgICAgdGhpcy5fd2FsbGV0QmFzZVVybCA9IG5lYXIuY29uZmlnLndhbGxldFVybDtcbiAgICAgICAgYXBwS2V5UHJlZml4ID0gYXBwS2V5UHJlZml4IHx8IG5lYXIuY29uZmlnLmNvbnRyYWN0TmFtZSB8fCAnZGVmYXVsdCc7XG4gICAgICAgIHRoaXMuX2tleVN0b3JlID0gbmVhci5jb25uZWN0aW9uLnNpZ25lci5rZXlTdG9yZTtcbiAgICAgICAgdGhpcy5fYXV0aERhdGEgPSBhdXRoRGF0YSB8fCB7IGFsbEtleXM6IFtdIH07XG4gICAgICAgIHRoaXMuX2F1dGhEYXRhS2V5ID0gYXV0aERhdGFLZXk7XG4gICAgICAgIGlmICghdGhpcy5pc1NpZ25lZEluKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbXBsZXRlU2lnbkluUHJvbWlzZSA9IHRoaXMuX2NvbXBsZXRlU2lnbkluV2l0aEFjY2Vzc0tleSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSwgaWYgdGhpcyBXYWxsZXRDb25uZWN0aW9uIGlzIGF1dGhvcml6ZWQgd2l0aCB0aGUgd2FsbGV0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCB3YWxsZXQgPSBuZXcgV2FsbGV0Q29ubmVjdGlvbihuZWFyLCAnbXktYXBwJyk7XG4gICAgICogd2FsbGV0LmlzU2lnbmVkSW4oKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBpc1NpZ25lZEluKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9hdXRoRGF0YS5hY2NvdW50SWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcHJvbWlzZSBvZiBjb21wbGV0aW5nIHNpZ25pbmcgaW4gYWZ0ZXIgcmVkaXJlY3RpbmcgZnJvbSB3YWxsZXRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogLy8gb24gbG9naW4gY2FsbGJhY2sgcGFnZVxuICAgICAqIGNvbnN0IHdhbGxldCA9IG5ldyBXYWxsZXRDb25uZWN0aW9uKG5lYXIsICdteS1hcHAnKTtcbiAgICAgKiB3YWxsZXQuaXNTaWduZWRJbigpOyAvLyBmYWxzZVxuICAgICAqIGF3YWl0IHdhbGxldC5pc1NpZ25lZEluQXN5bmMoKTsgLy8gdHJ1ZVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGlzU2lnbmVkSW5Bc3luYygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jb21wbGV0ZVNpZ25JblByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzU2lnbmVkSW4oKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLl9jb21wbGV0ZVNpZ25JblByb21pc2U7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU2lnbmVkSW4oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhdXRob3JpemVkIEFjY291bnQgSUQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IHdhbGxldCA9IG5ldyBXYWxsZXRDb25uZWN0aW9uKG5lYXIsICdteS1hcHAnKTtcbiAgICAgKiB3YWxsZXQuZ2V0QWNjb3VudElkKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0QWNjb3VudElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXV0aERhdGEuYWNjb3VudElkIHx8ICcnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIHN0cmluZyBVUkwgdG8gdGhlIHdhbGxldCBhdXRoZW50aWNhdGlvbiBwYWdlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIEFuIG9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIG9wdGlvbnMuY29udHJhY3RJZCBUaGUgTkVBUiBhY2NvdW50IHdoZXJlIHRoZSBjb250cmFjdCBpcyBkZXBsb3llZFxuICAgICAqIEBwYXJhbSBvcHRpb25zLnN1Y2Nlc3NVcmwgVVJMIHRvIHJlZGlyZWN0IHVwb24gc3VjY2Vzcy4gRGVmYXVsdDogY3VycmVudCB1cmxcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5mYWlsdXJlVXJsIFVSTCB0byByZWRpcmVjdCB1cG9uIGZhaWx1cmUuIERlZmF1bHQ6IGN1cnJlbnQgdXJsXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3Qgd2FsbGV0ID0gbmV3IFdhbGxldENvbm5lY3Rpb24obmVhciwgJ215LWFwcCcpO1xuICAgICAqIC8vIHJldHVybiBzdHJpbmcgVVJMIHRvIHRoZSBORUFSIFdhbGxldFxuICAgICAqIGNvbnN0IHVybCA9IGF3YWl0IHdhbGxldC5yZXF1ZXN0U2lnbkluVXJsKHsgY29udHJhY3RJZDogJ2FjY291bnQtd2l0aC1kZXBsb3ktY29udHJhY3QubmVhcicgfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgcmVxdWVzdFNpZ25JblVybCh7IGNvbnRyYWN0SWQsIG1ldGhvZE5hbWVzLCBzdWNjZXNzVXJsLCBmYWlsdXJlVXJsLCBrZXlUeXBlID0gJ2VkMjU1MTknIH0pIHtcbiAgICAgICAgY29uc3QgY3VycmVudFVybCA9IG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICBjb25zdCBuZXdVcmwgPSBuZXcgVVJMKHRoaXMuX3dhbGxldEJhc2VVcmwgKyBMT0dJTl9XQUxMRVRfVVJMX1NVRkZJWCk7XG4gICAgICAgIG5ld1VybC5zZWFyY2hQYXJhbXMuc2V0KCdzdWNjZXNzX3VybCcsIHN1Y2Nlc3NVcmwgfHwgY3VycmVudFVybC5ocmVmKTtcbiAgICAgICAgbmV3VXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2ZhaWx1cmVfdXJsJywgZmFpbHVyZVVybCB8fCBjdXJyZW50VXJsLmhyZWYpO1xuICAgICAgICBpZiAoY29udHJhY3RJZCkge1xuICAgICAgICAgICAgLyogVGhyb3dzIGV4Y2VwdGlvbiBpZiBjb250cmFjdCBhY2NvdW50IGRvZXMgbm90IGV4aXN0ICovXG4gICAgICAgICAgICBjb25zdCBjb250cmFjdEFjY291bnQgPSBhd2FpdCB0aGlzLl9uZWFyLmFjY291bnQoY29udHJhY3RJZCk7XG4gICAgICAgICAgICBhd2FpdCBjb250cmFjdEFjY291bnQuc3RhdGUoKTtcbiAgICAgICAgICAgIG5ld1VybC5zZWFyY2hQYXJhbXMuc2V0KCdjb250cmFjdF9pZCcsIGNvbnRyYWN0SWQpO1xuICAgICAgICAgICAgY29uc3QgYWNjZXNzS2V5ID0gY3J5cHRvXzEuS2V5UGFpci5mcm9tUmFuZG9tKGtleVR5cGUpO1xuICAgICAgICAgICAgbmV3VXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3B1YmxpY19rZXknLCBhY2Nlc3NLZXkuZ2V0UHVibGljS2V5KCkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9rZXlTdG9yZS5zZXRLZXkodGhpcy5fbmV0d29ya0lkLCBQRU5ESU5HX0FDQ0VTU19LRVlfUFJFRklYICsgYWNjZXNzS2V5LmdldFB1YmxpY0tleSgpLCBhY2Nlc3NLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRob2ROYW1lcykge1xuICAgICAgICAgICAgbWV0aG9kTmFtZXMuZm9yRWFjaChtZXRob2ROYW1lID0+IHtcbiAgICAgICAgICAgICAgICBuZXdVcmwuc2VhcmNoUGFyYW1zLmFwcGVuZCgnbWV0aG9kTmFtZXMnLCBtZXRob2ROYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdVcmwudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVkaXJlY3RzIGN1cnJlbnQgcGFnZSB0byB0aGUgd2FsbGV0IGF1dGhlbnRpY2F0aW9uIHBhZ2UuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQW4gb3B0aW9uYWwgb3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jb250cmFjdElkIFRoZSBORUFSIGFjY291bnQgd2hlcmUgdGhlIGNvbnRyYWN0IGlzIGRlcGxveWVkXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc3VjY2Vzc1VybCBVUkwgdG8gcmVkaXJlY3QgdXBvbiBzdWNjZXNzLiBEZWZhdWx0OiBjdXJyZW50IHVybFxuICAgICAqIEBwYXJhbSBvcHRpb25zLmZhaWx1cmVVcmwgVVJMIHRvIHJlZGlyZWN0IHVwb24gZmFpbHVyZS4gRGVmYXVsdDogY3VycmVudCB1cmxcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCB3YWxsZXQgPSBuZXcgV2FsbGV0Q29ubmVjdGlvbihuZWFyLCAnbXktYXBwJyk7XG4gICAgICogLy8gcmVkaXJlY3RzIHRvIHRoZSBORUFSIFdhbGxldFxuICAgICAqIHdhbGxldC5yZXF1ZXN0U2lnbkluKHsgY29udHJhY3RJZDogJ2FjY291bnQtd2l0aC1kZXBsb3ktY29udHJhY3QubmVhcicgfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgcmVxdWVzdFNpZ25JbihvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGF3YWl0IHRoaXMucmVxdWVzdFNpZ25JblVybChvcHRpb25zKTtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbih1cmwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIHN0cmluZyBVUkwgdG8gdGhlIHdhbGxldCB0byBzaWduIGEgdHJhbnNhY3Rpb24gb3IgYmF0Y2ggb2YgdHJhbnNhY3Rpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQSByZXF1aXJlZCBvcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSBvcHRpb25zLnRyYW5zYWN0aW9ucyBMaXN0IG9mIHRyYW5zYWN0aW9ucyB0byBzaWduXG4gICAgICogQHBhcmFtIG9wdGlvbnMuY2FsbGJhY2tVcmwgVVJMIHRvIHJlZGlyZWN0IHVwb24gc3VjY2Vzcy4gRGVmYXVsdDogY3VycmVudCB1cmxcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5tZXRhIE1ldGEgaW5mb3JtYXRpb24gdGhlIHdhbGxldCB3aWxsIHNlbmQgYmFjayB0byB0aGUgYXBwbGljYXRpb24uIGBtZXRhYCB3aWxsIGJlIGF0dGFjaGVkIHRvIHRoZSBgY2FsbGJhY2tVcmxgIGFzIGEgdXJsIHNlYXJjaCBwYXJhbVxuICAgICAqXG4gICAgICovXG4gICAgcmVxdWVzdFNpZ25UcmFuc2FjdGlvbnNVcmwoeyB0cmFuc2FjdGlvbnMsIG1ldGEsIGNhbGxiYWNrVXJsIH0pIHtcbiAgICAgICAgY29uc3QgY3VycmVudFVybCA9IG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICBjb25zdCBuZXdVcmwgPSBuZXcgVVJMKCdzaWduJywgdGhpcy5fd2FsbGV0QmFzZVVybCk7XG4gICAgICAgIG5ld1VybC5zZWFyY2hQYXJhbXMuc2V0KCd0cmFuc2FjdGlvbnMnLCB0cmFuc2FjdGlvbnNcbiAgICAgICAgICAgIC5tYXAodHJhbnNhY3Rpb24gPT4gKDAsIGJvcnNoXzEuc2VyaWFsaXplKSh0cmFuc2FjdGlvbnNfMS5TQ0hFTUEuVHJhbnNhY3Rpb24sIHRyYW5zYWN0aW9uKSlcbiAgICAgICAgICAgIC5tYXAoc2VyaWFsaXplZCA9PiBCdWZmZXIuZnJvbShzZXJpYWxpemVkKS50b1N0cmluZygnYmFzZTY0JykpXG4gICAgICAgICAgICAuam9pbignLCcpKTtcbiAgICAgICAgbmV3VXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2NhbGxiYWNrVXJsJywgY2FsbGJhY2tVcmwgfHwgY3VycmVudFVybC5ocmVmKTtcbiAgICAgICAgaWYgKG1ldGEpXG4gICAgICAgICAgICBuZXdVcmwuc2VhcmNoUGFyYW1zLnNldCgnbWV0YScsIG1ldGEpO1xuICAgICAgICByZXR1cm4gbmV3VXJsLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3RzIHRoZSB1c2VyIHRvIHF1aWNrbHkgc2lnbiBmb3IgYSB0cmFuc2FjdGlvbiBvciBiYXRjaCBvZiB0cmFuc2FjdGlvbnMgYnkgcmVkaXJlY3RpbmcgdG8gdGhlIHdhbGxldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIEEgcmVxdWlyZWQgb3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy50cmFuc2FjdGlvbnMgTGlzdCBvZiB0cmFuc2FjdGlvbnMgdG8gc2lnblxuICAgICAqIEBwYXJhbSBvcHRpb25zLmNhbGxiYWNrVXJsIFVSTCB0byByZWRpcmVjdCB1cG9uIHN1Y2Nlc3MuIERlZmF1bHQ6IGN1cnJlbnQgdXJsXG4gICAgICogQHBhcmFtIG9wdGlvbnMubWV0YSBNZXRhIGluZm9ybWF0aW9uIHRoZSB3YWxsZXQgd2lsbCBzZW5kIGJhY2sgdG8gdGhlIGFwcGxpY2F0aW9uLiBgbWV0YWAgd2lsbCBiZSBhdHRhY2hlZCB0byB0aGUgYGNhbGxiYWNrVXJsYCBhcyBhIHVybCBzZWFyY2ggcGFyYW1cbiAgICAgKlxuICAgICAqL1xuICAgIHJlcXVlc3RTaWduVHJhbnNhY3Rpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdXJsID0gdGhpcy5yZXF1ZXN0U2lnblRyYW5zYWN0aW9uc1VybChvcHRpb25zKTtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbih1cmwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQ29tcGxldGUgc2lnbiBpbiBmb3IgYSBnaXZlbiBhY2NvdW50IGlkIGFuZCBwdWJsaWMga2V5LiBUbyBiZSBpbnZva2VkIGJ5IHRoZSBhcHAgd2hlbiBnZXR0aW5nIGEgY2FsbGJhY2sgZnJvbSB0aGUgd2FsbGV0LlxuICAgICAqL1xuICAgIGFzeW5jIF9jb21wbGV0ZVNpZ25JbldpdGhBY2Nlc3NLZXkoKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRVcmwgPSBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgY29uc3QgcHVibGljS2V5ID0gY3VycmVudFVybC5zZWFyY2hQYXJhbXMuZ2V0KCdwdWJsaWNfa2V5JykgfHwgJyc7XG4gICAgICAgIGNvbnN0IGFsbEtleXMgPSAoY3VycmVudFVybC5zZWFyY2hQYXJhbXMuZ2V0KCdhbGxfa2V5cycpIHx8ICcnKS5zcGxpdCgnLCcpO1xuICAgICAgICBjb25zdCBhY2NvdW50SWQgPSBjdXJyZW50VXJsLnNlYXJjaFBhcmFtcy5nZXQoJ2FjY291bnRfaWQnKSB8fCAnJztcbiAgICAgICAgLy8gVE9ETzogSGFuZGxlIGVycm9ycyBkdXJpbmcgbG9naW5cbiAgICAgICAgaWYgKGFjY291bnRJZCkge1xuICAgICAgICAgICAgY29uc3QgYXV0aERhdGEgPSB7XG4gICAgICAgICAgICAgICAgYWNjb3VudElkLFxuICAgICAgICAgICAgICAgIGFsbEtleXNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0odGhpcy5fYXV0aERhdGFLZXksIEpTT04uc3RyaW5naWZ5KGF1dGhEYXRhKSk7XG4gICAgICAgICAgICBpZiAocHVibGljS2V5KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbW92ZUtleUZyb21UZW1wVG9QZXJtYW5lbnQoYWNjb3VudElkLCBwdWJsaWNLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYXV0aERhdGEgPSBhdXRoRGF0YTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50VXJsLnNlYXJjaFBhcmFtcy5kZWxldGUoJ3B1YmxpY19rZXknKTtcbiAgICAgICAgY3VycmVudFVybC5zZWFyY2hQYXJhbXMuZGVsZXRlKCdhbGxfa2V5cycpO1xuICAgICAgICBjdXJyZW50VXJsLnNlYXJjaFBhcmFtcy5kZWxldGUoJ2FjY291bnRfaWQnKTtcbiAgICAgICAgY3VycmVudFVybC5zZWFyY2hQYXJhbXMuZGVsZXRlKCdtZXRhJyk7XG4gICAgICAgIGN1cnJlbnRVcmwuc2VhcmNoUGFyYW1zLmRlbGV0ZSgndHJhbnNhY3Rpb25IYXNoZXMnKTtcbiAgICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHt9LCBkb2N1bWVudC50aXRsZSwgY3VycmVudFVybC50b1N0cmluZygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBwYXJhbSBhY2NvdW50SWQgVGhlIE5FQVIgYWNjb3VudCBvd25pbmcgdGhlIGdpdmVuIHB1YmxpYyBrZXlcbiAgICAgKiBAcGFyYW0gcHVibGljS2V5IFRoZSBwdWJsaWMga2V5IGJlaW5nIHNldCB0byB0aGUga2V5IHN0b3JlXG4gICAgICovXG4gICAgYXN5bmMgX21vdmVLZXlGcm9tVGVtcFRvUGVybWFuZW50KGFjY291bnRJZCwgcHVibGljS2V5KSB7XG4gICAgICAgIGNvbnN0IGtleVBhaXIgPSBhd2FpdCB0aGlzLl9rZXlTdG9yZS5nZXRLZXkodGhpcy5fbmV0d29ya0lkLCBQRU5ESU5HX0FDQ0VTU19LRVlfUFJFRklYICsgcHVibGljS2V5KTtcbiAgICAgICAgYXdhaXQgdGhpcy5fa2V5U3RvcmUuc2V0S2V5KHRoaXMuX25ldHdvcmtJZCwgYWNjb3VudElkLCBrZXlQYWlyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fa2V5U3RvcmUucmVtb3ZlS2V5KHRoaXMuX25ldHdvcmtJZCwgUEVORElOR19BQ0NFU1NfS0VZX1BSRUZJWCArIHB1YmxpY0tleSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ24gb3V0IGZyb20gdGhlIGN1cnJlbnQgYWNjb3VudFxuICAgICAqIEBleGFtcGxlXG4gICAgICogd2FsbGV0Q29ubmVjdGlvbi5zaWduT3V0KCk7XG4gICAgICovXG4gICAgc2lnbk91dCgpIHtcbiAgICAgICAgdGhpcy5fYXV0aERhdGEgPSB7fTtcbiAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMuX2F1dGhEYXRhS2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBjb25uZWN0ZWQgd2FsbGV0IGFjY291bnRcbiAgICAgKi9cbiAgICBhY2NvdW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuX2Nvbm5lY3RlZEFjY291bnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3RlZEFjY291bnQgPSBuZXcgQ29ubmVjdGVkV2FsbGV0QWNjb3VudCh0aGlzLCB0aGlzLl9uZWFyLmNvbm5lY3Rpb24sIHRoaXMuX2F1dGhEYXRhLmFjY291bnRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3RlZEFjY291bnQ7XG4gICAgfVxufVxuZXhwb3J0cy5XYWxsZXRDb25uZWN0aW9uID0gV2FsbGV0Q29ubmVjdGlvbjtcbi8qKlxuICoge0BsaW5rIEFjY291bnR9IGltcGxlbWVudGF0aW9uIHdoaWNoIHJlZGlyZWN0cyB0byB3YWxsZXQgdXNpbmcge0BsaW5rIFdhbGxldENvbm5lY3Rpb259IHdoZW4gbm8gbG9jYWwga2V5IGlzIGF2YWlsYWJsZS5cbiAqL1xuY2xhc3MgQ29ubmVjdGVkV2FsbGV0QWNjb3VudCBleHRlbmRzIGFjY291bnRzXzEuQWNjb3VudCB7XG4gICAgd2FsbGV0Q29ubmVjdGlvbjtcbiAgICBjb25zdHJ1Y3Rvcih3YWxsZXRDb25uZWN0aW9uLCBjb25uZWN0aW9uLCBhY2NvdW50SWQpIHtcbiAgICAgICAgc3VwZXIoY29ubmVjdGlvbiwgYWNjb3VudElkKTtcbiAgICAgICAgdGhpcy53YWxsZXRDb25uZWN0aW9uID0gd2FsbGV0Q29ubmVjdGlvbjtcbiAgICB9XG4gICAgLy8gT3ZlcnJpZGluZyBBY2NvdW50IG1ldGhvZHNcbiAgICAvKipcbiAgICAgKiBTaWduIGEgdHJhbnNhY3Rpb24gYnkgcmVkaXJlY3RpbmcgdG8gdGhlIE5FQVIgV2FsbGV0XG4gICAgICogQHNlZSB7QGxpbmsgV2FsbGV0Q29ubmVjdGlvbiNyZXF1ZXN0U2lnblRyYW5zYWN0aW9uc31cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBBbiBvcHRpb25hbCBvcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSBvcHRpb25zLnJlY2VpdmVySWQgVGhlIE5FQVIgYWNjb3VudCBJRCBvZiB0aGUgdHJhbnNhY3Rpb24gcmVjZWl2ZXIuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYWN0aW9ucyBBbiBhcnJheSBvZiB0cmFuc2FjdGlvbiBhY3Rpb25zIHRvIGJlIHBlcmZvcm1lZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy53YWxsZXRNZXRhIEFkZGl0aW9uYWwgbWV0YWRhdGEgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIHdhbGxldCBzaWduaW5nIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIG9wdGlvbnMud2FsbGV0Q2FsbGJhY2tVcmwgVVJMIHRvIHJlZGlyZWN0IHVwb24gY29tcGxldGlvbiBvZiB0aGUgd2FsbGV0IHNpZ25pbmcgcHJvY2Vzcy4gRGVmYXVsdDogY3VycmVudCBVUkwuXG4gICAgICovXG4gICAgYXN5bmMgc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih7IHJlY2VpdmVySWQsIGFjdGlvbnMsIHdhbGxldE1ldGEsIHdhbGxldENhbGxiYWNrVXJsID0gd2luZG93LmxvY2F0aW9uLmhyZWYgfSkge1xuICAgICAgICBjb25zdCBsb2NhbEtleSA9IGF3YWl0IHRoaXMuY29ubmVjdGlvbi5zaWduZXIuZ2V0UHVibGljS2V5KHRoaXMuYWNjb3VudElkLCB0aGlzLmNvbm5lY3Rpb24ubmV0d29ya0lkKTtcbiAgICAgICAgbGV0IGFjY2Vzc0tleSA9IGF3YWl0IHRoaXMuYWNjZXNzS2V5Rm9yVHJhbnNhY3Rpb24ocmVjZWl2ZXJJZCwgYWN0aW9ucywgbG9jYWxLZXkpO1xuICAgICAgICBpZiAoIWFjY2Vzc0tleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZmluZCBtYXRjaGluZyBrZXkgZm9yIHRyYW5zYWN0aW9uIHNlbnQgdG8gJHtyZWNlaXZlcklkfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhbEtleSAmJiBsb2NhbEtleS50b1N0cmluZygpID09PSBhY2Nlc3NLZXkucHVibGljX2tleSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgc3VwZXIuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih7IHJlY2VpdmVySWQsIGFjdGlvbnMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdOb3RFbm91Z2hBbGxvd2FuY2UnKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY2Vzc0tleSA9IGF3YWl0IHRoaXMuYWNjZXNzS2V5Rm9yVHJhbnNhY3Rpb24ocmVjZWl2ZXJJZCwgYWN0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBibG9jayA9IGF3YWl0IHRoaXMuY29ubmVjdGlvbi5wcm92aWRlci5ibG9jayh7IGZpbmFsaXR5OiAnZmluYWwnIH0pO1xuICAgICAgICBjb25zdCBibG9ja0hhc2ggPSAoMCwgdXRpbHNfMS5iYXNlRGVjb2RlKShibG9jay5oZWFkZXIuaGFzaCk7XG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IGNyeXB0b18xLlB1YmxpY0tleS5mcm9tKGFjY2Vzc0tleS5wdWJsaWNfa2V5KTtcbiAgICAgICAgLy8gVE9ETzogQ2FjaGUgJiBsaXN0ZW4gZm9yIG5vbmNlIHVwZGF0ZXMgZm9yIGdpdmVuIGFjY2VzcyBrZXlcbiAgICAgICAgY29uc3Qgbm9uY2UgPSBhY2Nlc3NLZXkuYWNjZXNzX2tleS5ub25jZSArIDFuO1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9ICgwLCB0cmFuc2FjdGlvbnNfMS5jcmVhdGVUcmFuc2FjdGlvbikodGhpcy5hY2NvdW50SWQsIHB1YmxpY0tleSwgcmVjZWl2ZXJJZCwgbm9uY2UsIGFjdGlvbnMsIGJsb2NrSGFzaCk7XG4gICAgICAgIGF3YWl0IHRoaXMud2FsbGV0Q29ubmVjdGlvbi5yZXF1ZXN0U2lnblRyYW5zYWN0aW9ucyh7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbnM6IFt0cmFuc2FjdGlvbl0sXG4gICAgICAgICAgICBtZXRhOiB3YWxsZXRNZXRhLFxuICAgICAgICAgICAgY2FsbGJhY2tVcmw6IHdhbGxldENhbGxiYWNrVXJsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIHJlZGlyZWN0IHRvIHNpZ24gdHJhbnNhY3Rpb24nKSk7XG4gICAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRPRE86IEFnZ3JlZ2F0ZSBtdWx0aXBsZSB0cmFuc2FjdGlvbiByZXF1ZXN0IHdpdGggXCJkZWJvdW5jZVwiLlxuICAgICAgICAvLyBUT0RPOiBJbnRyb2R1Y2UgVHJhbnNhY3Rpb25RdWV1ZSB3aGljaCBhbHNvIGNhbiBiZSB1c2VkIHRvIHdhdGNoIGZvciBzdGF0dXM/XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGdpdmVuIGFjY2VzcyBrZXkgYWxsb3dzIHRoZSBmdW5jdGlvbiBjYWxsIG9yIG1ldGhvZCBhdHRlbXB0ZWQgaW4gdHJhbnNhY3Rpb25cbiAgICAgKiBAcGFyYW0gYWNjZXNzS2V5IEFycmF5IG9mIFxce2FjY2Vzc19rZXk6IEFjY2Vzc0tleSwgcHVibGljX2tleTogUHVibGljS2V5XFx9IGl0ZW1zXG4gICAgICogQHBhcmFtIHJlY2VpdmVySWQgVGhlIE5FQVIgYWNjb3VudCBhdHRlbXB0aW5nIHRvIGhhdmUgYWNjZXNzXG4gICAgICogQHBhcmFtIGFjdGlvbnMgVGhlIGFjdGlvbihzKSBuZWVkZWQgdG8gYmUgY2hlY2tlZCBmb3IgYWNjZXNzXG4gICAgICovXG4gICAgYXN5bmMgYWNjZXNzS2V5TWF0Y2hlc1RyYW5zYWN0aW9uKGFjY2Vzc0tleSwgcmVjZWl2ZXJJZCwgYWN0aW9ucykge1xuICAgICAgICBjb25zdCB7IGFjY2Vzc19rZXk6IHsgcGVybWlzc2lvbiB9IH0gPSBhY2Nlc3NLZXk7XG4gICAgICAgIGlmIChwZXJtaXNzaW9uID09PSAnRnVsbEFjY2VzcycpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwZXJtaXNzaW9uLkZ1bmN0aW9uQ2FsbCkge1xuICAgICAgICAgICAgY29uc3QgeyByZWNlaXZlcl9pZDogYWxsb3dlZFJlY2VpdmVySWQsIG1ldGhvZF9uYW1lczogYWxsb3dlZE1ldGhvZHMgfSA9IHBlcm1pc3Npb24uRnVuY3Rpb25DYWxsO1xuICAgICAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICAgICBBY2NlcHQgbXVsdGlzaWcgYWNjZXNzIGtleXMgYW5kIGxldCB3YWxsZXRzIGF0dGVtcHQgdG8gc2lnbkFuZFNlbmRUcmFuc2FjdGlvblxuICAgICAgICAgICAgSWYgYW4gYWNjZXNzIGtleSBoYXMgaXRzZWxmIGFzIHJlY2VpdmVySWQgYW5kIG1ldGhvZCBwZXJtaXNzaW9uIGFkZF9yZXF1ZXN0X2FuZF9jb25maXJtLCB0aGVuIGl0IGlzIGJlaW5nIHVzZWQgaW4gYSB3YWxsZXQgd2l0aCBtdWx0aXNpZyBjb250cmFjdDogaHR0cHM6Ly9naXRodWIuY29tL25lYXIvY29yZS1jb250cmFjdHMvYmxvYi82NzFjMDVmMDlhYmVjYWJlN2E3ZTU4ZWZlOTQyNTUwYTM1ZmMzMjkyL211bHRpc2lnL3NyYy9saWIucnMjTDE0OS1MMTUzXG4gICAgICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgICAgIGlmIChhbGxvd2VkUmVjZWl2ZXJJZCA9PT0gdGhpcy5hY2NvdW50SWQgJiYgYWxsb3dlZE1ldGhvZHMuaW5jbHVkZXMoTVVMVElTSUdfSEFTX01FVEhPRCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbGxvd2VkUmVjZWl2ZXJJZCA9PT0gcmVjZWl2ZXJJZCkge1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb25zLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IFt7IGZ1bmN0aW9uQ2FsbCB9XSA9IGFjdGlvbnM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uQ2FsbCAmJlxuICAgICAgICAgICAgICAgICAgICAoIWZ1bmN0aW9uQ2FsbC5kZXBvc2l0IHx8IGZ1bmN0aW9uQ2FsbC5kZXBvc2l0LnRvU3RyaW5nKCkgPT09ICcwJykgJiYgLy8gVE9ETzogU2hvdWxkIHN1cHBvcnQgY2hhcmdpbmcgYW1vdW50IHNtYWxsZXIgdGhhbiBhbGxvd2FuY2U/XG4gICAgICAgICAgICAgICAgICAgIChhbGxvd2VkTWV0aG9kcy5sZW5ndGggPT09IDAgfHwgYWxsb3dlZE1ldGhvZHMuaW5jbHVkZXMoZnVuY3Rpb25DYWxsLm1ldGhvZE5hbWUpKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBIYW5kbGUgY2FzZXMgd2hlbiBhbGxvd2FuY2UgZG9lc24ndCBoYXZlIGVub3VnaCB0byBwYXkgZm9yIGdhc1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IFN1cHBvcnQgb3RoZXIgcGVybWlzc2lvbnMgdGhhbiBGdW5jdGlvbkNhbGxcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBhY2Nlc3Mga2V5IChpZiBpdCBleGlzdHMpIHRvIHRoZSByZWNlaXZlciB0aGF0IGdyYW50cyB0aGUgZGVzaWduYXRlZCBwZXJtaXNzaW9uXG4gICAgICogQHBhcmFtIHJlY2VpdmVySWQgVGhlIE5FQVIgYWNjb3VudCBzZWVraW5nIHRoZSBhY2Nlc3Mga2V5IGZvciBhIHRyYW5zYWN0aW9uXG4gICAgICogQHBhcmFtIGFjdGlvbnMgVGhlIGFjdGlvbihzKSBzb3VnaHQgdG8gZ2FpbiBhY2Nlc3MgdG9cbiAgICAgKiBAcGFyYW0gbG9jYWxLZXkgQSBsb2NhbCBwdWJsaWMga2V5IHByb3ZpZGVkIHRvIGNoZWNrIGZvciBhY2Nlc3NcbiAgICAgKi9cbiAgICBhc3luYyBhY2Nlc3NLZXlGb3JUcmFuc2FjdGlvbihyZWNlaXZlcklkLCBhY3Rpb25zLCBsb2NhbEtleSkge1xuICAgICAgICBjb25zdCBhY2Nlc3NLZXlzID0gYXdhaXQgdGhpcy5nZXRBY2Nlc3NLZXlzKCk7XG4gICAgICAgIGlmIChsb2NhbEtleSkge1xuICAgICAgICAgICAgY29uc3QgYWNjZXNzS2V5ID0gYWNjZXNzS2V5cy5maW5kKGtleSA9PiBrZXkucHVibGljX2tleS50b1N0cmluZygpID09PSBsb2NhbEtleS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGlmIChhY2Nlc3NLZXkgJiYgYXdhaXQgdGhpcy5hY2Nlc3NLZXlNYXRjaGVzVHJhbnNhY3Rpb24oYWNjZXNzS2V5LCByZWNlaXZlcklkLCBhY3Rpb25zKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2Nlc3NLZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2FsbGV0S2V5cyA9IHRoaXMud2FsbGV0Q29ubmVjdGlvbi5fYXV0aERhdGEuYWxsS2V5cztcbiAgICAgICAgZm9yIChjb25zdCBhY2Nlc3NLZXkgb2YgYWNjZXNzS2V5cykge1xuICAgICAgICAgICAgaWYgKHdhbGxldEtleXMuaW5kZXhPZihhY2Nlc3NLZXkucHVibGljX2tleSkgIT09IC0xICYmIGF3YWl0IHRoaXMuYWNjZXNzS2V5TWF0Y2hlc1RyYW5zYWN0aW9uKGFjY2Vzc0tleSwgcmVjZWl2ZXJJZCwgYWN0aW9ucykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjZXNzS2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29ubmVjdGVkV2FsbGV0QWNjb3VudCA9IENvbm5lY3RlZFdhbGxldEFjY291bnQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+wallet-account@1.3.1/node_modules/@near-js/wallet-account/lib/commonjs/wallet_account.cjs\n");

/***/ })

};
;