"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@near-js+accounts@1.3.1";
exports.ids = ["vendor-chunks/@near-js+accounts@1.3.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/account.cjs":
/*!************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/account.cjs ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Account = void 0;\nconst crypto_1 = __webpack_require__(/*! @near-js/crypto */ \"(ssr)/./node_modules/.pnpm/@near-js+crypto@1.4.1/node_modules/@near-js/crypto/lib/commonjs/index.cjs\");\nconst providers_1 = __webpack_require__(/*! @near-js/providers */ \"(ssr)/./node_modules/.pnpm/@near-js+providers@1.0.1/node_modules/@near-js/providers/lib/commonjs/index.cjs\");\nconst transactions_1 = __webpack_require__(/*! @near-js/transactions */ \"(ssr)/./node_modules/.pnpm/@near-js+transactions@1.3.1/node_modules/@near-js/transactions/lib/commonjs/index.cjs\");\nconst types_1 = __webpack_require__(/*! @near-js/types */ \"(ssr)/./node_modules/.pnpm/@near-js+types@0.3.1/node_modules/@near-js/types/lib/commonjs/index.cjs\");\nconst utils_1 = __webpack_require__(/*! @near-js/utils */ \"(ssr)/./node_modules/.pnpm/@near-js+utils@1.0.1/node_modules/@near-js/utils/lib/commonjs/index.cjs\");\nconst utils_2 = __webpack_require__(/*! ./utils.cjs */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/utils.cjs\");\nconst { addKey, createAccount, deleteAccount, deleteKey, deployContract, fullAccessKey, functionCall, functionCallAccessKey, stake, transfer, } = transactions_1.actionCreators;\n// Default number of retries with different nonce before giving up on a transaction.\nconst TX_NONCE_RETRY_NUMBER = 12;\n// Default wait until next retry in millis.\nconst TX_NONCE_RETRY_WAIT = 500;\n// Exponential back off for waiting to retry.\nconst TX_NONCE_RETRY_WAIT_BACKOFF = 1.5;\n/**\n * This class provides common account related RPC calls including signing transactions with a {@link \"@near-js/crypto\".key_pair.KeyPair | KeyPair}.\n */\nclass Account {\n    connection;\n    accountId;\n    constructor(connection, accountId) {\n        this.connection = connection;\n        this.accountId = accountId;\n    }\n    getConnection() {\n        return this.connection;\n    }\n    /**\n     * Returns basic NEAR account information via the `view_account` RPC query method\n     * @see [https://docs.near.org/api/rpc/contracts#view-account](https://docs.near.org/api/rpc/contracts#view-account)\n     */\n    async state() {\n        return this.connection.provider.query({\n            request_type: 'view_account',\n            account_id: this.accountId,\n            finality: 'optimistic'\n        });\n    }\n    /**\n     * Create a signed transaction which can be broadcast to the network\n     * @param receiverId NEAR account receiving the transaction\n     * @param actions list of actions to perform as part of the transaction\n     * @see {@link \"@near-js/providers\".json-rpc-provider.JsonRpcProvider.sendTransaction | JsonRpcProvider.sendTransaction}\n     */\n    async signTransaction(receiverId, actions) {\n        const accessKeyInfo = await this.findAccessKey(receiverId, actions);\n        if (!accessKeyInfo) {\n            throw new types_1.TypedError(`Can not sign transactions for account ${this.accountId} on network ${this.connection.networkId}, no matching key pair exists for this account`, 'KeyNotFound');\n        }\n        const { accessKey } = accessKeyInfo;\n        const block = await this.connection.provider.block({ finality: 'final' });\n        const blockHash = block.header.hash;\n        const nonce = accessKey.nonce + 1n;\n        return await (0, transactions_1.signTransaction)(receiverId, nonce, actions, (0, utils_1.baseDecode)(blockHash), this.connection.signer, this.accountId, this.connection.networkId);\n    }\n    /**\n     * Sign a transaction to perform a list of actions and broadcast it using the RPC API.\n     * @see {@link \"@near-js/providers\".json-rpc-provider.JsonRpcProvider | JsonRpcProvider }\n     *\n     * @param options The options for signing and sending the transaction.\n     * @param options.receiverId The NEAR account ID of the transaction receiver.\n     * @param options.actions The list of actions to be performed in the transaction.\n     * @param options.returnError Whether to return an error if the transaction fails.\n     * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the transaction.\n     */\n    async signAndSendTransaction({ receiverId, actions, returnError }) {\n        let txHash, signedTx;\n        // TODO: TX_NONCE (different constants for different uses of exponentialBackoff?)\n        const result = await (0, providers_1.exponentialBackoff)(TX_NONCE_RETRY_WAIT, TX_NONCE_RETRY_NUMBER, TX_NONCE_RETRY_WAIT_BACKOFF, async () => {\n            [txHash, signedTx] = await this.signTransaction(receiverId, actions);\n            const publicKey = signedTx.transaction.publicKey;\n            try {\n                return await this.connection.provider.sendTransaction(signedTx);\n            }\n            catch (error) {\n                if (error.type === 'InvalidNonce') {\n                    utils_1.Logger.warn(`Retrying transaction ${receiverId}:${(0, utils_1.baseEncode)(txHash)} with new nonce.`);\n                    delete this.accessKeyByPublicKeyCache[publicKey.toString()];\n                    return null;\n                }\n                if (error.type === 'Expired') {\n                    utils_1.Logger.warn(`Retrying transaction ${receiverId}:${(0, utils_1.baseEncode)(txHash)} due to expired block hash`);\n                    return null;\n                }\n                error.context = new types_1.ErrorContext((0, utils_1.baseEncode)(txHash));\n                throw error;\n            }\n        });\n        if (!result) {\n            // TODO: This should have different code actually, as means \"transaction not submitted for sure\"\n            throw new types_1.TypedError('nonce retries exceeded for transaction. This usually means there are too many parallel requests with the same access key.', 'RetriesExceeded');\n        }\n        (0, utils_1.printTxOutcomeLogsAndFailures)({ contractId: signedTx.transaction.receiverId, outcome: result });\n        // Should be falsy if result.status.Failure is null\n        if (!returnError && typeof result.status === 'object' && typeof result.status.Failure === 'object' && result.status.Failure !== null) {\n            // if error data has error_message and error_type properties, we consider that node returned an error in the old format\n            if (result.status.Failure.error_message && result.status.Failure.error_type) {\n                throw new types_1.TypedError(`Transaction ${result.transaction_outcome.id} failed. ${result.status.Failure.error_message}`, result.status.Failure.error_type);\n            }\n            else {\n                throw (0, utils_1.parseResultError)(result);\n            }\n        }\n        // TODO: if Tx is Unknown or Started.\n        return result;\n    }\n    /** @hidden */\n    accessKeyByPublicKeyCache = {};\n    /**\n     * Finds the {@link AccessKeyView} associated with the accounts {@link PublicKey} stored in the {@link \"@near-js/keystores\".keystore.KeyStore | Keystore}.\n     *\n     * @todo Find matching access key based on transaction (i.e. receiverId and actions)\n     *\n     * @param receiverId currently unused (see todo)\n     * @param actions currently unused (see todo)\n     * @returns `{ publicKey PublicKey; accessKey: AccessKeyView }`\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async findAccessKey(receiverId, actions) {\n        // TODO: Find matching access key based on transaction (i.e. receiverId and actions)\n        const publicKey = await this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);\n        if (!publicKey) {\n            throw new types_1.TypedError(`no matching key pair found in ${this.connection.signer}`, 'PublicKeyNotFound');\n        }\n        const cachedAccessKey = this.accessKeyByPublicKeyCache[publicKey.toString()];\n        if (cachedAccessKey !== undefined) {\n            return { publicKey, accessKey: cachedAccessKey };\n        }\n        try {\n            const rawAccessKey = await this.connection.provider.query({\n                request_type: 'view_access_key',\n                account_id: this.accountId,\n                public_key: publicKey.toString(),\n                finality: 'optimistic'\n            });\n            // store nonce as BigInt to preserve precision on big number\n            const accessKey = {\n                ...rawAccessKey,\n                nonce: BigInt(rawAccessKey.nonce || 0)\n            };\n            // this function can be called multiple times and retrieve the same access key\n            // this checks to see if the access key was already retrieved and cached while\n            // the above network call was in flight. To keep nonce values in line, we return\n            // the cached access key.\n            if (this.accessKeyByPublicKeyCache[publicKey.toString()]) {\n                return { publicKey, accessKey: this.accessKeyByPublicKeyCache[publicKey.toString()] };\n            }\n            this.accessKeyByPublicKeyCache[publicKey.toString()] = accessKey;\n            return { publicKey, accessKey };\n        }\n        catch (e) {\n            if (e.type == 'AccessKeyDoesNotExist') {\n                return null;\n            }\n            throw e;\n        }\n    }\n    /**\n     * Create a new account and deploy a contract to it\n     *\n     * @param contractId NEAR account where the contract is deployed\n     * @param publicKey The public key to add to the created contract account\n     * @param data The compiled contract code\n     * @param amount of NEAR to transfer to the created contract account. Transfer enough to pay for storage https://docs.near.org/docs/concepts/storage-staking\n     */\n    async createAndDeployContract(contractId, publicKey, data, amount) {\n        const accessKey = fullAccessKey();\n        await this.signAndSendTransaction({\n            receiverId: contractId,\n            actions: [createAccount(), transfer(amount), addKey(crypto_1.PublicKey.from(publicKey), accessKey), deployContract(data)]\n        });\n        const contractAccount = new Account(this.connection, contractId);\n        return contractAccount;\n    }\n    /**\n     * @param receiverId NEAR account receiving Ⓝ\n     * @param amount Amount to send in yoctoⓃ\n     */\n    async sendMoney(receiverId, amount) {\n        return this.signAndSendTransaction({\n            receiverId,\n            actions: [transfer(amount)]\n        });\n    }\n    /**\n     * @param newAccountId NEAR account name to be created\n     * @param publicKey A public key created from the masterAccount\n     */\n    async createAccount(newAccountId, publicKey, amount) {\n        const accessKey = fullAccessKey();\n        return this.signAndSendTransaction({\n            receiverId: newAccountId,\n            actions: [createAccount(), transfer(amount), addKey(crypto_1.PublicKey.from(publicKey), accessKey)]\n        });\n    }\n    /**\n     * @param beneficiaryId The NEAR account that will receive the remaining Ⓝ balance from the account being deleted\n     */\n    async deleteAccount(beneficiaryId) {\n        utils_1.Logger.log('Deleting an account does not automatically transfer NFTs and FTs to the beneficiary address. Ensure to transfer assets before deleting.');\n        return this.signAndSendTransaction({\n            receiverId: this.accountId,\n            actions: [deleteAccount(beneficiaryId)]\n        });\n    }\n    /**\n     * @param data The compiled contract code\n     */\n    async deployContract(data) {\n        return this.signAndSendTransaction({\n            receiverId: this.accountId,\n            actions: [deployContract(data)]\n        });\n    }\n    /** @hidden */\n    encodeJSContractArgs(contractId, method, args) {\n        return Buffer.concat([Buffer.from(contractId), Buffer.from([0]), Buffer.from(method), Buffer.from([0]), Buffer.from(args)]);\n    }\n    /**\n      * Execute a function call.\n      * @param options The options for the function call.\n      * @param options.contractId The NEAR account ID of the smart contract.\n      * @param options.methodName The name of the method to be called on the smart contract.\n      * @param options.args The arguments to be passed to the method.\n      * @param options.gas The maximum amount of gas to be used for the function call.\n      * @param options.attachedDeposit The amount of NEAR tokens to be attached to the function call.\n      * @param options.walletMeta Metadata for wallet integration.\n      * @param options.walletCallbackUrl The callback URL for wallet integration.\n      * @param options.stringify A function to convert input arguments into bytes array\n      * @param options.jsContract Whether the contract is from JS SDK, automatically encodes args from JS SDK to binary.\n      * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the function call.\n      */\n    async functionCall({ contractId, methodName, args = {}, gas = utils_1.DEFAULT_FUNCTION_CALL_GAS, attachedDeposit, walletMeta, walletCallbackUrl, stringify, jsContract }) {\n        this.validateArgs(args);\n        let functionCallArgs;\n        if (jsContract) {\n            const encodedArgs = this.encodeJSContractArgs(contractId, methodName, JSON.stringify(args));\n            functionCallArgs = ['call_js_contract', encodedArgs, gas, attachedDeposit, null, true];\n        }\n        else {\n            const stringifyArg = stringify === undefined ? transactions_1.stringifyJsonOrBytes : stringify;\n            functionCallArgs = [methodName, args, gas, attachedDeposit, stringifyArg, false];\n        }\n        return this.signAndSendTransaction({\n            receiverId: jsContract ? this.connection.jsvmAccountId : contractId,\n            // eslint-disable-next-line prefer-spread\n            actions: [functionCall.apply(void 0, functionCallArgs)],\n            walletMeta,\n            walletCallbackUrl\n        });\n    }\n    /**\n     * @see [https://docs.near.org/concepts/basics/accounts/access-keys](https://docs.near.org/concepts/basics/accounts/access-keys)\n     * @todo expand this API to support more options.\n     * @param publicKey A public key to be associated with the contract\n     * @param contractId NEAR account where the contract is deployed\n     * @param methodNames The method names on the contract that should be allowed to be called. Pass null for no method names and '' or [] for any method names.\n     * @param amount Payment in yoctoⓃ that is sent to the contract during this function call\n     */\n    async addKey(publicKey, contractId, methodNames, amount) {\n        if (!methodNames) {\n            methodNames = [];\n        }\n        if (!Array.isArray(methodNames)) {\n            methodNames = [methodNames];\n        }\n        let accessKey;\n        if (!contractId) {\n            accessKey = fullAccessKey();\n        }\n        else {\n            accessKey = functionCallAccessKey(contractId, methodNames, amount);\n        }\n        return this.signAndSendTransaction({\n            receiverId: this.accountId,\n            actions: [addKey(crypto_1.PublicKey.from(publicKey), accessKey)]\n        });\n    }\n    /**\n     * @param publicKey The public key to be deleted\n     * @returns {Promise<FinalExecutionOutcome>}\n     */\n    async deleteKey(publicKey) {\n        return this.signAndSendTransaction({\n            receiverId: this.accountId,\n            actions: [deleteKey(crypto_1.PublicKey.from(publicKey))]\n        });\n    }\n    /**\n     * @see [https://near-nodes.io/validator/staking-and-delegation](https://near-nodes.io/validator/staking-and-delegation)\n     *\n     * @param publicKey The public key for the account that's staking\n     * @param amount The account to stake in yoctoⓃ\n     */\n    async stake(publicKey, amount) {\n        return this.signAndSendTransaction({\n            receiverId: this.accountId,\n            actions: [stake(amount, crypto_1.PublicKey.from(publicKey))]\n        });\n    }\n    /**\n     * Compose and sign a SignedDelegate action to be executed in a transaction on behalf of this Account instance\n     *\n     * @param options Options for the transaction.\n     * @param options.actions Actions to be included in the meta transaction\n     * @param options.blockHeightTtl Number of blocks past the current block height for which the SignedDelegate action may be included in a meta transaction\n     * @param options.receiverId Receiver account of the meta transaction\n     */\n    async signedDelegate({ actions, blockHeightTtl, receiverId, }) {\n        const { provider, signer } = this.connection;\n        const { header } = await provider.block({ finality: 'final' });\n        const { accessKey, publicKey } = await this.findAccessKey(null, null);\n        const delegateAction = (0, transactions_1.buildDelegateAction)({\n            actions,\n            maxBlockHeight: BigInt(header.height) + BigInt(blockHeightTtl),\n            nonce: BigInt(accessKey.nonce) + 1n,\n            publicKey,\n            receiverId,\n            senderId: this.accountId,\n        });\n        const { signedDelegateAction } = await (0, transactions_1.signDelegateAction)({\n            delegateAction,\n            signer: {\n                sign: async (message) => {\n                    const { signature } = await signer.signMessage(message, delegateAction.senderId, this.connection.networkId);\n                    return signature;\n                },\n            }\n        });\n        return signedDelegateAction;\n    }\n    /** @hidden */\n    validateArgs(args) {\n        const isUint8Array = args.byteLength !== undefined && args.byteLength === args.length;\n        if (isUint8Array) {\n            return;\n        }\n        if (Array.isArray(args) || typeof args !== 'object') {\n            throw new types_1.PositionalArgsError();\n        }\n    }\n    /**\n     * Invoke a contract view function using the RPC API.\n     * @see [https://docs.near.org/api/rpc/contracts#call-a-contract-function](https://docs.near.org/api/rpc/contracts#call-a-contract-function)\n     *\n     * @param options Function call options.\n     * @param options.contractId NEAR account where the contract is deployed\n     * @param options.methodName The view-only method (no state mutations) name on the contract as it is written in the contract code\n     * @param options.args Any arguments to the view contract method, wrapped in JSON\n     * @param options.parse Parse the result of the call. Receives a Buffer (bytes array) and converts it to any object. By default result will be treated as json.\n     * @param options.stringify Convert input arguments into a bytes array. By default the input is treated as a JSON.\n     * @param options.jsContract Is contract from JS SDK, automatically encodes args from JS SDK to binary.\n     * @param options.blockQuery specifies which block to query state at. By default returns last \"optimistic\" block (i.e. not necessarily finalized).\n     * @returns {Promise<any>}\n     */\n    async viewFunction(options) {\n        return await (0, utils_2.viewFunction)(this.connection, options);\n    }\n    /**\n     * Returns the state (key value pairs) of this account's contract based on the key prefix.\n     * Pass an empty string for prefix if you would like to return the entire state.\n     * @see [https://docs.near.org/api/rpc/contracts#view-contract-state](https://docs.near.org/api/rpc/contracts#view-contract-state)\n     *\n     * @param prefix allows to filter which keys should be returned. Empty prefix means all keys. String prefix is utf-8 encoded.\n     * @param blockQuery specifies which block to query state at. By default returns last \"optimistic\" block (i.e. not necessarily finalized).\n     */\n    async viewState(prefix, blockQuery = { finality: 'optimistic' }) {\n        return await (0, utils_2.viewState)(this.connection, this.accountId, prefix, blockQuery);\n    }\n    /**\n     * Get all access keys for the account\n     * @see [https://docs.near.org/api/rpc/access-keys#view-access-key-list](https://docs.near.org/api/rpc/access-keys#view-access-key-list)\n     */\n    async getAccessKeys() {\n        const response = await this.connection.provider.query({\n            request_type: 'view_access_key_list',\n            account_id: this.accountId,\n            finality: 'optimistic'\n        });\n        // Replace raw nonce into a new BigInt\n        return response?.keys?.map((key) => ({ ...key, access_key: { ...key.access_key, nonce: BigInt(key.access_key.nonce) } }));\n    }\n    /**\n     * Returns a list of authorized apps\n     * @todo update the response value to return all the different keys, not just app keys.\n     */\n    async getAccountDetails() {\n        // TODO: update the response value to return all the different keys, not just app keys.\n        // Also if we need this function, or getAccessKeys is good enough.\n        const accessKeys = await this.getAccessKeys();\n        const authorizedApps = accessKeys\n            .filter(item => item.access_key.permission !== 'FullAccess')\n            .map(item => {\n            const perm = item.access_key.permission;\n            return {\n                contractId: perm.FunctionCall.receiver_id,\n                amount: perm.FunctionCall.allowance,\n                publicKey: item.public_key,\n            };\n        });\n        return { authorizedApps };\n    }\n    /**\n     * Returns calculated account balance\n     */\n    async getAccountBalance() {\n        const protocolConfig = await this.connection.provider.experimental_protocolConfig({ finality: 'final' });\n        const state = await this.state();\n        const costPerByte = BigInt(protocolConfig.runtime_config.storage_amount_per_byte);\n        const stateStaked = BigInt(state.storage_usage) * costPerByte;\n        const staked = BigInt(state.locked);\n        const totalBalance = BigInt(state.amount) + staked;\n        const availableBalance = totalBalance - (staked > stateStaked ? staked : stateStaked);\n        return {\n            total: totalBalance.toString(),\n            stateStaked: stateStaked.toString(),\n            staked: staked.toString(),\n            available: availableBalance.toString()\n        };\n    }\n    /**\n     * Returns the NEAR tokens balance and validators of a given account that is delegated to the staking pools that are part of the validators set in the current epoch.\n     *\n     * NOTE: If the tokens are delegated to a staking pool that is currently on pause or does not have enough tokens to participate in validation, they won't be accounted for.\n     * @returns {Promise<ActiveDelegatedStakeBalance>}\n     */\n    async getActiveDelegatedStakeBalance() {\n        const block = await this.connection.provider.block({ finality: 'final' });\n        const blockHash = block.header.hash;\n        const epochId = block.header.epoch_id;\n        const { current_validators, next_validators, current_proposals } = await this.connection.provider.validators(epochId);\n        const pools = new Set();\n        [...current_validators, ...next_validators, ...current_proposals]\n            .forEach((validator) => pools.add(validator.account_id));\n        const uniquePools = [...pools];\n        const promises = uniquePools\n            .map((validator) => (this.viewFunction({\n            contractId: validator,\n            methodName: 'get_account_total_balance',\n            args: { account_id: this.accountId },\n            blockQuery: { blockId: blockHash }\n        })));\n        const results = await Promise.allSettled(promises);\n        const hasTimeoutError = results.some((result) => {\n            if (result.status === 'rejected' && result.reason.type === 'TimeoutError') {\n                return true;\n            }\n            return false;\n        });\n        // When RPC is down and return timeout error, throw error\n        if (hasTimeoutError) {\n            throw new Error('Failed to get delegated stake balance');\n        }\n        const summary = results.reduce((result, state, index) => {\n            const validatorId = uniquePools[index];\n            if (state.status === 'fulfilled') {\n                const currentBN = BigInt(state.value);\n                if (currentBN !== 0n) {\n                    return {\n                        ...result,\n                        stakedValidators: [...result.stakedValidators, { validatorId, amount: currentBN.toString() }],\n                        total: result.total + currentBN,\n                    };\n                }\n            }\n            if (state.status === 'rejected') {\n                return {\n                    ...result,\n                    failedValidators: [...result.failedValidators, { validatorId, error: state.reason }],\n                };\n            }\n            return result;\n        }, { stakedValidators: [], failedValidators: [], total: 0n });\n        return {\n            ...summary,\n            total: summary.total.toString(),\n        };\n    }\n}\nexports.Account = Account;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMS4zLjEvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9jb21tb25qcy9hY2NvdW50LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlO0FBQ2YsaUJBQWlCLG1CQUFPLENBQUMsNkhBQWlCO0FBQzFDLG9CQUFvQixtQkFBTyxDQUFDLHNJQUFvQjtBQUNoRCx1QkFBdUIsbUJBQU8sQ0FBQywrSUFBdUI7QUFDdEQsZ0JBQWdCLG1CQUFPLENBQUMsMEhBQWdCO0FBQ3hDLGdCQUFnQixtQkFBTyxDQUFDLDBIQUFnQjtBQUN4QyxnQkFBZ0IsbUJBQU8sQ0FBQyw2SEFBYTtBQUNyQyxRQUFRLHdJQUF3STtBQUNoSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRixtREFBbUQ7QUFDbEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLGdCQUFnQixhQUFhLDBCQUEwQjtBQUN6STtBQUNBLGdCQUFnQixZQUFZO0FBQzVCLDZEQUE2RCxtQkFBbUI7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0NBQWdDO0FBQ2pEO0FBQ0EsbUNBQW1DLGtDQUFrQztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxXQUFXLEdBQUcsaUNBQWlDO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLFdBQVcsR0FBRyxpQ0FBaUM7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCw4REFBOEQ7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsK0JBQStCLFVBQVUsb0NBQW9DO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCLDhCQUE4QixpQkFBaUIsZUFBZSx3REFBd0Q7QUFDN0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUIsMEJBQTBCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSx1QkFBdUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQ0FBZ0M7QUFDbEQ7QUFDQSx5QkFBeUIsaUNBQWlDLGtIQUFrSDtBQUM1SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNDQUFzQztBQUNqRSxnQkFBZ0IsbUJBQW1CO0FBQ25DLGdCQUFnQixTQUFTLHlCQUF5QixtQkFBbUI7QUFDckUsZ0JBQWdCLHVCQUF1QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsd0JBQXdCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwrQ0FBK0Msc0JBQXNCLDBEQUEwRDtBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsbUJBQW1CO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDZEQUE2RCxtQkFBbUI7QUFDaEY7QUFDQTtBQUNBLGdCQUFnQix5REFBeUQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQsMEJBQTBCO0FBQzFCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSwyQ0FBMkM7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsa0NBQWtDO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSSx1REFBdUQ7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL2hhY2thdGhvbi1uZWFyLXJlZGFjdGVkLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BuZWFyLWpzK2FjY291bnRzQDEuMy4xL25vZGVfbW9kdWxlcy9AbmVhci1qcy9hY2NvdW50cy9saWIvY29tbW9uanMvYWNjb3VudC5janM/N2IyMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWNjb3VudCA9IHZvaWQgMDtcbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcIkBuZWFyLWpzL2NyeXB0b1wiKTtcbmNvbnN0IHByb3ZpZGVyc18xID0gcmVxdWlyZShcIkBuZWFyLWpzL3Byb3ZpZGVyc1wiKTtcbmNvbnN0IHRyYW5zYWN0aW9uc18xID0gcmVxdWlyZShcIkBuZWFyLWpzL3RyYW5zYWN0aW9uc1wiKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiQG5lYXItanMvdHlwZXNcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBuZWFyLWpzL3V0aWxzXCIpO1xuY29uc3QgdXRpbHNfMiA9IHJlcXVpcmUoXCIuL3V0aWxzLmNqc1wiKTtcbmNvbnN0IHsgYWRkS2V5LCBjcmVhdGVBY2NvdW50LCBkZWxldGVBY2NvdW50LCBkZWxldGVLZXksIGRlcGxveUNvbnRyYWN0LCBmdWxsQWNjZXNzS2V5LCBmdW5jdGlvbkNhbGwsIGZ1bmN0aW9uQ2FsbEFjY2Vzc0tleSwgc3Rha2UsIHRyYW5zZmVyLCB9ID0gdHJhbnNhY3Rpb25zXzEuYWN0aW9uQ3JlYXRvcnM7XG4vLyBEZWZhdWx0IG51bWJlciBvZiByZXRyaWVzIHdpdGggZGlmZmVyZW50IG5vbmNlIGJlZm9yZSBnaXZpbmcgdXAgb24gYSB0cmFuc2FjdGlvbi5cbmNvbnN0IFRYX05PTkNFX1JFVFJZX05VTUJFUiA9IDEyO1xuLy8gRGVmYXVsdCB3YWl0IHVudGlsIG5leHQgcmV0cnkgaW4gbWlsbGlzLlxuY29uc3QgVFhfTk9OQ0VfUkVUUllfV0FJVCA9IDUwMDtcbi8vIEV4cG9uZW50aWFsIGJhY2sgb2ZmIGZvciB3YWl0aW5nIHRvIHJldHJ5LlxuY29uc3QgVFhfTk9OQ0VfUkVUUllfV0FJVF9CQUNLT0ZGID0gMS41O1xuLyoqXG4gKiBUaGlzIGNsYXNzIHByb3ZpZGVzIGNvbW1vbiBhY2NvdW50IHJlbGF0ZWQgUlBDIGNhbGxzIGluY2x1ZGluZyBzaWduaW5nIHRyYW5zYWN0aW9ucyB3aXRoIGEge0BsaW5rIFwiQG5lYXItanMvY3J5cHRvXCIua2V5X3BhaXIuS2V5UGFpciB8IEtleVBhaXJ9LlxuICovXG5jbGFzcyBBY2NvdW50IHtcbiAgICBjb25uZWN0aW9uO1xuICAgIGFjY291bnRJZDtcbiAgICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uLCBhY2NvdW50SWQpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICAgICAgdGhpcy5hY2NvdW50SWQgPSBhY2NvdW50SWQ7XG4gICAgfVxuICAgIGdldENvbm5lY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYmFzaWMgTkVBUiBhY2NvdW50IGluZm9ybWF0aW9uIHZpYSB0aGUgYHZpZXdfYWNjb3VudGAgUlBDIHF1ZXJ5IG1ldGhvZFxuICAgICAqIEBzZWUgW2h0dHBzOi8vZG9jcy5uZWFyLm9yZy9hcGkvcnBjL2NvbnRyYWN0cyN2aWV3LWFjY291bnRdKGh0dHBzOi8vZG9jcy5uZWFyLm9yZy9hcGkvcnBjL2NvbnRyYWN0cyN2aWV3LWFjY291bnQpXG4gICAgICovXG4gICAgYXN5bmMgc3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24ucHJvdmlkZXIucXVlcnkoe1xuICAgICAgICAgICAgcmVxdWVzdF90eXBlOiAndmlld19hY2NvdW50JyxcbiAgICAgICAgICAgIGFjY291bnRfaWQ6IHRoaXMuYWNjb3VudElkLFxuICAgICAgICAgICAgZmluYWxpdHk6ICdvcHRpbWlzdGljJ1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgc2lnbmVkIHRyYW5zYWN0aW9uIHdoaWNoIGNhbiBiZSBicm9hZGNhc3QgdG8gdGhlIG5ldHdvcmtcbiAgICAgKiBAcGFyYW0gcmVjZWl2ZXJJZCBORUFSIGFjY291bnQgcmVjZWl2aW5nIHRoZSB0cmFuc2FjdGlvblxuICAgICAqIEBwYXJhbSBhY3Rpb25zIGxpc3Qgb2YgYWN0aW9ucyB0byBwZXJmb3JtIGFzIHBhcnQgb2YgdGhlIHRyYW5zYWN0aW9uXG4gICAgICogQHNlZSB7QGxpbmsgXCJAbmVhci1qcy9wcm92aWRlcnNcIi5qc29uLXJwYy1wcm92aWRlci5Kc29uUnBjUHJvdmlkZXIuc2VuZFRyYW5zYWN0aW9uIHwgSnNvblJwY1Byb3ZpZGVyLnNlbmRUcmFuc2FjdGlvbn1cbiAgICAgKi9cbiAgICBhc3luYyBzaWduVHJhbnNhY3Rpb24ocmVjZWl2ZXJJZCwgYWN0aW9ucykge1xuICAgICAgICBjb25zdCBhY2Nlc3NLZXlJbmZvID0gYXdhaXQgdGhpcy5maW5kQWNjZXNzS2V5KHJlY2VpdmVySWQsIGFjdGlvbnMpO1xuICAgICAgICBpZiAoIWFjY2Vzc0tleUluZm8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyB0eXBlc18xLlR5cGVkRXJyb3IoYENhbiBub3Qgc2lnbiB0cmFuc2FjdGlvbnMgZm9yIGFjY291bnQgJHt0aGlzLmFjY291bnRJZH0gb24gbmV0d29yayAke3RoaXMuY29ubmVjdGlvbi5uZXR3b3JrSWR9LCBubyBtYXRjaGluZyBrZXkgcGFpciBleGlzdHMgZm9yIHRoaXMgYWNjb3VudGAsICdLZXlOb3RGb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgYWNjZXNzS2V5IH0gPSBhY2Nlc3NLZXlJbmZvO1xuICAgICAgICBjb25zdCBibG9jayA9IGF3YWl0IHRoaXMuY29ubmVjdGlvbi5wcm92aWRlci5ibG9jayh7IGZpbmFsaXR5OiAnZmluYWwnIH0pO1xuICAgICAgICBjb25zdCBibG9ja0hhc2ggPSBibG9jay5oZWFkZXIuaGFzaDtcbiAgICAgICAgY29uc3Qgbm9uY2UgPSBhY2Nlc3NLZXkubm9uY2UgKyAxbjtcbiAgICAgICAgcmV0dXJuIGF3YWl0ICgwLCB0cmFuc2FjdGlvbnNfMS5zaWduVHJhbnNhY3Rpb24pKHJlY2VpdmVySWQsIG5vbmNlLCBhY3Rpb25zLCAoMCwgdXRpbHNfMS5iYXNlRGVjb2RlKShibG9ja0hhc2gpLCB0aGlzLmNvbm5lY3Rpb24uc2lnbmVyLCB0aGlzLmFjY291bnRJZCwgdGhpcy5jb25uZWN0aW9uLm5ldHdvcmtJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ24gYSB0cmFuc2FjdGlvbiB0byBwZXJmb3JtIGEgbGlzdCBvZiBhY3Rpb25zIGFuZCBicm9hZGNhc3QgaXQgdXNpbmcgdGhlIFJQQyBBUEkuXG4gICAgICogQHNlZSB7QGxpbmsgXCJAbmVhci1qcy9wcm92aWRlcnNcIi5qc29uLXJwYy1wcm92aWRlci5Kc29uUnBjUHJvdmlkZXIgfCBKc29uUnBjUHJvdmlkZXIgfVxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIHNpZ25pbmcgYW5kIHNlbmRpbmcgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnJlY2VpdmVySWQgVGhlIE5FQVIgYWNjb3VudCBJRCBvZiB0aGUgdHJhbnNhY3Rpb24gcmVjZWl2ZXIuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYWN0aW9ucyBUaGUgbGlzdCBvZiBhY3Rpb25zIHRvIGJlIHBlcmZvcm1lZCBpbiB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICogQHBhcmFtIG9wdGlvbnMucmV0dXJuRXJyb3IgV2hldGhlciB0byByZXR1cm4gYW4gZXJyb3IgaWYgdGhlIHRyYW5zYWN0aW9uIGZhaWxzLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZpbmFsRXhlY3V0aW9uT3V0Y29tZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBmaW5hbCBleGVjdXRpb24gb3V0Y29tZSBvZiB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgYXN5bmMgc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih7IHJlY2VpdmVySWQsIGFjdGlvbnMsIHJldHVybkVycm9yIH0pIHtcbiAgICAgICAgbGV0IHR4SGFzaCwgc2lnbmVkVHg7XG4gICAgICAgIC8vIFRPRE86IFRYX05PTkNFIChkaWZmZXJlbnQgY29uc3RhbnRzIGZvciBkaWZmZXJlbnQgdXNlcyBvZiBleHBvbmVudGlhbEJhY2tvZmY/KVxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCAoMCwgcHJvdmlkZXJzXzEuZXhwb25lbnRpYWxCYWNrb2ZmKShUWF9OT05DRV9SRVRSWV9XQUlULCBUWF9OT05DRV9SRVRSWV9OVU1CRVIsIFRYX05PTkNFX1JFVFJZX1dBSVRfQkFDS09GRiwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgW3R4SGFzaCwgc2lnbmVkVHhdID0gYXdhaXQgdGhpcy5zaWduVHJhbnNhY3Rpb24ocmVjZWl2ZXJJZCwgYWN0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSBzaWduZWRUeC50cmFuc2FjdGlvbi5wdWJsaWNLZXk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbm5lY3Rpb24ucHJvdmlkZXIuc2VuZFRyYW5zYWN0aW9uKHNpZ25lZFR4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci50eXBlID09PSAnSW52YWxpZE5vbmNlJykge1xuICAgICAgICAgICAgICAgICAgICB1dGlsc18xLkxvZ2dlci53YXJuKGBSZXRyeWluZyB0cmFuc2FjdGlvbiAke3JlY2VpdmVySWR9OiR7KDAsIHV0aWxzXzEuYmFzZUVuY29kZSkodHhIYXNoKX0gd2l0aCBuZXcgbm9uY2UuYCk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmFjY2Vzc0tleUJ5UHVibGljS2V5Q2FjaGVbcHVibGljS2V5LnRvU3RyaW5nKCldO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLnR5cGUgPT09ICdFeHBpcmVkJykge1xuICAgICAgICAgICAgICAgICAgICB1dGlsc18xLkxvZ2dlci53YXJuKGBSZXRyeWluZyB0cmFuc2FjdGlvbiAke3JlY2VpdmVySWR9OiR7KDAsIHV0aWxzXzEuYmFzZUVuY29kZSkodHhIYXNoKX0gZHVlIHRvIGV4cGlyZWQgYmxvY2sgaGFzaGApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXJyb3IuY29udGV4dCA9IG5ldyB0eXBlc18xLkVycm9yQ29udGV4dCgoMCwgdXRpbHNfMS5iYXNlRW5jb2RlKSh0eEhhc2gpKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCBoYXZlIGRpZmZlcmVudCBjb2RlIGFjdHVhbGx5LCBhcyBtZWFucyBcInRyYW5zYWN0aW9uIG5vdCBzdWJtaXR0ZWQgZm9yIHN1cmVcIlxuICAgICAgICAgICAgdGhyb3cgbmV3IHR5cGVzXzEuVHlwZWRFcnJvcignbm9uY2UgcmV0cmllcyBleGNlZWRlZCBmb3IgdHJhbnNhY3Rpb24uIFRoaXMgdXN1YWxseSBtZWFucyB0aGVyZSBhcmUgdG9vIG1hbnkgcGFyYWxsZWwgcmVxdWVzdHMgd2l0aCB0aGUgc2FtZSBhY2Nlc3Mga2V5LicsICdSZXRyaWVzRXhjZWVkZWQnKTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgdXRpbHNfMS5wcmludFR4T3V0Y29tZUxvZ3NBbmRGYWlsdXJlcykoeyBjb250cmFjdElkOiBzaWduZWRUeC50cmFuc2FjdGlvbi5yZWNlaXZlcklkLCBvdXRjb21lOiByZXN1bHQgfSk7XG4gICAgICAgIC8vIFNob3VsZCBiZSBmYWxzeSBpZiByZXN1bHQuc3RhdHVzLkZhaWx1cmUgaXMgbnVsbFxuICAgICAgICBpZiAoIXJldHVybkVycm9yICYmIHR5cGVvZiByZXN1bHQuc3RhdHVzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcmVzdWx0LnN0YXR1cy5GYWlsdXJlID09PSAnb2JqZWN0JyAmJiByZXN1bHQuc3RhdHVzLkZhaWx1cmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGlmIGVycm9yIGRhdGEgaGFzIGVycm9yX21lc3NhZ2UgYW5kIGVycm9yX3R5cGUgcHJvcGVydGllcywgd2UgY29uc2lkZXIgdGhhdCBub2RlIHJldHVybmVkIGFuIGVycm9yIGluIHRoZSBvbGQgZm9ybWF0XG4gICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cy5GYWlsdXJlLmVycm9yX21lc3NhZ2UgJiYgcmVzdWx0LnN0YXR1cy5GYWlsdXJlLmVycm9yX3R5cGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgdHlwZXNfMS5UeXBlZEVycm9yKGBUcmFuc2FjdGlvbiAke3Jlc3VsdC50cmFuc2FjdGlvbl9vdXRjb21lLmlkfSBmYWlsZWQuICR7cmVzdWx0LnN0YXR1cy5GYWlsdXJlLmVycm9yX21lc3NhZ2V9YCwgcmVzdWx0LnN0YXR1cy5GYWlsdXJlLmVycm9yX3R5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgKDAsIHV0aWxzXzEucGFyc2VSZXN1bHRFcnJvcikocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBpZiBUeCBpcyBVbmtub3duIG9yIFN0YXJ0ZWQuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgYWNjZXNzS2V5QnlQdWJsaWNLZXlDYWNoZSA9IHt9O1xuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSB7QGxpbmsgQWNjZXNzS2V5Vmlld30gYXNzb2NpYXRlZCB3aXRoIHRoZSBhY2NvdW50cyB7QGxpbmsgUHVibGljS2V5fSBzdG9yZWQgaW4gdGhlIHtAbGluayBcIkBuZWFyLWpzL2tleXN0b3Jlc1wiLmtleXN0b3JlLktleVN0b3JlIHwgS2V5c3RvcmV9LlxuICAgICAqXG4gICAgICogQHRvZG8gRmluZCBtYXRjaGluZyBhY2Nlc3Mga2V5IGJhc2VkIG9uIHRyYW5zYWN0aW9uIChpLmUuIHJlY2VpdmVySWQgYW5kIGFjdGlvbnMpXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVjZWl2ZXJJZCBjdXJyZW50bHkgdW51c2VkIChzZWUgdG9kbylcbiAgICAgKiBAcGFyYW0gYWN0aW9ucyBjdXJyZW50bHkgdW51c2VkIChzZWUgdG9kbylcbiAgICAgKiBAcmV0dXJucyBgeyBwdWJsaWNLZXkgUHVibGljS2V5OyBhY2Nlc3NLZXk6IEFjY2Vzc0tleVZpZXcgfWBcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgYXN5bmMgZmluZEFjY2Vzc0tleShyZWNlaXZlcklkLCBhY3Rpb25zKSB7XG4gICAgICAgIC8vIFRPRE86IEZpbmQgbWF0Y2hpbmcgYWNjZXNzIGtleSBiYXNlZCBvbiB0cmFuc2FjdGlvbiAoaS5lLiByZWNlaXZlcklkIGFuZCBhY3Rpb25zKVxuICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uc2lnbmVyLmdldFB1YmxpY0tleSh0aGlzLmFjY291bnRJZCwgdGhpcy5jb25uZWN0aW9uLm5ldHdvcmtJZCk7XG4gICAgICAgIGlmICghcHVibGljS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgdHlwZXNfMS5UeXBlZEVycm9yKGBubyBtYXRjaGluZyBrZXkgcGFpciBmb3VuZCBpbiAke3RoaXMuY29ubmVjdGlvbi5zaWduZXJ9YCwgJ1B1YmxpY0tleU5vdEZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FjaGVkQWNjZXNzS2V5ID0gdGhpcy5hY2Nlc3NLZXlCeVB1YmxpY0tleUNhY2hlW3B1YmxpY0tleS50b1N0cmluZygpXTtcbiAgICAgICAgaWYgKGNhY2hlZEFjY2Vzc0tleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4geyBwdWJsaWNLZXksIGFjY2Vzc0tleTogY2FjaGVkQWNjZXNzS2V5IH07XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJhd0FjY2Vzc0tleSA9IGF3YWl0IHRoaXMuY29ubmVjdGlvbi5wcm92aWRlci5xdWVyeSh7XG4gICAgICAgICAgICAgICAgcmVxdWVzdF90eXBlOiAndmlld19hY2Nlc3Nfa2V5JyxcbiAgICAgICAgICAgICAgICBhY2NvdW50X2lkOiB0aGlzLmFjY291bnRJZCxcbiAgICAgICAgICAgICAgICBwdWJsaWNfa2V5OiBwdWJsaWNLZXkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBmaW5hbGl0eTogJ29wdGltaXN0aWMnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHN0b3JlIG5vbmNlIGFzIEJpZ0ludCB0byBwcmVzZXJ2ZSBwcmVjaXNpb24gb24gYmlnIG51bWJlclxuICAgICAgICAgICAgY29uc3QgYWNjZXNzS2V5ID0ge1xuICAgICAgICAgICAgICAgIC4uLnJhd0FjY2Vzc0tleSxcbiAgICAgICAgICAgICAgICBub25jZTogQmlnSW50KHJhd0FjY2Vzc0tleS5ub25jZSB8fCAwKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIHRoaXMgZnVuY3Rpb24gY2FuIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBhbmQgcmV0cmlldmUgdGhlIHNhbWUgYWNjZXNzIGtleVxuICAgICAgICAgICAgLy8gdGhpcyBjaGVja3MgdG8gc2VlIGlmIHRoZSBhY2Nlc3Mga2V5IHdhcyBhbHJlYWR5IHJldHJpZXZlZCBhbmQgY2FjaGVkIHdoaWxlXG4gICAgICAgICAgICAvLyB0aGUgYWJvdmUgbmV0d29yayBjYWxsIHdhcyBpbiBmbGlnaHQuIFRvIGtlZXAgbm9uY2UgdmFsdWVzIGluIGxpbmUsIHdlIHJldHVyblxuICAgICAgICAgICAgLy8gdGhlIGNhY2hlZCBhY2Nlc3Mga2V5LlxuICAgICAgICAgICAgaWYgKHRoaXMuYWNjZXNzS2V5QnlQdWJsaWNLZXlDYWNoZVtwdWJsaWNLZXkudG9TdHJpbmcoKV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBwdWJsaWNLZXksIGFjY2Vzc0tleTogdGhpcy5hY2Nlc3NLZXlCeVB1YmxpY0tleUNhY2hlW3B1YmxpY0tleS50b1N0cmluZygpXSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hY2Nlc3NLZXlCeVB1YmxpY0tleUNhY2hlW3B1YmxpY0tleS50b1N0cmluZygpXSA9IGFjY2Vzc0tleTtcbiAgICAgICAgICAgIHJldHVybiB7IHB1YmxpY0tleSwgYWNjZXNzS2V5IH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlLnR5cGUgPT0gJ0FjY2Vzc0tleURvZXNOb3RFeGlzdCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGFjY291bnQgYW5kIGRlcGxveSBhIGNvbnRyYWN0IHRvIGl0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29udHJhY3RJZCBORUFSIGFjY291bnQgd2hlcmUgdGhlIGNvbnRyYWN0IGlzIGRlcGxveWVkXG4gICAgICogQHBhcmFtIHB1YmxpY0tleSBUaGUgcHVibGljIGtleSB0byBhZGQgdG8gdGhlIGNyZWF0ZWQgY29udHJhY3QgYWNjb3VudFxuICAgICAqIEBwYXJhbSBkYXRhIFRoZSBjb21waWxlZCBjb250cmFjdCBjb2RlXG4gICAgICogQHBhcmFtIGFtb3VudCBvZiBORUFSIHRvIHRyYW5zZmVyIHRvIHRoZSBjcmVhdGVkIGNvbnRyYWN0IGFjY291bnQuIFRyYW5zZmVyIGVub3VnaCB0byBwYXkgZm9yIHN0b3JhZ2UgaHR0cHM6Ly9kb2NzLm5lYXIub3JnL2RvY3MvY29uY2VwdHMvc3RvcmFnZS1zdGFraW5nXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlQW5kRGVwbG95Q29udHJhY3QoY29udHJhY3RJZCwgcHVibGljS2V5LCBkYXRhLCBhbW91bnQpIHtcbiAgICAgICAgY29uc3QgYWNjZXNzS2V5ID0gZnVsbEFjY2Vzc0tleSgpO1xuICAgICAgICBhd2FpdCB0aGlzLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgcmVjZWl2ZXJJZDogY29udHJhY3RJZCxcbiAgICAgICAgICAgIGFjdGlvbnM6IFtjcmVhdGVBY2NvdW50KCksIHRyYW5zZmVyKGFtb3VudCksIGFkZEtleShjcnlwdG9fMS5QdWJsaWNLZXkuZnJvbShwdWJsaWNLZXkpLCBhY2Nlc3NLZXkpLCBkZXBsb3lDb250cmFjdChkYXRhKV1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNvbnRyYWN0QWNjb3VudCA9IG5ldyBBY2NvdW50KHRoaXMuY29ubmVjdGlvbiwgY29udHJhY3RJZCk7XG4gICAgICAgIHJldHVybiBjb250cmFjdEFjY291bnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSByZWNlaXZlcklkIE5FQVIgYWNjb3VudCByZWNlaXZpbmcg4pODXG4gICAgICogQHBhcmFtIGFtb3VudCBBbW91bnQgdG8gc2VuZCBpbiB5b2N0b+KTg1xuICAgICAqL1xuICAgIGFzeW5jIHNlbmRNb25leShyZWNlaXZlcklkLCBhbW91bnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICByZWNlaXZlcklkLFxuICAgICAgICAgICAgYWN0aW9uczogW3RyYW5zZmVyKGFtb3VudCldXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbmV3QWNjb3VudElkIE5FQVIgYWNjb3VudCBuYW1lIHRvIGJlIGNyZWF0ZWRcbiAgICAgKiBAcGFyYW0gcHVibGljS2V5IEEgcHVibGljIGtleSBjcmVhdGVkIGZyb20gdGhlIG1hc3RlckFjY291bnRcbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVBY2NvdW50KG5ld0FjY291bnRJZCwgcHVibGljS2V5LCBhbW91bnQpIHtcbiAgICAgICAgY29uc3QgYWNjZXNzS2V5ID0gZnVsbEFjY2Vzc0tleSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5zaWduQW5kU2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgIHJlY2VpdmVySWQ6IG5ld0FjY291bnRJZCxcbiAgICAgICAgICAgIGFjdGlvbnM6IFtjcmVhdGVBY2NvdW50KCksIHRyYW5zZmVyKGFtb3VudCksIGFkZEtleShjcnlwdG9fMS5QdWJsaWNLZXkuZnJvbShwdWJsaWNLZXkpLCBhY2Nlc3NLZXkpXVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGJlbmVmaWNpYXJ5SWQgVGhlIE5FQVIgYWNjb3VudCB0aGF0IHdpbGwgcmVjZWl2ZSB0aGUgcmVtYWluaW5nIOKTgyBiYWxhbmNlIGZyb20gdGhlIGFjY291bnQgYmVpbmcgZGVsZXRlZFxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZUFjY291bnQoYmVuZWZpY2lhcnlJZCkge1xuICAgICAgICB1dGlsc18xLkxvZ2dlci5sb2coJ0RlbGV0aW5nIGFuIGFjY291bnQgZG9lcyBub3QgYXV0b21hdGljYWxseSB0cmFuc2ZlciBORlRzIGFuZCBGVHMgdG8gdGhlIGJlbmVmaWNpYXJ5IGFkZHJlc3MuIEVuc3VyZSB0byB0cmFuc2ZlciBhc3NldHMgYmVmb3JlIGRlbGV0aW5nLicpO1xuICAgICAgICByZXR1cm4gdGhpcy5zaWduQW5kU2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgIHJlY2VpdmVySWQ6IHRoaXMuYWNjb3VudElkLFxuICAgICAgICAgICAgYWN0aW9uczogW2RlbGV0ZUFjY291bnQoYmVuZWZpY2lhcnlJZCldXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZGF0YSBUaGUgY29tcGlsZWQgY29udHJhY3QgY29kZVxuICAgICAqL1xuICAgIGFzeW5jIGRlcGxveUNvbnRyYWN0KGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICByZWNlaXZlcklkOiB0aGlzLmFjY291bnRJZCxcbiAgICAgICAgICAgIGFjdGlvbnM6IFtkZXBsb3lDb250cmFjdChkYXRhKV1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgZW5jb2RlSlNDb250cmFjdEFyZ3MoY29udHJhY3RJZCwgbWV0aG9kLCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbShjb250cmFjdElkKSwgQnVmZmVyLmZyb20oWzBdKSwgQnVmZmVyLmZyb20obWV0aG9kKSwgQnVmZmVyLmZyb20oWzBdKSwgQnVmZmVyLmZyb20oYXJncyldKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICAqIEV4ZWN1dGUgYSBmdW5jdGlvbiBjYWxsLlxuICAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgdGhlIGZ1bmN0aW9uIGNhbGwuXG4gICAgICAqIEBwYXJhbSBvcHRpb25zLmNvbnRyYWN0SWQgVGhlIE5FQVIgYWNjb3VudCBJRCBvZiB0aGUgc21hcnQgY29udHJhY3QuXG4gICAgICAqIEBwYXJhbSBvcHRpb25zLm1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0byBiZSBjYWxsZWQgb24gdGhlIHNtYXJ0IGNvbnRyYWN0LlxuICAgICAgKiBAcGFyYW0gb3B0aW9ucy5hcmdzIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFzc2VkIHRvIHRoZSBtZXRob2QuXG4gICAgICAqIEBwYXJhbSBvcHRpb25zLmdhcyBUaGUgbWF4aW11bSBhbW91bnQgb2YgZ2FzIHRvIGJlIHVzZWQgZm9yIHRoZSBmdW5jdGlvbiBjYWxsLlxuICAgICAgKiBAcGFyYW0gb3B0aW9ucy5hdHRhY2hlZERlcG9zaXQgVGhlIGFtb3VudCBvZiBORUFSIHRva2VucyB0byBiZSBhdHRhY2hlZCB0byB0aGUgZnVuY3Rpb24gY2FsbC5cbiAgICAgICogQHBhcmFtIG9wdGlvbnMud2FsbGV0TWV0YSBNZXRhZGF0YSBmb3Igd2FsbGV0IGludGVncmF0aW9uLlxuICAgICAgKiBAcGFyYW0gb3B0aW9ucy53YWxsZXRDYWxsYmFja1VybCBUaGUgY2FsbGJhY2sgVVJMIGZvciB3YWxsZXQgaW50ZWdyYXRpb24uXG4gICAgICAqIEBwYXJhbSBvcHRpb25zLnN0cmluZ2lmeSBBIGZ1bmN0aW9uIHRvIGNvbnZlcnQgaW5wdXQgYXJndW1lbnRzIGludG8gYnl0ZXMgYXJyYXlcbiAgICAgICogQHBhcmFtIG9wdGlvbnMuanNDb250cmFjdCBXaGV0aGVyIHRoZSBjb250cmFjdCBpcyBmcm9tIEpTIFNESywgYXV0b21hdGljYWxseSBlbmNvZGVzIGFyZ3MgZnJvbSBKUyBTREsgdG8gYmluYXJ5LlxuICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGaW5hbEV4ZWN1dGlvbk91dGNvbWU+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgZmluYWwgZXhlY3V0aW9uIG91dGNvbWUgb2YgdGhlIGZ1bmN0aW9uIGNhbGwuXG4gICAgICAqL1xuICAgIGFzeW5jIGZ1bmN0aW9uQ2FsbCh7IGNvbnRyYWN0SWQsIG1ldGhvZE5hbWUsIGFyZ3MgPSB7fSwgZ2FzID0gdXRpbHNfMS5ERUZBVUxUX0ZVTkNUSU9OX0NBTExfR0FTLCBhdHRhY2hlZERlcG9zaXQsIHdhbGxldE1ldGEsIHdhbGxldENhbGxiYWNrVXJsLCBzdHJpbmdpZnksIGpzQ29udHJhY3QgfSkge1xuICAgICAgICB0aGlzLnZhbGlkYXRlQXJncyhhcmdzKTtcbiAgICAgICAgbGV0IGZ1bmN0aW9uQ2FsbEFyZ3M7XG4gICAgICAgIGlmIChqc0NvbnRyYWN0KSB7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGVkQXJncyA9IHRoaXMuZW5jb2RlSlNDb250cmFjdEFyZ3MoY29udHJhY3RJZCwgbWV0aG9kTmFtZSwgSlNPTi5zdHJpbmdpZnkoYXJncykpO1xuICAgICAgICAgICAgZnVuY3Rpb25DYWxsQXJncyA9IFsnY2FsbF9qc19jb250cmFjdCcsIGVuY29kZWRBcmdzLCBnYXMsIGF0dGFjaGVkRGVwb3NpdCwgbnVsbCwgdHJ1ZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzdHJpbmdpZnlBcmcgPSBzdHJpbmdpZnkgPT09IHVuZGVmaW5lZCA/IHRyYW5zYWN0aW9uc18xLnN0cmluZ2lmeUpzb25PckJ5dGVzIDogc3RyaW5naWZ5O1xuICAgICAgICAgICAgZnVuY3Rpb25DYWxsQXJncyA9IFttZXRob2ROYW1lLCBhcmdzLCBnYXMsIGF0dGFjaGVkRGVwb3NpdCwgc3RyaW5naWZ5QXJnLCBmYWxzZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICByZWNlaXZlcklkOiBqc0NvbnRyYWN0ID8gdGhpcy5jb25uZWN0aW9uLmpzdm1BY2NvdW50SWQgOiBjb250cmFjdElkLFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1zcHJlYWRcbiAgICAgICAgICAgIGFjdGlvbnM6IFtmdW5jdGlvbkNhbGwuYXBwbHkodm9pZCAwLCBmdW5jdGlvbkNhbGxBcmdzKV0sXG4gICAgICAgICAgICB3YWxsZXRNZXRhLFxuICAgICAgICAgICAgd2FsbGV0Q2FsbGJhY2tVcmxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzZWUgW2h0dHBzOi8vZG9jcy5uZWFyLm9yZy9jb25jZXB0cy9iYXNpY3MvYWNjb3VudHMvYWNjZXNzLWtleXNdKGh0dHBzOi8vZG9jcy5uZWFyLm9yZy9jb25jZXB0cy9iYXNpY3MvYWNjb3VudHMvYWNjZXNzLWtleXMpXG4gICAgICogQHRvZG8gZXhwYW5kIHRoaXMgQVBJIHRvIHN1cHBvcnQgbW9yZSBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBwdWJsaWNLZXkgQSBwdWJsaWMga2V5IHRvIGJlIGFzc29jaWF0ZWQgd2l0aCB0aGUgY29udHJhY3RcbiAgICAgKiBAcGFyYW0gY29udHJhY3RJZCBORUFSIGFjY291bnQgd2hlcmUgdGhlIGNvbnRyYWN0IGlzIGRlcGxveWVkXG4gICAgICogQHBhcmFtIG1ldGhvZE5hbWVzIFRoZSBtZXRob2QgbmFtZXMgb24gdGhlIGNvbnRyYWN0IHRoYXQgc2hvdWxkIGJlIGFsbG93ZWQgdG8gYmUgY2FsbGVkLiBQYXNzIG51bGwgZm9yIG5vIG1ldGhvZCBuYW1lcyBhbmQgJycgb3IgW10gZm9yIGFueSBtZXRob2QgbmFtZXMuXG4gICAgICogQHBhcmFtIGFtb3VudCBQYXltZW50IGluIHlvY3Rv4pODIHRoYXQgaXMgc2VudCB0byB0aGUgY29udHJhY3QgZHVyaW5nIHRoaXMgZnVuY3Rpb24gY2FsbFxuICAgICAqL1xuICAgIGFzeW5jIGFkZEtleShwdWJsaWNLZXksIGNvbnRyYWN0SWQsIG1ldGhvZE5hbWVzLCBhbW91bnQpIHtcbiAgICAgICAgaWYgKCFtZXRob2ROYW1lcykge1xuICAgICAgICAgICAgbWV0aG9kTmFtZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWV0aG9kTmFtZXMpKSB7XG4gICAgICAgICAgICBtZXRob2ROYW1lcyA9IFttZXRob2ROYW1lc107XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFjY2Vzc0tleTtcbiAgICAgICAgaWYgKCFjb250cmFjdElkKSB7XG4gICAgICAgICAgICBhY2Nlc3NLZXkgPSBmdWxsQWNjZXNzS2V5KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhY2Nlc3NLZXkgPSBmdW5jdGlvbkNhbGxBY2Nlc3NLZXkoY29udHJhY3RJZCwgbWV0aG9kTmFtZXMsIGFtb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICByZWNlaXZlcklkOiB0aGlzLmFjY291bnRJZCxcbiAgICAgICAgICAgIGFjdGlvbnM6IFthZGRLZXkoY3J5cHRvXzEuUHVibGljS2V5LmZyb20ocHVibGljS2V5KSwgYWNjZXNzS2V5KV1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBwdWJsaWNLZXkgVGhlIHB1YmxpYyBrZXkgdG8gYmUgZGVsZXRlZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZpbmFsRXhlY3V0aW9uT3V0Y29tZT59XG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlS2V5KHB1YmxpY0tleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaWduQW5kU2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgIHJlY2VpdmVySWQ6IHRoaXMuYWNjb3VudElkLFxuICAgICAgICAgICAgYWN0aW9uczogW2RlbGV0ZUtleShjcnlwdG9fMS5QdWJsaWNLZXkuZnJvbShwdWJsaWNLZXkpKV1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzZWUgW2h0dHBzOi8vbmVhci1ub2Rlcy5pby92YWxpZGF0b3Ivc3Rha2luZy1hbmQtZGVsZWdhdGlvbl0oaHR0cHM6Ly9uZWFyLW5vZGVzLmlvL3ZhbGlkYXRvci9zdGFraW5nLWFuZC1kZWxlZ2F0aW9uKVxuICAgICAqXG4gICAgICogQHBhcmFtIHB1YmxpY0tleSBUaGUgcHVibGljIGtleSBmb3IgdGhlIGFjY291bnQgdGhhdCdzIHN0YWtpbmdcbiAgICAgKiBAcGFyYW0gYW1vdW50IFRoZSBhY2NvdW50IHRvIHN0YWtlIGluIHlvY3Rv4pODXG4gICAgICovXG4gICAgYXN5bmMgc3Rha2UocHVibGljS2V5LCBhbW91bnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICByZWNlaXZlcklkOiB0aGlzLmFjY291bnRJZCxcbiAgICAgICAgICAgIGFjdGlvbnM6IFtzdGFrZShhbW91bnQsIGNyeXB0b18xLlB1YmxpY0tleS5mcm9tKHB1YmxpY0tleSkpXVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcG9zZSBhbmQgc2lnbiBhIFNpZ25lZERlbGVnYXRlIGFjdGlvbiB0byBiZSBleGVjdXRlZCBpbiBhIHRyYW5zYWN0aW9uIG9uIGJlaGFsZiBvZiB0aGlzIEFjY291bnQgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgZm9yIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hY3Rpb25zIEFjdGlvbnMgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIG1ldGEgdHJhbnNhY3Rpb25cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5ibG9ja0hlaWdodFR0bCBOdW1iZXIgb2YgYmxvY2tzIHBhc3QgdGhlIGN1cnJlbnQgYmxvY2sgaGVpZ2h0IGZvciB3aGljaCB0aGUgU2lnbmVkRGVsZWdhdGUgYWN0aW9uIG1heSBiZSBpbmNsdWRlZCBpbiBhIG1ldGEgdHJhbnNhY3Rpb25cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5yZWNlaXZlcklkIFJlY2VpdmVyIGFjY291bnQgb2YgdGhlIG1ldGEgdHJhbnNhY3Rpb25cbiAgICAgKi9cbiAgICBhc3luYyBzaWduZWREZWxlZ2F0ZSh7IGFjdGlvbnMsIGJsb2NrSGVpZ2h0VHRsLCByZWNlaXZlcklkLCB9KSB7XG4gICAgICAgIGNvbnN0IHsgcHJvdmlkZXIsIHNpZ25lciB9ID0gdGhpcy5jb25uZWN0aW9uO1xuICAgICAgICBjb25zdCB7IGhlYWRlciB9ID0gYXdhaXQgcHJvdmlkZXIuYmxvY2soeyBmaW5hbGl0eTogJ2ZpbmFsJyB9KTtcbiAgICAgICAgY29uc3QgeyBhY2Nlc3NLZXksIHB1YmxpY0tleSB9ID0gYXdhaXQgdGhpcy5maW5kQWNjZXNzS2V5KG51bGwsIG51bGwpO1xuICAgICAgICBjb25zdCBkZWxlZ2F0ZUFjdGlvbiA9ICgwLCB0cmFuc2FjdGlvbnNfMS5idWlsZERlbGVnYXRlQWN0aW9uKSh7XG4gICAgICAgICAgICBhY3Rpb25zLFxuICAgICAgICAgICAgbWF4QmxvY2tIZWlnaHQ6IEJpZ0ludChoZWFkZXIuaGVpZ2h0KSArIEJpZ0ludChibG9ja0hlaWdodFR0bCksXG4gICAgICAgICAgICBub25jZTogQmlnSW50KGFjY2Vzc0tleS5ub25jZSkgKyAxbixcbiAgICAgICAgICAgIHB1YmxpY0tleSxcbiAgICAgICAgICAgIHJlY2VpdmVySWQsXG4gICAgICAgICAgICBzZW5kZXJJZDogdGhpcy5hY2NvdW50SWQsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IHNpZ25lZERlbGVnYXRlQWN0aW9uIH0gPSBhd2FpdCAoMCwgdHJhbnNhY3Rpb25zXzEuc2lnbkRlbGVnYXRlQWN0aW9uKSh7XG4gICAgICAgICAgICBkZWxlZ2F0ZUFjdGlvbixcbiAgICAgICAgICAgIHNpZ25lcjoge1xuICAgICAgICAgICAgICAgIHNpZ246IGFzeW5jIChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2lnbmF0dXJlIH0gPSBhd2FpdCBzaWduZXIuc2lnbk1lc3NhZ2UobWVzc2FnZSwgZGVsZWdhdGVBY3Rpb24uc2VuZGVySWQsIHRoaXMuY29ubmVjdGlvbi5uZXR3b3JrSWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmF0dXJlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2lnbmVkRGVsZWdhdGVBY3Rpb247XG4gICAgfVxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgdmFsaWRhdGVBcmdzKGFyZ3MpIHtcbiAgICAgICAgY29uc3QgaXNVaW50OEFycmF5ID0gYXJncy5ieXRlTGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgYXJncy5ieXRlTGVuZ3RoID09PSBhcmdzLmxlbmd0aDtcbiAgICAgICAgaWYgKGlzVWludDhBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpIHx8IHR5cGVvZiBhcmdzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHR5cGVzXzEuUG9zaXRpb25hbEFyZ3NFcnJvcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludm9rZSBhIGNvbnRyYWN0IHZpZXcgZnVuY3Rpb24gdXNpbmcgdGhlIFJQQyBBUEkuXG4gICAgICogQHNlZSBbaHR0cHM6Ly9kb2NzLm5lYXIub3JnL2FwaS9ycGMvY29udHJhY3RzI2NhbGwtYS1jb250cmFjdC1mdW5jdGlvbl0oaHR0cHM6Ly9kb2NzLm5lYXIub3JnL2FwaS9ycGMvY29udHJhY3RzI2NhbGwtYS1jb250cmFjdC1mdW5jdGlvbilcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIEZ1bmN0aW9uIGNhbGwgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jb250cmFjdElkIE5FQVIgYWNjb3VudCB3aGVyZSB0aGUgY29udHJhY3QgaXMgZGVwbG95ZWRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5tZXRob2ROYW1lIFRoZSB2aWV3LW9ubHkgbWV0aG9kIChubyBzdGF0ZSBtdXRhdGlvbnMpIG5hbWUgb24gdGhlIGNvbnRyYWN0IGFzIGl0IGlzIHdyaXR0ZW4gaW4gdGhlIGNvbnRyYWN0IGNvZGVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hcmdzIEFueSBhcmd1bWVudHMgdG8gdGhlIHZpZXcgY29udHJhY3QgbWV0aG9kLCB3cmFwcGVkIGluIEpTT05cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5wYXJzZSBQYXJzZSB0aGUgcmVzdWx0IG9mIHRoZSBjYWxsLiBSZWNlaXZlcyBhIEJ1ZmZlciAoYnl0ZXMgYXJyYXkpIGFuZCBjb252ZXJ0cyBpdCB0byBhbnkgb2JqZWN0LiBCeSBkZWZhdWx0IHJlc3VsdCB3aWxsIGJlIHRyZWF0ZWQgYXMganNvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zdHJpbmdpZnkgQ29udmVydCBpbnB1dCBhcmd1bWVudHMgaW50byBhIGJ5dGVzIGFycmF5LiBCeSBkZWZhdWx0IHRoZSBpbnB1dCBpcyB0cmVhdGVkIGFzIGEgSlNPTi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5qc0NvbnRyYWN0IElzIGNvbnRyYWN0IGZyb20gSlMgU0RLLCBhdXRvbWF0aWNhbGx5IGVuY29kZXMgYXJncyBmcm9tIEpTIFNESyB0byBiaW5hcnkuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYmxvY2tRdWVyeSBzcGVjaWZpZXMgd2hpY2ggYmxvY2sgdG8gcXVlcnkgc3RhdGUgYXQuIEJ5IGRlZmF1bHQgcmV0dXJucyBsYXN0IFwib3B0aW1pc3RpY1wiIGJsb2NrIChpLmUuIG5vdCBuZWNlc3NhcmlseSBmaW5hbGl6ZWQpLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgYXN5bmMgdmlld0Z1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0ICgwLCB1dGlsc18yLnZpZXdGdW5jdGlvbikodGhpcy5jb25uZWN0aW9uLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3RhdGUgKGtleSB2YWx1ZSBwYWlycykgb2YgdGhpcyBhY2NvdW50J3MgY29udHJhY3QgYmFzZWQgb24gdGhlIGtleSBwcmVmaXguXG4gICAgICogUGFzcyBhbiBlbXB0eSBzdHJpbmcgZm9yIHByZWZpeCBpZiB5b3Ugd291bGQgbGlrZSB0byByZXR1cm4gdGhlIGVudGlyZSBzdGF0ZS5cbiAgICAgKiBAc2VlIFtodHRwczovL2RvY3MubmVhci5vcmcvYXBpL3JwYy9jb250cmFjdHMjdmlldy1jb250cmFjdC1zdGF0ZV0oaHR0cHM6Ly9kb2NzLm5lYXIub3JnL2FwaS9ycGMvY29udHJhY3RzI3ZpZXctY29udHJhY3Qtc3RhdGUpXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHJlZml4IGFsbG93cyB0byBmaWx0ZXIgd2hpY2gga2V5cyBzaG91bGQgYmUgcmV0dXJuZWQuIEVtcHR5IHByZWZpeCBtZWFucyBhbGwga2V5cy4gU3RyaW5nIHByZWZpeCBpcyB1dGYtOCBlbmNvZGVkLlxuICAgICAqIEBwYXJhbSBibG9ja1F1ZXJ5IHNwZWNpZmllcyB3aGljaCBibG9jayB0byBxdWVyeSBzdGF0ZSBhdC4gQnkgZGVmYXVsdCByZXR1cm5zIGxhc3QgXCJvcHRpbWlzdGljXCIgYmxvY2sgKGkuZS4gbm90IG5lY2Vzc2FyaWx5IGZpbmFsaXplZCkuXG4gICAgICovXG4gICAgYXN5bmMgdmlld1N0YXRlKHByZWZpeCwgYmxvY2tRdWVyeSA9IHsgZmluYWxpdHk6ICdvcHRpbWlzdGljJyB9KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCAoMCwgdXRpbHNfMi52aWV3U3RhdGUpKHRoaXMuY29ubmVjdGlvbiwgdGhpcy5hY2NvdW50SWQsIHByZWZpeCwgYmxvY2tRdWVyeSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgYWNjZXNzIGtleXMgZm9yIHRoZSBhY2NvdW50XG4gICAgICogQHNlZSBbaHR0cHM6Ly9kb2NzLm5lYXIub3JnL2FwaS9ycGMvYWNjZXNzLWtleXMjdmlldy1hY2Nlc3Mta2V5LWxpc3RdKGh0dHBzOi8vZG9jcy5uZWFyLm9yZy9hcGkvcnBjL2FjY2Vzcy1rZXlzI3ZpZXctYWNjZXNzLWtleS1saXN0KVxuICAgICAqL1xuICAgIGFzeW5jIGdldEFjY2Vzc0tleXMoKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLnByb3ZpZGVyLnF1ZXJ5KHtcbiAgICAgICAgICAgIHJlcXVlc3RfdHlwZTogJ3ZpZXdfYWNjZXNzX2tleV9saXN0JyxcbiAgICAgICAgICAgIGFjY291bnRfaWQ6IHRoaXMuYWNjb3VudElkLFxuICAgICAgICAgICAgZmluYWxpdHk6ICdvcHRpbWlzdGljJ1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gUmVwbGFjZSByYXcgbm9uY2UgaW50byBhIG5ldyBCaWdJbnRcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlPy5rZXlzPy5tYXAoKGtleSkgPT4gKHsgLi4ua2V5LCBhY2Nlc3Nfa2V5OiB7IC4uLmtleS5hY2Nlc3Nfa2V5LCBub25jZTogQmlnSW50KGtleS5hY2Nlc3Nfa2V5Lm5vbmNlKSB9IH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgYXV0aG9yaXplZCBhcHBzXG4gICAgICogQHRvZG8gdXBkYXRlIHRoZSByZXNwb25zZSB2YWx1ZSB0byByZXR1cm4gYWxsIHRoZSBkaWZmZXJlbnQga2V5cywgbm90IGp1c3QgYXBwIGtleXMuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWNjb3VudERldGFpbHMoKSB7XG4gICAgICAgIC8vIFRPRE86IHVwZGF0ZSB0aGUgcmVzcG9uc2UgdmFsdWUgdG8gcmV0dXJuIGFsbCB0aGUgZGlmZmVyZW50IGtleXMsIG5vdCBqdXN0IGFwcCBrZXlzLlxuICAgICAgICAvLyBBbHNvIGlmIHdlIG5lZWQgdGhpcyBmdW5jdGlvbiwgb3IgZ2V0QWNjZXNzS2V5cyBpcyBnb29kIGVub3VnaC5cbiAgICAgICAgY29uc3QgYWNjZXNzS2V5cyA9IGF3YWl0IHRoaXMuZ2V0QWNjZXNzS2V5cygpO1xuICAgICAgICBjb25zdCBhdXRob3JpemVkQXBwcyA9IGFjY2Vzc0tleXNcbiAgICAgICAgICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtLmFjY2Vzc19rZXkucGVybWlzc2lvbiAhPT0gJ0Z1bGxBY2Nlc3MnKVxuICAgICAgICAgICAgLm1hcChpdGVtID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBlcm0gPSBpdGVtLmFjY2Vzc19rZXkucGVybWlzc2lvbjtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29udHJhY3RJZDogcGVybS5GdW5jdGlvbkNhbGwucmVjZWl2ZXJfaWQsXG4gICAgICAgICAgICAgICAgYW1vdW50OiBwZXJtLkZ1bmN0aW9uQ2FsbC5hbGxvd2FuY2UsXG4gICAgICAgICAgICAgICAgcHVibGljS2V5OiBpdGVtLnB1YmxpY19rZXksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgYXV0aG9yaXplZEFwcHMgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjYWxjdWxhdGVkIGFjY291bnQgYmFsYW5jZVxuICAgICAqL1xuICAgIGFzeW5jIGdldEFjY291bnRCYWxhbmNlKCkge1xuICAgICAgICBjb25zdCBwcm90b2NvbENvbmZpZyA9IGF3YWl0IHRoaXMuY29ubmVjdGlvbi5wcm92aWRlci5leHBlcmltZW50YWxfcHJvdG9jb2xDb25maWcoeyBmaW5hbGl0eTogJ2ZpbmFsJyB9KTtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBhd2FpdCB0aGlzLnN0YXRlKCk7XG4gICAgICAgIGNvbnN0IGNvc3RQZXJCeXRlID0gQmlnSW50KHByb3RvY29sQ29uZmlnLnJ1bnRpbWVfY29uZmlnLnN0b3JhZ2VfYW1vdW50X3Blcl9ieXRlKTtcbiAgICAgICAgY29uc3Qgc3RhdGVTdGFrZWQgPSBCaWdJbnQoc3RhdGUuc3RvcmFnZV91c2FnZSkgKiBjb3N0UGVyQnl0ZTtcbiAgICAgICAgY29uc3Qgc3Rha2VkID0gQmlnSW50KHN0YXRlLmxvY2tlZCk7XG4gICAgICAgIGNvbnN0IHRvdGFsQmFsYW5jZSA9IEJpZ0ludChzdGF0ZS5hbW91bnQpICsgc3Rha2VkO1xuICAgICAgICBjb25zdCBhdmFpbGFibGVCYWxhbmNlID0gdG90YWxCYWxhbmNlIC0gKHN0YWtlZCA+IHN0YXRlU3Rha2VkID8gc3Rha2VkIDogc3RhdGVTdGFrZWQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG90YWw6IHRvdGFsQmFsYW5jZS50b1N0cmluZygpLFxuICAgICAgICAgICAgc3RhdGVTdGFrZWQ6IHN0YXRlU3Rha2VkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBzdGFrZWQ6IHN0YWtlZC50b1N0cmluZygpLFxuICAgICAgICAgICAgYXZhaWxhYmxlOiBhdmFpbGFibGVCYWxhbmNlLnRvU3RyaW5nKClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgTkVBUiB0b2tlbnMgYmFsYW5jZSBhbmQgdmFsaWRhdG9ycyBvZiBhIGdpdmVuIGFjY291bnQgdGhhdCBpcyBkZWxlZ2F0ZWQgdG8gdGhlIHN0YWtpbmcgcG9vbHMgdGhhdCBhcmUgcGFydCBvZiB0aGUgdmFsaWRhdG9ycyBzZXQgaW4gdGhlIGN1cnJlbnQgZXBvY2guXG4gICAgICpcbiAgICAgKiBOT1RFOiBJZiB0aGUgdG9rZW5zIGFyZSBkZWxlZ2F0ZWQgdG8gYSBzdGFraW5nIHBvb2wgdGhhdCBpcyBjdXJyZW50bHkgb24gcGF1c2Ugb3IgZG9lcyBub3QgaGF2ZSBlbm91Z2ggdG9rZW5zIHRvIHBhcnRpY2lwYXRlIGluIHZhbGlkYXRpb24sIHRoZXkgd29uJ3QgYmUgYWNjb3VudGVkIGZvci5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBY3RpdmVEZWxlZ2F0ZWRTdGFrZUJhbGFuY2U+fVxuICAgICAqL1xuICAgIGFzeW5jIGdldEFjdGl2ZURlbGVnYXRlZFN0YWtlQmFsYW5jZSgpIHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb24ucHJvdmlkZXIuYmxvY2soeyBmaW5hbGl0eTogJ2ZpbmFsJyB9KTtcbiAgICAgICAgY29uc3QgYmxvY2tIYXNoID0gYmxvY2suaGVhZGVyLmhhc2g7XG4gICAgICAgIGNvbnN0IGVwb2NoSWQgPSBibG9jay5oZWFkZXIuZXBvY2hfaWQ7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudF92YWxpZGF0b3JzLCBuZXh0X3ZhbGlkYXRvcnMsIGN1cnJlbnRfcHJvcG9zYWxzIH0gPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb24ucHJvdmlkZXIudmFsaWRhdG9ycyhlcG9jaElkKTtcbiAgICAgICAgY29uc3QgcG9vbHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIFsuLi5jdXJyZW50X3ZhbGlkYXRvcnMsIC4uLm5leHRfdmFsaWRhdG9ycywgLi4uY3VycmVudF9wcm9wb3NhbHNdXG4gICAgICAgICAgICAuZm9yRWFjaCgodmFsaWRhdG9yKSA9PiBwb29scy5hZGQodmFsaWRhdG9yLmFjY291bnRfaWQpKTtcbiAgICAgICAgY29uc3QgdW5pcXVlUG9vbHMgPSBbLi4ucG9vbHNdO1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IHVuaXF1ZVBvb2xzXG4gICAgICAgICAgICAubWFwKCh2YWxpZGF0b3IpID0+ICh0aGlzLnZpZXdGdW5jdGlvbih7XG4gICAgICAgICAgICBjb250cmFjdElkOiB2YWxpZGF0b3IsXG4gICAgICAgICAgICBtZXRob2ROYW1lOiAnZ2V0X2FjY291bnRfdG90YWxfYmFsYW5jZScsXG4gICAgICAgICAgICBhcmdzOiB7IGFjY291bnRfaWQ6IHRoaXMuYWNjb3VudElkIH0sXG4gICAgICAgICAgICBibG9ja1F1ZXJ5OiB7IGJsb2NrSWQ6IGJsb2NrSGFzaCB9XG4gICAgICAgIH0pKSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQocHJvbWlzZXMpO1xuICAgICAgICBjb25zdCBoYXNUaW1lb3V0RXJyb3IgPSByZXN1bHRzLnNvbWUoKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09ICdyZWplY3RlZCcgJiYgcmVzdWx0LnJlYXNvbi50eXBlID09PSAnVGltZW91dEVycm9yJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gV2hlbiBSUEMgaXMgZG93biBhbmQgcmV0dXJuIHRpbWVvdXQgZXJyb3IsIHRocm93IGVycm9yXG4gICAgICAgIGlmIChoYXNUaW1lb3V0RXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCBkZWxlZ2F0ZWQgc3Rha2UgYmFsYW5jZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN1bW1hcnkgPSByZXN1bHRzLnJlZHVjZSgocmVzdWx0LCBzdGF0ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRvcklkID0gdW5pcXVlUG9vbHNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHN0YXRlLnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Qk4gPSBCaWdJbnQoc3RhdGUudmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Qk4gIT09IDBuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFrZWRWYWxpZGF0b3JzOiBbLi4ucmVzdWx0LnN0YWtlZFZhbGlkYXRvcnMsIHsgdmFsaWRhdG9ySWQsIGFtb3VudDogY3VycmVudEJOLnRvU3RyaW5nKCkgfV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbDogcmVzdWx0LnRvdGFsICsgY3VycmVudEJOLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZS5zdGF0dXMgPT09ICdyZWplY3RlZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIGZhaWxlZFZhbGlkYXRvcnM6IFsuLi5yZXN1bHQuZmFpbGVkVmFsaWRhdG9ycywgeyB2YWxpZGF0b3JJZCwgZXJyb3I6IHN0YXRlLnJlYXNvbiB9XSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSwgeyBzdGFrZWRWYWxpZGF0b3JzOiBbXSwgZmFpbGVkVmFsaWRhdG9yczogW10sIHRvdGFsOiAwbiB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1bW1hcnksXG4gICAgICAgICAgICB0b3RhbDogc3VtbWFyeS50b3RhbC50b1N0cmluZygpLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQWNjb3VudCA9IEFjY291bnQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/account.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/account_2fa.cjs":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/account_2fa.cjs ***!
  \****************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Account2FA = void 0;\nconst crypto_1 = __webpack_require__(/*! @near-js/crypto */ \"(ssr)/./node_modules/.pnpm/@near-js+crypto@1.4.1/node_modules/@near-js/crypto/lib/commonjs/index.cjs\");\nconst types_1 = __webpack_require__(/*! @near-js/types */ \"(ssr)/./node_modules/.pnpm/@near-js+types@0.3.1/node_modules/@near-js/types/lib/commonjs/index.cjs\");\nconst transactions_1 = __webpack_require__(/*! @near-js/transactions */ \"(ssr)/./node_modules/.pnpm/@near-js+transactions@1.3.1/node_modules/@near-js/transactions/lib/commonjs/index.cjs\");\nconst utils_1 = __webpack_require__(/*! @near-js/utils */ \"(ssr)/./node_modules/.pnpm/@near-js+utils@1.0.1/node_modules/@near-js/utils/lib/commonjs/index.cjs\");\nconst isomorphic_unfetch_1 = __importDefault(__webpack_require__(/*! isomorphic-unfetch */ \"(ssr)/./node_modules/.pnpm/isomorphic-unfetch@3.1.0/node_modules/isomorphic-unfetch/index.js\"));\nconst account_multisig_1 = __webpack_require__(/*! ./account_multisig.cjs */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/account_multisig.cjs\");\nconst constants_1 = __webpack_require__(/*! ./constants.cjs */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/constants.cjs\");\nconst types_2 = __webpack_require__(/*! ./types.cjs */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/types.cjs\");\nconst { addKey, deleteKey, deployContract, fullAccessKey, functionCall, functionCallAccessKey } = transactions_1.actionCreators;\nclass Account2FA extends account_multisig_1.AccountMultisig {\n    /********************************\n    Account2FA has options object where you can provide callbacks for:\n    - sendCode: how to send the 2FA code in case you don't use NEAR Contract Helper\n    - getCode: how to get code from user (use this to provide custom UI/UX for prompt of 2FA code)\n    - onResult: the tx result after it's been confirmed by NEAR Contract Helper\n    ********************************/\n    sendCode;\n    getCode;\n    verifyCode;\n    onConfirmResult;\n    helperUrl = 'https://helper.testnet.near.org';\n    constructor(connection, accountId, options) {\n        super(connection, accountId, options);\n        this.helperUrl = options.helperUrl || this.helperUrl;\n        this.storage = options.storage;\n        this.sendCode = options.sendCode || this.sendCodeDefault;\n        this.getCode = options.getCode || this.getCodeDefault;\n        this.verifyCode = options.verifyCode || this.verifyCodeDefault;\n        this.onConfirmResult = options.onConfirmResult;\n    }\n    /**\n     * Sign a transaction to preform a list of actions and broadcast it using the RPC API.\n     * @see {@link \"@near-js/providers\".json-rpc-provider.JsonRpcProvider.sendTransaction | JsonRpcProvider.sendTransaction}\n     *\n     * @param options Options for the transaction.\n     * @param options.receiverId The NEAR account ID of the transaction receiver.\n     * @param options.actions The list of actions to be included in the transaction.\n     * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the transaction.\n     */\n    async signAndSendTransaction({ receiverId, actions }) {\n        await super.signAndSendTransaction({ receiverId, actions });\n        // TODO: Should following override onRequestResult in superclass instead of doing custom signAndSendTransaction?\n        await this.sendCode();\n        const result = await this.promptAndVerify();\n        if (this.onConfirmResult) {\n            await this.onConfirmResult(result);\n        }\n        return result;\n    }\n    // default helpers for CH deployments of multisig\n    /**\n     * Deploy a multisig contract with 2FA and handle the deployment process.\n     * @param contractBytes - The bytecode of the multisig contract.\n     * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the deployment.\n     */\n    async deployMultisig(contractBytes) {\n        const { accountId } = this;\n        const seedOrLedgerKey = (await this.getRecoveryMethods()).data\n            // @ts-ignore\n            .filter(({ kind, publicKey }) => (kind === 'phrase' || kind === 'ledger') && publicKey !== null)\n            .map((rm) => rm.publicKey);\n        const fak2lak = (await this.getAccessKeys())\n            .filter(({ public_key, access_key: { permission } }) => permission === 'FullAccess' && !seedOrLedgerKey.includes(public_key))\n            .map((ak) => ak.public_key)\n            .map(toPK);\n        // @ts-ignore\n        const confirmOnlyKey = toPK((await this.postSignedJson('/2fa/getAccessKey', { accountId })).publicKey);\n        const newArgs = Buffer.from(JSON.stringify({ 'num_confirmations': 2 }));\n        const actions = [\n            ...fak2lak.map((pk) => deleteKey(pk)),\n            ...fak2lak.map((pk) => addKey(pk, functionCallAccessKey(accountId, constants_1.MULTISIG_CHANGE_METHODS, null))),\n            addKey(confirmOnlyKey, functionCallAccessKey(accountId, constants_1.MULTISIG_CONFIRM_METHODS, null)),\n            deployContract(contractBytes),\n        ];\n        const newFunctionCallActionBatch = actions.concat(functionCall('new', newArgs, constants_1.MULTISIG_GAS, constants_1.MULTISIG_DEPOSIT));\n        utils_1.Logger.log('deploying multisig contract for', accountId);\n        const { stateStatus: multisigStateStatus } = await this.checkMultisigCodeAndStateStatus(contractBytes);\n        switch (multisigStateStatus) {\n            case types_2.MultisigStateStatus.STATE_NOT_INITIALIZED:\n                return await super.signAndSendTransactionWithAccount(accountId, newFunctionCallActionBatch);\n            case types_2.MultisigStateStatus.VALID_STATE:\n                return await super.signAndSendTransactionWithAccount(accountId, actions);\n            case types_2.MultisigStateStatus.INVALID_STATE:\n                throw new types_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account has existing state.`, 'ContractHasExistingState');\n            default:\n                throw new types_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account state could not be verified.`, 'ContractStateUnknown');\n        }\n    }\n    /**\n     * Disable 2FA with the option to clean up contract state.\n     * @param options Options for disabling 2FA.\n     * @param options.contractBytes The bytecode of the contract to deploy.\n     * @param options.cleanupContractBytes The bytecode of the cleanup contract (optional).\n     * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the operation.\n     */\n    async disableWithFAK({ contractBytes, cleanupContractBytes }) {\n        let cleanupActions = [];\n        if (cleanupContractBytes) {\n            await this.deleteAllRequests().catch(e => e);\n            cleanupActions = await this.get2faDisableCleanupActions(cleanupContractBytes);\n        }\n        const keyConversionActions = await this.get2faDisableKeyConversionActions();\n        const actions = [\n            ...cleanupActions,\n            ...keyConversionActions,\n            deployContract(contractBytes)\n        ];\n        const accessKeyInfo = await this.findAccessKey(this.accountId, actions);\n        if (accessKeyInfo && accessKeyInfo.accessKey && accessKeyInfo.accessKey.permission !== 'FullAccess') {\n            throw new types_1.TypedError('No full access key found in keystore. Unable to bypass multisig', 'NoFAKFound');\n        }\n        return this.signAndSendTransactionWithAccount(this.accountId, actions);\n    }\n    /**\n     * Retrieves cleanup actions for disabling 2FA.\n     * @param cleanupContractBytes - The bytecode of the cleanup contract.\n     * @returns {Promise<Action[]>} - A promise that resolves to an array of cleanup actions.\n     */\n    async get2faDisableCleanupActions(cleanupContractBytes) {\n        const currentAccountState = await this.viewState('').catch(error => {\n            const cause = error.cause && error.cause.name;\n            if (cause == 'NO_CONTRACT_CODE') {\n                return [];\n            }\n            throw cause == 'TOO_LARGE_CONTRACT_STATE'\n                ? new types_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account has existing state.`, 'ContractHasExistingState')\n                : error;\n        });\n        const currentAccountStateKeys = currentAccountState.map(({ key }) => key.toString('base64'));\n        return currentAccountState.length ? [\n            deployContract(cleanupContractBytes),\n            functionCall('clean', { keys: currentAccountStateKeys }, constants_1.MULTISIG_GAS, 0n)\n        ] : [];\n    }\n    /**\n     * Retrieves key conversion actions for disabling 2FA.\n     * @returns {Promise<Action[]>} - A promise that resolves to an array of key conversion actions.\n     */\n    async get2faDisableKeyConversionActions() {\n        const { accountId } = this;\n        const accessKeys = await this.getAccessKeys();\n        const lak2fak = accessKeys\n            .filter(({ access_key }) => access_key.permission !== 'FullAccess')\n            .filter(({ access_key }) => {\n            const perm = access_key.permission.FunctionCall;\n            return perm.receiver_id === accountId &&\n                perm.method_names.length === 4 &&\n                perm.method_names.includes('add_request_and_confirm');\n        });\n        // @ts-ignore\n        const confirmOnlyKey = crypto_1.PublicKey.from((await this.postSignedJson('/2fa/getAccessKey', { accountId })).publicKey);\n        return [\n            deleteKey(confirmOnlyKey),\n            ...lak2fak.map(({ public_key }) => deleteKey(crypto_1.PublicKey.from(public_key))),\n            ...lak2fak.map(({ public_key }) => addKey(crypto_1.PublicKey.from(public_key), fullAccessKey()))\n        ];\n    }\n    /**\n     * This method converts LAKs back to FAKs, clears state and deploys an 'empty' contract (contractBytes param)\n     * @param [contractBytes]{@link https://github.com/near/near-wallet/blob/master/packages/frontend/src/wasm/main.wasm?raw=true}\n     * @param [cleanupContractBytes]{@link https://github.com/near/core-contracts/blob/master/state-manipulation/res/state_cleanup.wasm?raw=true}\n     * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the operation.\n     */\n    async disable(contractBytes, cleanupContractBytes) {\n        const { stateStatus } = await this.checkMultisigCodeAndStateStatus();\n        if (stateStatus !== types_2.MultisigStateStatus.VALID_STATE && stateStatus !== types_2.MultisigStateStatus.STATE_NOT_INITIALIZED) {\n            throw new types_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account state could not be verified.`, 'ContractStateUnknown');\n        }\n        let deleteAllRequestsError;\n        await this.deleteAllRequests().catch(e => deleteAllRequestsError = e);\n        const cleanupActions = await this.get2faDisableCleanupActions(cleanupContractBytes).catch(e => {\n            if (e.type === 'ContractHasExistingState') {\n                throw deleteAllRequestsError || e;\n            }\n            throw e;\n        });\n        const actions = [\n            ...cleanupActions,\n            ...(await this.get2faDisableKeyConversionActions()),\n            deployContract(contractBytes),\n        ];\n        utils_1.Logger.log('disabling 2fa for', this.accountId);\n        return await this.signAndSendTransaction({\n            receiverId: this.accountId,\n            actions\n        });\n    }\n    /**\n     * Default implementation for sending the 2FA code.\n     * @returns {Promise<string>} - A promise that resolves to the request ID.\n     */\n    async sendCodeDefault() {\n        const { accountId } = this;\n        const { requestId } = this.getRequest();\n        const method = await this.get2faMethod();\n        await this.postSignedJson('/2fa/send', {\n            accountId,\n            method,\n            requestId,\n        });\n        return requestId;\n    }\n    async getCodeDefault() {\n        throw new Error('There is no getCode callback provided. Please provide your own in AccountMultisig constructor options. It has a parameter method where method.kind is \"email\" or \"phone\".');\n    }\n    /**\n     * Prompts the user to enter and verify the 2FA code.\n     * @returns {Promise<any>} - A promise that resolves to the verification result.\n     */\n    async promptAndVerify() {\n        const method = await this.get2faMethod();\n        const securityCode = await this.getCode(method);\n        try {\n            const result = await this.verifyCode(securityCode);\n            // TODO: Parse error from result for real (like in normal account.signAndSendTransaction)\n            return result;\n        }\n        catch (e) {\n            utils_1.Logger.warn('Error validating security code:', e);\n            if (e.toString().includes('invalid 2fa code provided') || e.toString().includes('2fa code not valid')) {\n                return await this.promptAndVerify();\n            }\n            throw e;\n        }\n    }\n    /**\n     * Verify the 2FA code using the default method.\n     * @param securityCode - The security code to verify.\n     * @returns {Promise<any>} A promise that resolves to the verification result.\n     */\n    async verifyCodeDefault(securityCode) {\n        const { accountId } = this;\n        const request = this.getRequest();\n        if (!request) {\n            throw new Error('no request pending');\n        }\n        const { requestId } = request;\n        return await this.postSignedJson('/2fa/verify', {\n            accountId,\n            securityCode,\n            requestId\n        });\n    }\n    /**\n     * Retrieves recovery methods for the account.\n     * @returns {Promise<{ accountId: string, data: any }>} - A promise that resolves to recovery methods data.\n     */\n    async getRecoveryMethods() {\n        const { accountId } = this;\n        return {\n            accountId,\n            data: await this.postSignedJson('/account/recoveryMethods', { accountId })\n        };\n    }\n    /**\n     * Gets the 2FA method (kind and detail).\n     * @returns {Promise<{ kind: string, detail: string }>} A promise that resolves to the 2FA method.\n     */\n    async get2faMethod() {\n        let { data } = await this.getRecoveryMethods();\n        // @ts-ignore\n        if (data && data.length) {\n            // @ts-ignore\n            data = data.find((m) => m.kind.indexOf('2fa-') === 0);\n        }\n        if (!data)\n            return null;\n        // @ts-ignore\n        const { kind, detail } = data;\n        return { kind, detail };\n    }\n    /**\n    * Generates a signature for the latest finalized block.\n    * @returns {Promise<{ blockNumber: string, blockNumberSignature: string }>} - A promise that resolves to the signature information.\n    */\n    async signatureFor() {\n        const { accountId } = this;\n        const block = await this.connection.provider.block({ finality: 'final' });\n        const blockNumber = block.header.height.toString();\n        const signed = await this.connection.signer.signMessage(Buffer.from(blockNumber), accountId, this.connection.networkId);\n        const blockNumberSignature = Buffer.from(signed.signature).toString('base64');\n        return { blockNumber, blockNumberSignature };\n    }\n    /**\n    * Sends a signed JSON request to a specified path.\n    * @param path - The path for the request.\n    * @param body - The request body.\n    * @returns {Promise<any>} - A promise that resolves to the response from the helper.\n    */\n    async postSignedJson(path, body) {\n        return await (0, isomorphic_unfetch_1.default)(this.helperUrl + path, {\n            body: JSON.stringify({\n                ...body,\n                ...(await this.signatureFor()),\n            }),\n            method: 'POST',\n        });\n    }\n}\nexports.Account2FA = Account2FA;\n// helpers\nconst toPK = (pk) => crypto_1.PublicKey.from(pk);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMS4zLjEvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9jb21tb25qcy9hY2NvdW50XzJmYS5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0I7QUFDbEIsaUJBQWlCLG1CQUFPLENBQUMsNkhBQWlCO0FBQzFDLGdCQUFnQixtQkFBTyxDQUFDLDBIQUFnQjtBQUN4Qyx1QkFBdUIsbUJBQU8sQ0FBQywrSUFBdUI7QUFDdEQsZ0JBQWdCLG1CQUFPLENBQUMsMEhBQWdCO0FBQ3hDLDZDQUE2QyxtQkFBTyxDQUFDLHdIQUFvQjtBQUN6RSwyQkFBMkIsbUJBQU8sQ0FBQyxtSkFBd0I7QUFDM0Qsb0JBQW9CLG1CQUFPLENBQUMscUlBQWlCO0FBQzdDLGdCQUFnQixtQkFBTyxDQUFDLDZIQUFhO0FBQ3JDLFFBQVEsd0ZBQXdGO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0NBQWdDO0FBQ2pEO0FBQ0EsbUNBQW1DLHFCQUFxQjtBQUN4RCw2Q0FBNkMscUJBQXFCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQ0FBZ0M7QUFDakQ7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQSx1QkFBdUIsMEJBQTBCLGNBQWM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLFdBQVc7QUFDakcscURBQXFELHdCQUF3QjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1DQUFtQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsZ0JBQWdCLGFBQWEsMEJBQTBCO0FBQzVJO0FBQ0EscUZBQXFGLGdCQUFnQixhQUFhLDBCQUEwQjtBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQ0FBZ0M7QUFDakQ7QUFDQSwyQkFBMkIscUNBQXFDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsZ0JBQWdCLGFBQWEsMEJBQTBCO0FBQ3hJO0FBQ0EsU0FBUztBQUNULG1FQUFtRSxLQUFLO0FBQ3hFO0FBQ0E7QUFDQSxvQ0FBb0MsK0JBQStCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBLHVCQUF1QixZQUFZO0FBQ25DLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EseUdBQXlHLFdBQVc7QUFDcEg7QUFDQTtBQUNBLDhCQUE4QixZQUFZO0FBQzFDLDhCQUE4QixZQUFZO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLHFDQUFxQztBQUNyQyxpQkFBaUIsZ0NBQWdDO0FBQ2pEO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBLGlGQUFpRixnQkFBZ0IsYUFBYSwwQkFBMEI7QUFDeEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUIsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixjQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsVUFBVSw4QkFBOEIsR0FBRztBQUM1RDtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBLDBFQUEwRSxXQUFXO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFVBQVUsOEJBQThCLEdBQUc7QUFDNUQ7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVLG1EQUFtRCxHQUFHO0FBQ2hGO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1Qiw2REFBNkQsbUJBQW1CO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hhY2thdGhvbi1uZWFyLXJlZGFjdGVkLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BuZWFyLWpzK2FjY291bnRzQDEuMy4xL25vZGVfbW9kdWxlcy9AbmVhci1qcy9hY2NvdW50cy9saWIvY29tbW9uanMvYWNjb3VudF8yZmEuY2pzP2YzYzAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFjY291bnQyRkEgPSB2b2lkIDA7XG5jb25zdCBjcnlwdG9fMSA9IHJlcXVpcmUoXCJAbmVhci1qcy9jcnlwdG9cIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIkBuZWFyLWpzL3R5cGVzXCIpO1xuY29uc3QgdHJhbnNhY3Rpb25zXzEgPSByZXF1aXJlKFwiQG5lYXItanMvdHJhbnNhY3Rpb25zXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbmVhci1qcy91dGlsc1wiKTtcbmNvbnN0IGlzb21vcnBoaWNfdW5mZXRjaF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJpc29tb3JwaGljLXVuZmV0Y2hcIikpO1xuY29uc3QgYWNjb3VudF9tdWx0aXNpZ18xID0gcmVxdWlyZShcIi4vYWNjb3VudF9tdWx0aXNpZy5janNcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50cy5janNcIik7XG5jb25zdCB0eXBlc18yID0gcmVxdWlyZShcIi4vdHlwZXMuY2pzXCIpO1xuY29uc3QgeyBhZGRLZXksIGRlbGV0ZUtleSwgZGVwbG95Q29udHJhY3QsIGZ1bGxBY2Nlc3NLZXksIGZ1bmN0aW9uQ2FsbCwgZnVuY3Rpb25DYWxsQWNjZXNzS2V5IH0gPSB0cmFuc2FjdGlvbnNfMS5hY3Rpb25DcmVhdG9ycztcbmNsYXNzIEFjY291bnQyRkEgZXh0ZW5kcyBhY2NvdW50X211bHRpc2lnXzEuQWNjb3VudE11bHRpc2lnIHtcbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICBBY2NvdW50MkZBIGhhcyBvcHRpb25zIG9iamVjdCB3aGVyZSB5b3UgY2FuIHByb3ZpZGUgY2FsbGJhY2tzIGZvcjpcbiAgICAtIHNlbmRDb2RlOiBob3cgdG8gc2VuZCB0aGUgMkZBIGNvZGUgaW4gY2FzZSB5b3UgZG9uJ3QgdXNlIE5FQVIgQ29udHJhY3QgSGVscGVyXG4gICAgLSBnZXRDb2RlOiBob3cgdG8gZ2V0IGNvZGUgZnJvbSB1c2VyICh1c2UgdGhpcyB0byBwcm92aWRlIGN1c3RvbSBVSS9VWCBmb3IgcHJvbXB0IG9mIDJGQSBjb2RlKVxuICAgIC0gb25SZXN1bHQ6IHRoZSB0eCByZXN1bHQgYWZ0ZXIgaXQncyBiZWVuIGNvbmZpcm1lZCBieSBORUFSIENvbnRyYWN0IEhlbHBlclxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgIHNlbmRDb2RlO1xuICAgIGdldENvZGU7XG4gICAgdmVyaWZ5Q29kZTtcbiAgICBvbkNvbmZpcm1SZXN1bHQ7XG4gICAgaGVscGVyVXJsID0gJ2h0dHBzOi8vaGVscGVyLnRlc3RuZXQubmVhci5vcmcnO1xuICAgIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb24sIGFjY291bnRJZCwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcihjb25uZWN0aW9uLCBhY2NvdW50SWQsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmhlbHBlclVybCA9IG9wdGlvbnMuaGVscGVyVXJsIHx8IHRoaXMuaGVscGVyVXJsO1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBvcHRpb25zLnN0b3JhZ2U7XG4gICAgICAgIHRoaXMuc2VuZENvZGUgPSBvcHRpb25zLnNlbmRDb2RlIHx8IHRoaXMuc2VuZENvZGVEZWZhdWx0O1xuICAgICAgICB0aGlzLmdldENvZGUgPSBvcHRpb25zLmdldENvZGUgfHwgdGhpcy5nZXRDb2RlRGVmYXVsdDtcbiAgICAgICAgdGhpcy52ZXJpZnlDb2RlID0gb3B0aW9ucy52ZXJpZnlDb2RlIHx8IHRoaXMudmVyaWZ5Q29kZURlZmF1bHQ7XG4gICAgICAgIHRoaXMub25Db25maXJtUmVzdWx0ID0gb3B0aW9ucy5vbkNvbmZpcm1SZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ24gYSB0cmFuc2FjdGlvbiB0byBwcmVmb3JtIGEgbGlzdCBvZiBhY3Rpb25zIGFuZCBicm9hZGNhc3QgaXQgdXNpbmcgdGhlIFJQQyBBUEkuXG4gICAgICogQHNlZSB7QGxpbmsgXCJAbmVhci1qcy9wcm92aWRlcnNcIi5qc29uLXJwYy1wcm92aWRlci5Kc29uUnBjUHJvdmlkZXIuc2VuZFRyYW5zYWN0aW9uIHwgSnNvblJwY1Byb3ZpZGVyLnNlbmRUcmFuc2FjdGlvbn1cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgZm9yIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5yZWNlaXZlcklkIFRoZSBORUFSIGFjY291bnQgSUQgb2YgdGhlIHRyYW5zYWN0aW9uIHJlY2VpdmVyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFjdGlvbnMgVGhlIGxpc3Qgb2YgYWN0aW9ucyB0byBiZSBpbmNsdWRlZCBpbiB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RmluYWxFeGVjdXRpb25PdXRjb21lPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGZpbmFsIGV4ZWN1dGlvbiBvdXRjb21lIG9mIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyBzaWduQW5kU2VuZFRyYW5zYWN0aW9uKHsgcmVjZWl2ZXJJZCwgYWN0aW9ucyB9KSB7XG4gICAgICAgIGF3YWl0IHN1cGVyLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb24oeyByZWNlaXZlcklkLCBhY3Rpb25zIH0pO1xuICAgICAgICAvLyBUT0RPOiBTaG91bGQgZm9sbG93aW5nIG92ZXJyaWRlIG9uUmVxdWVzdFJlc3VsdCBpbiBzdXBlcmNsYXNzIGluc3RlYWQgb2YgZG9pbmcgY3VzdG9tIHNpZ25BbmRTZW5kVHJhbnNhY3Rpb24/XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZENvZGUoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5wcm9tcHRBbmRWZXJpZnkoKTtcbiAgICAgICAgaWYgKHRoaXMub25Db25maXJtUmVzdWx0KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLm9uQ29uZmlybVJlc3VsdChyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIGRlZmF1bHQgaGVscGVycyBmb3IgQ0ggZGVwbG95bWVudHMgb2YgbXVsdGlzaWdcbiAgICAvKipcbiAgICAgKiBEZXBsb3kgYSBtdWx0aXNpZyBjb250cmFjdCB3aXRoIDJGQSBhbmQgaGFuZGxlIHRoZSBkZXBsb3ltZW50IHByb2Nlc3MuXG4gICAgICogQHBhcmFtIGNvbnRyYWN0Qnl0ZXMgLSBUaGUgYnl0ZWNvZGUgb2YgdGhlIG11bHRpc2lnIGNvbnRyYWN0LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZpbmFsRXhlY3V0aW9uT3V0Y29tZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBmaW5hbCBleGVjdXRpb24gb3V0Y29tZSBvZiB0aGUgZGVwbG95bWVudC5cbiAgICAgKi9cbiAgICBhc3luYyBkZXBsb3lNdWx0aXNpZyhjb250cmFjdEJ5dGVzKSB7XG4gICAgICAgIGNvbnN0IHsgYWNjb3VudElkIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBzZWVkT3JMZWRnZXJLZXkgPSAoYXdhaXQgdGhpcy5nZXRSZWNvdmVyeU1ldGhvZHMoKSkuZGF0YVxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgLmZpbHRlcigoeyBraW5kLCBwdWJsaWNLZXkgfSkgPT4gKGtpbmQgPT09ICdwaHJhc2UnIHx8IGtpbmQgPT09ICdsZWRnZXInKSAmJiBwdWJsaWNLZXkgIT09IG51bGwpXG4gICAgICAgICAgICAubWFwKChybSkgPT4gcm0ucHVibGljS2V5KTtcbiAgICAgICAgY29uc3QgZmFrMmxhayA9IChhd2FpdCB0aGlzLmdldEFjY2Vzc0tleXMoKSlcbiAgICAgICAgICAgIC5maWx0ZXIoKHsgcHVibGljX2tleSwgYWNjZXNzX2tleTogeyBwZXJtaXNzaW9uIH0gfSkgPT4gcGVybWlzc2lvbiA9PT0gJ0Z1bGxBY2Nlc3MnICYmICFzZWVkT3JMZWRnZXJLZXkuaW5jbHVkZXMocHVibGljX2tleSkpXG4gICAgICAgICAgICAubWFwKChhaykgPT4gYWsucHVibGljX2tleSlcbiAgICAgICAgICAgIC5tYXAodG9QSyk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY29uc3QgY29uZmlybU9ubHlLZXkgPSB0b1BLKChhd2FpdCB0aGlzLnBvc3RTaWduZWRKc29uKCcvMmZhL2dldEFjY2Vzc0tleScsIHsgYWNjb3VudElkIH0pKS5wdWJsaWNLZXkpO1xuICAgICAgICBjb25zdCBuZXdBcmdzID0gQnVmZmVyLmZyb20oSlNPTi5zdHJpbmdpZnkoeyAnbnVtX2NvbmZpcm1hdGlvbnMnOiAyIH0pKTtcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IFtcbiAgICAgICAgICAgIC4uLmZhazJsYWsubWFwKChwaykgPT4gZGVsZXRlS2V5KHBrKSksXG4gICAgICAgICAgICAuLi5mYWsybGFrLm1hcCgocGspID0+IGFkZEtleShwaywgZnVuY3Rpb25DYWxsQWNjZXNzS2V5KGFjY291bnRJZCwgY29uc3RhbnRzXzEuTVVMVElTSUdfQ0hBTkdFX01FVEhPRFMsIG51bGwpKSksXG4gICAgICAgICAgICBhZGRLZXkoY29uZmlybU9ubHlLZXksIGZ1bmN0aW9uQ2FsbEFjY2Vzc0tleShhY2NvdW50SWQsIGNvbnN0YW50c18xLk1VTFRJU0lHX0NPTkZJUk1fTUVUSE9EUywgbnVsbCkpLFxuICAgICAgICAgICAgZGVwbG95Q29udHJhY3QoY29udHJhY3RCeXRlcyksXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IG5ld0Z1bmN0aW9uQ2FsbEFjdGlvbkJhdGNoID0gYWN0aW9ucy5jb25jYXQoZnVuY3Rpb25DYWxsKCduZXcnLCBuZXdBcmdzLCBjb25zdGFudHNfMS5NVUxUSVNJR19HQVMsIGNvbnN0YW50c18xLk1VTFRJU0lHX0RFUE9TSVQpKTtcbiAgICAgICAgdXRpbHNfMS5Mb2dnZXIubG9nKCdkZXBsb3lpbmcgbXVsdGlzaWcgY29udHJhY3QgZm9yJywgYWNjb3VudElkKTtcbiAgICAgICAgY29uc3QgeyBzdGF0ZVN0YXR1czogbXVsdGlzaWdTdGF0ZVN0YXR1cyB9ID0gYXdhaXQgdGhpcy5jaGVja011bHRpc2lnQ29kZUFuZFN0YXRlU3RhdHVzKGNvbnRyYWN0Qnl0ZXMpO1xuICAgICAgICBzd2l0Y2ggKG11bHRpc2lnU3RhdGVTdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMi5NdWx0aXNpZ1N0YXRlU3RhdHVzLlNUQVRFX05PVF9JTklUSUFMSVpFRDpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgc3VwZXIuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbldpdGhBY2NvdW50KGFjY291bnRJZCwgbmV3RnVuY3Rpb25DYWxsQWN0aW9uQmF0Y2gpO1xuICAgICAgICAgICAgY2FzZSB0eXBlc18yLk11bHRpc2lnU3RhdGVTdGF0dXMuVkFMSURfU1RBVEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHN1cGVyLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb25XaXRoQWNjb3VudChhY2NvdW50SWQsIGFjdGlvbnMpO1xuICAgICAgICAgICAgY2FzZSB0eXBlc18yLk11bHRpc2lnU3RhdGVTdGF0dXMuSU5WQUxJRF9TVEFURTpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgdHlwZXNfMS5UeXBlZEVycm9yKGBDYW4gbm90IGRlcGxveSBhIGNvbnRyYWN0IHRvIGFjY291bnQgJHt0aGlzLmFjY291bnRJZH0gb24gbmV0d29yayAke3RoaXMuY29ubmVjdGlvbi5uZXR3b3JrSWR9LCB0aGUgYWNjb3VudCBoYXMgZXhpc3Rpbmcgc3RhdGUuYCwgJ0NvbnRyYWN0SGFzRXhpc3RpbmdTdGF0ZScpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgdHlwZXNfMS5UeXBlZEVycm9yKGBDYW4gbm90IGRlcGxveSBhIGNvbnRyYWN0IHRvIGFjY291bnQgJHt0aGlzLmFjY291bnRJZH0gb24gbmV0d29yayAke3RoaXMuY29ubmVjdGlvbi5uZXR3b3JrSWR9LCB0aGUgYWNjb3VudCBzdGF0ZSBjb3VsZCBub3QgYmUgdmVyaWZpZWQuYCwgJ0NvbnRyYWN0U3RhdGVVbmtub3duJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzYWJsZSAyRkEgd2l0aCB0aGUgb3B0aW9uIHRvIGNsZWFuIHVwIGNvbnRyYWN0IHN0YXRlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgZm9yIGRpc2FibGluZyAyRkEuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuY29udHJhY3RCeXRlcyBUaGUgYnl0ZWNvZGUgb2YgdGhlIGNvbnRyYWN0IHRvIGRlcGxveS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jbGVhbnVwQ29udHJhY3RCeXRlcyBUaGUgYnl0ZWNvZGUgb2YgdGhlIGNsZWFudXAgY29udHJhY3QgKG9wdGlvbmFsKS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGaW5hbEV4ZWN1dGlvbk91dGNvbWU+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgZmluYWwgZXhlY3V0aW9uIG91dGNvbWUgb2YgdGhlIG9wZXJhdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyBkaXNhYmxlV2l0aEZBSyh7IGNvbnRyYWN0Qnl0ZXMsIGNsZWFudXBDb250cmFjdEJ5dGVzIH0pIHtcbiAgICAgICAgbGV0IGNsZWFudXBBY3Rpb25zID0gW107XG4gICAgICAgIGlmIChjbGVhbnVwQ29udHJhY3RCeXRlcykge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5kZWxldGVBbGxSZXF1ZXN0cygpLmNhdGNoKGUgPT4gZSk7XG4gICAgICAgICAgICBjbGVhbnVwQWN0aW9ucyA9IGF3YWl0IHRoaXMuZ2V0MmZhRGlzYWJsZUNsZWFudXBBY3Rpb25zKGNsZWFudXBDb250cmFjdEJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXlDb252ZXJzaW9uQWN0aW9ucyA9IGF3YWl0IHRoaXMuZ2V0MmZhRGlzYWJsZUtleUNvbnZlcnNpb25BY3Rpb25zKCk7XG4gICAgICAgIGNvbnN0IGFjdGlvbnMgPSBbXG4gICAgICAgICAgICAuLi5jbGVhbnVwQWN0aW9ucyxcbiAgICAgICAgICAgIC4uLmtleUNvbnZlcnNpb25BY3Rpb25zLFxuICAgICAgICAgICAgZGVwbG95Q29udHJhY3QoY29udHJhY3RCeXRlcylcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgYWNjZXNzS2V5SW5mbyA9IGF3YWl0IHRoaXMuZmluZEFjY2Vzc0tleSh0aGlzLmFjY291bnRJZCwgYWN0aW9ucyk7XG4gICAgICAgIGlmIChhY2Nlc3NLZXlJbmZvICYmIGFjY2Vzc0tleUluZm8uYWNjZXNzS2V5ICYmIGFjY2Vzc0tleUluZm8uYWNjZXNzS2V5LnBlcm1pc3Npb24gIT09ICdGdWxsQWNjZXNzJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHR5cGVzXzEuVHlwZWRFcnJvcignTm8gZnVsbCBhY2Nlc3Mga2V5IGZvdW5kIGluIGtleXN0b3JlLiBVbmFibGUgdG8gYnlwYXNzIG11bHRpc2lnJywgJ05vRkFLRm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zaWduQW5kU2VuZFRyYW5zYWN0aW9uV2l0aEFjY291bnQodGhpcy5hY2NvdW50SWQsIGFjdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgY2xlYW51cCBhY3Rpb25zIGZvciBkaXNhYmxpbmcgMkZBLlxuICAgICAqIEBwYXJhbSBjbGVhbnVwQ29udHJhY3RCeXRlcyAtIFRoZSBieXRlY29kZSBvZiB0aGUgY2xlYW51cCBjb250cmFjdC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBY3Rpb25bXT59IC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gYXJyYXkgb2YgY2xlYW51cCBhY3Rpb25zLlxuICAgICAqL1xuICAgIGFzeW5jIGdldDJmYURpc2FibGVDbGVhbnVwQWN0aW9ucyhjbGVhbnVwQ29udHJhY3RCeXRlcykge1xuICAgICAgICBjb25zdCBjdXJyZW50QWNjb3VudFN0YXRlID0gYXdhaXQgdGhpcy52aWV3U3RhdGUoJycpLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNhdXNlID0gZXJyb3IuY2F1c2UgJiYgZXJyb3IuY2F1c2UubmFtZTtcbiAgICAgICAgICAgIGlmIChjYXVzZSA9PSAnTk9fQ09OVFJBQ1RfQ09ERScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBjYXVzZSA9PSAnVE9PX0xBUkdFX0NPTlRSQUNUX1NUQVRFJ1xuICAgICAgICAgICAgICAgID8gbmV3IHR5cGVzXzEuVHlwZWRFcnJvcihgQ2FuIG5vdCBkZXBsb3kgYSBjb250cmFjdCB0byBhY2NvdW50ICR7dGhpcy5hY2NvdW50SWR9IG9uIG5ldHdvcmsgJHt0aGlzLmNvbm5lY3Rpb24ubmV0d29ya0lkfSwgdGhlIGFjY291bnQgaGFzIGV4aXN0aW5nIHN0YXRlLmAsICdDb250cmFjdEhhc0V4aXN0aW5nU3RhdGUnKVxuICAgICAgICAgICAgICAgIDogZXJyb3I7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjdXJyZW50QWNjb3VudFN0YXRlS2V5cyA9IGN1cnJlbnRBY2NvdW50U3RhdGUubWFwKCh7IGtleSB9KSA9PiBrZXkudG9TdHJpbmcoJ2Jhc2U2NCcpKTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRBY2NvdW50U3RhdGUubGVuZ3RoID8gW1xuICAgICAgICAgICAgZGVwbG95Q29udHJhY3QoY2xlYW51cENvbnRyYWN0Qnl0ZXMpLFxuICAgICAgICAgICAgZnVuY3Rpb25DYWxsKCdjbGVhbicsIHsga2V5czogY3VycmVudEFjY291bnRTdGF0ZUtleXMgfSwgY29uc3RhbnRzXzEuTVVMVElTSUdfR0FTLCAwbilcbiAgICAgICAgXSA6IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMga2V5IGNvbnZlcnNpb24gYWN0aW9ucyBmb3IgZGlzYWJsaW5nIDJGQS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBY3Rpb25bXT59IC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gYXJyYXkgb2Yga2V5IGNvbnZlcnNpb24gYWN0aW9ucy5cbiAgICAgKi9cbiAgICBhc3luYyBnZXQyZmFEaXNhYmxlS2V5Q29udmVyc2lvbkFjdGlvbnMoKSB7XG4gICAgICAgIGNvbnN0IHsgYWNjb3VudElkIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBhY2Nlc3NLZXlzID0gYXdhaXQgdGhpcy5nZXRBY2Nlc3NLZXlzKCk7XG4gICAgICAgIGNvbnN0IGxhazJmYWsgPSBhY2Nlc3NLZXlzXG4gICAgICAgICAgICAuZmlsdGVyKCh7IGFjY2Vzc19rZXkgfSkgPT4gYWNjZXNzX2tleS5wZXJtaXNzaW9uICE9PSAnRnVsbEFjY2VzcycpXG4gICAgICAgICAgICAuZmlsdGVyKCh7IGFjY2Vzc19rZXkgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGVybSA9IGFjY2Vzc19rZXkucGVybWlzc2lvbi5GdW5jdGlvbkNhbGw7XG4gICAgICAgICAgICByZXR1cm4gcGVybS5yZWNlaXZlcl9pZCA9PT0gYWNjb3VudElkICYmXG4gICAgICAgICAgICAgICAgcGVybS5tZXRob2RfbmFtZXMubGVuZ3RoID09PSA0ICYmXG4gICAgICAgICAgICAgICAgcGVybS5tZXRob2RfbmFtZXMuaW5jbHVkZXMoJ2FkZF9yZXF1ZXN0X2FuZF9jb25maXJtJyk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGNvbnN0IGNvbmZpcm1Pbmx5S2V5ID0gY3J5cHRvXzEuUHVibGljS2V5LmZyb20oKGF3YWl0IHRoaXMucG9zdFNpZ25lZEpzb24oJy8yZmEvZ2V0QWNjZXNzS2V5JywgeyBhY2NvdW50SWQgfSkpLnB1YmxpY0tleSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBkZWxldGVLZXkoY29uZmlybU9ubHlLZXkpLFxuICAgICAgICAgICAgLi4ubGFrMmZhay5tYXAoKHsgcHVibGljX2tleSB9KSA9PiBkZWxldGVLZXkoY3J5cHRvXzEuUHVibGljS2V5LmZyb20ocHVibGljX2tleSkpKSxcbiAgICAgICAgICAgIC4uLmxhazJmYWsubWFwKCh7IHB1YmxpY19rZXkgfSkgPT4gYWRkS2V5KGNyeXB0b18xLlB1YmxpY0tleS5mcm9tKHB1YmxpY19rZXkpLCBmdWxsQWNjZXNzS2V5KCkpKVxuICAgICAgICBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBjb252ZXJ0cyBMQUtzIGJhY2sgdG8gRkFLcywgY2xlYXJzIHN0YXRlIGFuZCBkZXBsb3lzIGFuICdlbXB0eScgY29udHJhY3QgKGNvbnRyYWN0Qnl0ZXMgcGFyYW0pXG4gICAgICogQHBhcmFtIFtjb250cmFjdEJ5dGVzXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmVhci9uZWFyLXdhbGxldC9ibG9iL21hc3Rlci9wYWNrYWdlcy9mcm9udGVuZC9zcmMvd2FzbS9tYWluLndhc20/cmF3PXRydWV9XG4gICAgICogQHBhcmFtIFtjbGVhbnVwQ29udHJhY3RCeXRlc117QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL25lYXIvY29yZS1jb250cmFjdHMvYmxvYi9tYXN0ZXIvc3RhdGUtbWFuaXB1bGF0aW9uL3Jlcy9zdGF0ZV9jbGVhbnVwLndhc20/cmF3PXRydWV9XG4gICAgICogQHJldHVybnMge1Byb21pc2U8RmluYWxFeGVjdXRpb25PdXRjb21lPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGZpbmFsIGV4ZWN1dGlvbiBvdXRjb21lIG9mIHRoZSBvcGVyYXRpb24uXG4gICAgICovXG4gICAgYXN5bmMgZGlzYWJsZShjb250cmFjdEJ5dGVzLCBjbGVhbnVwQ29udHJhY3RCeXRlcykge1xuICAgICAgICBjb25zdCB7IHN0YXRlU3RhdHVzIH0gPSBhd2FpdCB0aGlzLmNoZWNrTXVsdGlzaWdDb2RlQW5kU3RhdGVTdGF0dXMoKTtcbiAgICAgICAgaWYgKHN0YXRlU3RhdHVzICE9PSB0eXBlc18yLk11bHRpc2lnU3RhdGVTdGF0dXMuVkFMSURfU1RBVEUgJiYgc3RhdGVTdGF0dXMgIT09IHR5cGVzXzIuTXVsdGlzaWdTdGF0ZVN0YXR1cy5TVEFURV9OT1RfSU5JVElBTElaRUQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyB0eXBlc18xLlR5cGVkRXJyb3IoYENhbiBub3QgZGVwbG95IGEgY29udHJhY3QgdG8gYWNjb3VudCAke3RoaXMuYWNjb3VudElkfSBvbiBuZXR3b3JrICR7dGhpcy5jb25uZWN0aW9uLm5ldHdvcmtJZH0sIHRoZSBhY2NvdW50IHN0YXRlIGNvdWxkIG5vdCBiZSB2ZXJpZmllZC5gLCAnQ29udHJhY3RTdGF0ZVVua25vd24nKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVsZXRlQWxsUmVxdWVzdHNFcnJvcjtcbiAgICAgICAgYXdhaXQgdGhpcy5kZWxldGVBbGxSZXF1ZXN0cygpLmNhdGNoKGUgPT4gZGVsZXRlQWxsUmVxdWVzdHNFcnJvciA9IGUpO1xuICAgICAgICBjb25zdCBjbGVhbnVwQWN0aW9ucyA9IGF3YWl0IHRoaXMuZ2V0MmZhRGlzYWJsZUNsZWFudXBBY3Rpb25zKGNsZWFudXBDb250cmFjdEJ5dGVzKS5jYXRjaChlID0+IHtcbiAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdDb250cmFjdEhhc0V4aXN0aW5nU3RhdGUnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGVsZXRlQWxsUmVxdWVzdHNFcnJvciB8fCBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGFjdGlvbnMgPSBbXG4gICAgICAgICAgICAuLi5jbGVhbnVwQWN0aW9ucyxcbiAgICAgICAgICAgIC4uLihhd2FpdCB0aGlzLmdldDJmYURpc2FibGVLZXlDb252ZXJzaW9uQWN0aW9ucygpKSxcbiAgICAgICAgICAgIGRlcGxveUNvbnRyYWN0KGNvbnRyYWN0Qnl0ZXMpLFxuICAgICAgICBdO1xuICAgICAgICB1dGlsc18xLkxvZ2dlci5sb2coJ2Rpc2FibGluZyAyZmEgZm9yJywgdGhpcy5hY2NvdW50SWQpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zaWduQW5kU2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgIHJlY2VpdmVySWQ6IHRoaXMuYWNjb3VudElkLFxuICAgICAgICAgICAgYWN0aW9uc1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBmb3Igc2VuZGluZyB0aGUgMkZBIGNvZGUuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgcmVxdWVzdCBJRC5cbiAgICAgKi9cbiAgICBhc3luYyBzZW5kQ29kZURlZmF1bHQoKSB7XG4gICAgICAgIGNvbnN0IHsgYWNjb3VudElkIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHJlcXVlc3RJZCB9ID0gdGhpcy5nZXRSZXF1ZXN0KCk7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IGF3YWl0IHRoaXMuZ2V0MmZhTWV0aG9kKCk7XG4gICAgICAgIGF3YWl0IHRoaXMucG9zdFNpZ25lZEpzb24oJy8yZmEvc2VuZCcsIHtcbiAgICAgICAgICAgIGFjY291bnRJZCxcbiAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXF1ZXN0SWQ7XG4gICAgfVxuICAgIGFzeW5jIGdldENvZGVEZWZhdWx0KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIGlzIG5vIGdldENvZGUgY2FsbGJhY2sgcHJvdmlkZWQuIFBsZWFzZSBwcm92aWRlIHlvdXIgb3duIGluIEFjY291bnRNdWx0aXNpZyBjb25zdHJ1Y3RvciBvcHRpb25zLiBJdCBoYXMgYSBwYXJhbWV0ZXIgbWV0aG9kIHdoZXJlIG1ldGhvZC5raW5kIGlzIFwiZW1haWxcIiBvciBcInBob25lXCIuJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb21wdHMgdGhlIHVzZXIgdG8gZW50ZXIgYW5kIHZlcmlmeSB0aGUgMkZBIGNvZGUuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgdmVyaWZpY2F0aW9uIHJlc3VsdC5cbiAgICAgKi9cbiAgICBhc3luYyBwcm9tcHRBbmRWZXJpZnkoKSB7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IGF3YWl0IHRoaXMuZ2V0MmZhTWV0aG9kKCk7XG4gICAgICAgIGNvbnN0IHNlY3VyaXR5Q29kZSA9IGF3YWl0IHRoaXMuZ2V0Q29kZShtZXRob2QpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy52ZXJpZnlDb2RlKHNlY3VyaXR5Q29kZSk7XG4gICAgICAgICAgICAvLyBUT0RPOiBQYXJzZSBlcnJvciBmcm9tIHJlc3VsdCBmb3IgcmVhbCAobGlrZSBpbiBub3JtYWwgYWNjb3VudC5zaWduQW5kU2VuZFRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdXRpbHNfMS5Mb2dnZXIud2FybignRXJyb3IgdmFsaWRhdGluZyBzZWN1cml0eSBjb2RlOicsIGUpO1xuICAgICAgICAgICAgaWYgKGUudG9TdHJpbmcoKS5pbmNsdWRlcygnaW52YWxpZCAyZmEgY29kZSBwcm92aWRlZCcpIHx8IGUudG9TdHJpbmcoKS5pbmNsdWRlcygnMmZhIGNvZGUgbm90IHZhbGlkJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcm9tcHRBbmRWZXJpZnkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVmVyaWZ5IHRoZSAyRkEgY29kZSB1c2luZyB0aGUgZGVmYXVsdCBtZXRob2QuXG4gICAgICogQHBhcmFtIHNlY3VyaXR5Q29kZSAtIFRoZSBzZWN1cml0eSBjb2RlIHRvIHZlcmlmeS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgdmVyaWZpY2F0aW9uIHJlc3VsdC5cbiAgICAgKi9cbiAgICBhc3luYyB2ZXJpZnlDb2RlRGVmYXVsdChzZWN1cml0eUNvZGUpIHtcbiAgICAgICAgY29uc3QgeyBhY2NvdW50SWQgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmdldFJlcXVlc3QoKTtcbiAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHJlcXVlc3QgcGVuZGluZycpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgcmVxdWVzdElkIH0gPSByZXF1ZXN0O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wb3N0U2lnbmVkSnNvbignLzJmYS92ZXJpZnknLCB7XG4gICAgICAgICAgICBhY2NvdW50SWQsXG4gICAgICAgICAgICBzZWN1cml0eUNvZGUsXG4gICAgICAgICAgICByZXF1ZXN0SWRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyByZWNvdmVyeSBtZXRob2RzIGZvciB0aGUgYWNjb3VudC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx7IGFjY291bnRJZDogc3RyaW5nLCBkYXRhOiBhbnkgfT59IC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gcmVjb3ZlcnkgbWV0aG9kcyBkYXRhLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFJlY292ZXJ5TWV0aG9kcygpIHtcbiAgICAgICAgY29uc3QgeyBhY2NvdW50SWQgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhY2NvdW50SWQsXG4gICAgICAgICAgICBkYXRhOiBhd2FpdCB0aGlzLnBvc3RTaWduZWRKc29uKCcvYWNjb3VudC9yZWNvdmVyeU1ldGhvZHMnLCB7IGFjY291bnRJZCB9KVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSAyRkEgbWV0aG9kIChraW5kIGFuZCBkZXRhaWwpLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHsga2luZDogc3RyaW5nLCBkZXRhaWw6IHN0cmluZyB9Pn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIDJGQSBtZXRob2QuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0MmZhTWV0aG9kKCkge1xuICAgICAgICBsZXQgeyBkYXRhIH0gPSBhd2FpdCB0aGlzLmdldFJlY292ZXJ5TWV0aG9kcygpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBkYXRhID0gZGF0YS5maW5kKChtKSA9PiBtLmtpbmQuaW5kZXhPZignMmZhLScpID09PSAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGEpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjb25zdCB7IGtpbmQsIGRldGFpbCB9ID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIHsga2luZCwgZGV0YWlsIH07XG4gICAgfVxuICAgIC8qKlxuICAgICogR2VuZXJhdGVzIGEgc2lnbmF0dXJlIGZvciB0aGUgbGF0ZXN0IGZpbmFsaXplZCBibG9jay5cbiAgICAqIEByZXR1cm5zIHtQcm9taXNlPHsgYmxvY2tOdW1iZXI6IHN0cmluZywgYmxvY2tOdW1iZXJTaWduYXR1cmU6IHN0cmluZyB9Pn0gLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgc2lnbmF0dXJlIGluZm9ybWF0aW9uLlxuICAgICovXG4gICAgYXN5bmMgc2lnbmF0dXJlRm9yKCkge1xuICAgICAgICBjb25zdCB7IGFjY291bnRJZCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb24ucHJvdmlkZXIuYmxvY2soeyBmaW5hbGl0eTogJ2ZpbmFsJyB9KTtcbiAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSBibG9jay5oZWFkZXIuaGVpZ2h0LnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IHNpZ25lZCA9IGF3YWl0IHRoaXMuY29ubmVjdGlvbi5zaWduZXIuc2lnbk1lc3NhZ2UoQnVmZmVyLmZyb20oYmxvY2tOdW1iZXIpLCBhY2NvdW50SWQsIHRoaXMuY29ubmVjdGlvbi5uZXR3b3JrSWQpO1xuICAgICAgICBjb25zdCBibG9ja051bWJlclNpZ25hdHVyZSA9IEJ1ZmZlci5mcm9tKHNpZ25lZC5zaWduYXR1cmUpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgICAgcmV0dXJuIHsgYmxvY2tOdW1iZXIsIGJsb2NrTnVtYmVyU2lnbmF0dXJlIH07XG4gICAgfVxuICAgIC8qKlxuICAgICogU2VuZHMgYSBzaWduZWQgSlNPTiByZXF1ZXN0IHRvIGEgc3BlY2lmaWVkIHBhdGguXG4gICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIGZvciB0aGUgcmVxdWVzdC5cbiAgICAqIEBwYXJhbSBib2R5IC0gVGhlIHJlcXVlc3QgYm9keS5cbiAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHJlc3BvbnNlIGZyb20gdGhlIGhlbHBlci5cbiAgICAqL1xuICAgIGFzeW5jIHBvc3RTaWduZWRKc29uKHBhdGgsIGJvZHkpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0ICgwLCBpc29tb3JwaGljX3VuZmV0Y2hfMS5kZWZhdWx0KSh0aGlzLmhlbHBlclVybCArIHBhdGgsIHtcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAuLi5ib2R5LFxuICAgICAgICAgICAgICAgIC4uLihhd2FpdCB0aGlzLnNpZ25hdHVyZUZvcigpKSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQWNjb3VudDJGQSA9IEFjY291bnQyRkE7XG4vLyBoZWxwZXJzXG5jb25zdCB0b1BLID0gKHBrKSA9PiBjcnlwdG9fMS5QdWJsaWNLZXkuZnJvbShwayk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/account_2fa.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/account_creator.cjs":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/account_creator.cjs ***!
  \********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UrlAccountCreator = exports.LocalAccountCreator = exports.AccountCreator = void 0;\nconst isomorphic_unfetch_1 = __importDefault(__webpack_require__(/*! isomorphic-unfetch */ \"(ssr)/./node_modules/.pnpm/isomorphic-unfetch@3.1.0/node_modules/isomorphic-unfetch/index.js\"));\n/**\n * Account creator provides an interface for implementations to actually create accounts\n */\nclass AccountCreator {\n}\nexports.AccountCreator = AccountCreator;\nclass LocalAccountCreator extends AccountCreator {\n    masterAccount;\n    initialBalance;\n    constructor(masterAccount, initialBalance) {\n        super();\n        this.masterAccount = masterAccount;\n        this.initialBalance = initialBalance;\n    }\n    /**\n     * Creates an account using a masterAccount, meaning the new account is created from an existing account\n     * @param newAccountId The name of the NEAR account to be created\n     * @param publicKey The public key from the masterAccount used to create this account\n     * @returns {Promise<void>}\n     */\n    async createAccount(newAccountId, publicKey) {\n        await this.masterAccount.createAccount(newAccountId, publicKey, this.initialBalance);\n    }\n}\nexports.LocalAccountCreator = LocalAccountCreator;\nclass UrlAccountCreator extends AccountCreator {\n    connection;\n    helperUrl;\n    constructor(connection, helperUrl) {\n        super();\n        this.connection = connection;\n        this.helperUrl = helperUrl;\n    }\n    /**\n     * Creates an account using a helperUrl\n     * This is [hosted here](https://helper.nearprotocol.com) or set up locally with the [near-contract-helper](https://github.com/nearprotocol/near-contract-helper) repository\n     * @param newAccountId The name of the NEAR account to be created\n     * @param publicKey The public key from the masterAccount used to create this account\n     * @returns {Promise<void>}\n     */\n    async createAccount(newAccountId, publicKey) {\n        await (0, isomorphic_unfetch_1.default)(`${this.helperUrl}/account`, {\n            body: JSON.stringify({ newAccountId, newAccountPublicKey: publicKey.toString() }),\n            method: 'POST',\n        });\n    }\n}\nexports.UrlAccountCreator = UrlAccountCreator;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMS4zLjEvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9jb21tb25qcy9hY2NvdW50X2NyZWF0b3IuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCLEdBQUcsMkJBQTJCLEdBQUcsc0JBQXNCO0FBQ2hGLDZDQUE2QyxtQkFBTyxDQUFDLHdIQUFvQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxtREFBbUQsZUFBZTtBQUNsRSxtQ0FBbUMseURBQXlEO0FBQzVGO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oYWNrYXRob24tbmVhci1yZWRhY3RlZC8uL25vZGVfbW9kdWxlcy8ucG5wbS9AbmVhci1qcythY2NvdW50c0AxLjMuMS9ub2RlX21vZHVsZXMvQG5lYXItanMvYWNjb3VudHMvbGliL2NvbW1vbmpzL2FjY291bnRfY3JlYXRvci5janM/NDBjMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVXJsQWNjb3VudENyZWF0b3IgPSBleHBvcnRzLkxvY2FsQWNjb3VudENyZWF0b3IgPSBleHBvcnRzLkFjY291bnRDcmVhdG9yID0gdm9pZCAwO1xuY29uc3QgaXNvbW9ycGhpY191bmZldGNoXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImlzb21vcnBoaWMtdW5mZXRjaFwiKSk7XG4vKipcbiAqIEFjY291bnQgY3JlYXRvciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGltcGxlbWVudGF0aW9ucyB0byBhY3R1YWxseSBjcmVhdGUgYWNjb3VudHNcbiAqL1xuY2xhc3MgQWNjb3VudENyZWF0b3Ige1xufVxuZXhwb3J0cy5BY2NvdW50Q3JlYXRvciA9IEFjY291bnRDcmVhdG9yO1xuY2xhc3MgTG9jYWxBY2NvdW50Q3JlYXRvciBleHRlbmRzIEFjY291bnRDcmVhdG9yIHtcbiAgICBtYXN0ZXJBY2NvdW50O1xuICAgIGluaXRpYWxCYWxhbmNlO1xuICAgIGNvbnN0cnVjdG9yKG1hc3RlckFjY291bnQsIGluaXRpYWxCYWxhbmNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubWFzdGVyQWNjb3VudCA9IG1hc3RlckFjY291bnQ7XG4gICAgICAgIHRoaXMuaW5pdGlhbEJhbGFuY2UgPSBpbml0aWFsQmFsYW5jZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhY2NvdW50IHVzaW5nIGEgbWFzdGVyQWNjb3VudCwgbWVhbmluZyB0aGUgbmV3IGFjY291bnQgaXMgY3JlYXRlZCBmcm9tIGFuIGV4aXN0aW5nIGFjY291bnRcbiAgICAgKiBAcGFyYW0gbmV3QWNjb3VudElkIFRoZSBuYW1lIG9mIHRoZSBORUFSIGFjY291bnQgdG8gYmUgY3JlYXRlZFxuICAgICAqIEBwYXJhbSBwdWJsaWNLZXkgVGhlIHB1YmxpYyBrZXkgZnJvbSB0aGUgbWFzdGVyQWNjb3VudCB1c2VkIHRvIGNyZWF0ZSB0aGlzIGFjY291bnRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVBY2NvdW50KG5ld0FjY291bnRJZCwgcHVibGljS2V5KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubWFzdGVyQWNjb3VudC5jcmVhdGVBY2NvdW50KG5ld0FjY291bnRJZCwgcHVibGljS2V5LCB0aGlzLmluaXRpYWxCYWxhbmNlKTtcbiAgICB9XG59XG5leHBvcnRzLkxvY2FsQWNjb3VudENyZWF0b3IgPSBMb2NhbEFjY291bnRDcmVhdG9yO1xuY2xhc3MgVXJsQWNjb3VudENyZWF0b3IgZXh0ZW5kcyBBY2NvdW50Q3JlYXRvciB7XG4gICAgY29ubmVjdGlvbjtcbiAgICBoZWxwZXJVcmw7XG4gICAgY29uc3RydWN0b3IoY29ubmVjdGlvbiwgaGVscGVyVXJsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgICAgIHRoaXMuaGVscGVyVXJsID0gaGVscGVyVXJsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFjY291bnQgdXNpbmcgYSBoZWxwZXJVcmxcbiAgICAgKiBUaGlzIGlzIFtob3N0ZWQgaGVyZV0oaHR0cHM6Ly9oZWxwZXIubmVhcnByb3RvY29sLmNvbSkgb3Igc2V0IHVwIGxvY2FsbHkgd2l0aCB0aGUgW25lYXItY29udHJhY3QtaGVscGVyXShodHRwczovL2dpdGh1Yi5jb20vbmVhcnByb3RvY29sL25lYXItY29udHJhY3QtaGVscGVyKSByZXBvc2l0b3J5XG4gICAgICogQHBhcmFtIG5ld0FjY291bnRJZCBUaGUgbmFtZSBvZiB0aGUgTkVBUiBhY2NvdW50IHRvIGJlIGNyZWF0ZWRcbiAgICAgKiBAcGFyYW0gcHVibGljS2V5IFRoZSBwdWJsaWMga2V5IGZyb20gdGhlIG1hc3RlckFjY291bnQgdXNlZCB0byBjcmVhdGUgdGhpcyBhY2NvdW50XG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlQWNjb3VudChuZXdBY2NvdW50SWQsIHB1YmxpY0tleSkge1xuICAgICAgICBhd2FpdCAoMCwgaXNvbW9ycGhpY191bmZldGNoXzEuZGVmYXVsdCkoYCR7dGhpcy5oZWxwZXJVcmx9L2FjY291bnRgLCB7XG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IG5ld0FjY291bnRJZCwgbmV3QWNjb3VudFB1YmxpY0tleTogcHVibGljS2V5LnRvU3RyaW5nKCkgfSksXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5VcmxBY2NvdW50Q3JlYXRvciA9IFVybEFjY291bnRDcmVhdG9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/account_creator.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/account_multisig.cjs":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/account_multisig.cjs ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AccountMultisig = void 0;\nconst transactions_1 = __webpack_require__(/*! @near-js/transactions */ \"(ssr)/./node_modules/.pnpm/@near-js+transactions@1.3.1/node_modules/@near-js/transactions/lib/commonjs/index.cjs\");\nconst utils_1 = __webpack_require__(/*! @near-js/utils */ \"(ssr)/./node_modules/.pnpm/@near-js+utils@1.0.1/node_modules/@near-js/utils/lib/commonjs/index.cjs\");\nconst account_1 = __webpack_require__(/*! ./account.cjs */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/account.cjs\");\nconst constants_1 = __webpack_require__(/*! ./constants.cjs */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/constants.cjs\");\nconst types_1 = __webpack_require__(/*! ./types.cjs */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/types.cjs\");\nconst { deployContract, functionCall } = transactions_1.actionCreators;\nvar MultisigCodeStatus;\n(function (MultisigCodeStatus) {\n    MultisigCodeStatus[MultisigCodeStatus[\"INVALID_CODE\"] = 0] = \"INVALID_CODE\";\n    MultisigCodeStatus[MultisigCodeStatus[\"VALID_CODE\"] = 1] = \"VALID_CODE\";\n    MultisigCodeStatus[MultisigCodeStatus[\"UNKNOWN_CODE\"] = 2] = \"UNKNOWN_CODE\";\n})(MultisigCodeStatus || (MultisigCodeStatus = {}));\n// in memory request cache for node w/o localStorage\nconst storageFallback = {\n    [constants_1.MULTISIG_STORAGE_KEY]: null\n};\nclass AccountMultisig extends account_1.Account {\n    storage;\n    onAddRequestResult;\n    /**\n     * Constructs an instance of the `AccountMultisig` class.\n     * @param connection The NEAR connection object.\n     * @param accountId The NEAR account ID.\n     * @param options Additional options for the multisig account.\n     * @param options.storage Storage to store data related to multisig operations.\n     * @param options.onAddRequestResult Callback function to handle the result of adding a request.\n     */\n    constructor(connection, accountId, options) {\n        super(connection, accountId);\n        this.storage = options.storage;\n        this.onAddRequestResult = options.onAddRequestResult;\n    }\n    /**\n     * Sign and send a transaction with the multisig account as the sender.\n     * @param receiverId - The NEAR account ID of the transaction receiver.\n     * @param actions - The list of actions to be included in the transaction.\n     * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the transaction.\n     */\n    async signAndSendTransactionWithAccount(receiverId, actions) {\n        return super.signAndSendTransaction({ receiverId, actions });\n    }\n    /**\n     * Sign and send a multisig transaction to add a request and confirm it.\n     * @param options Options for the multisig transaction.\n     * @param options.receiverId The NEAR account ID of the transaction receiver.\n     * @param options.actions The list of actions to be included in the transaction.\n     * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the transaction.\n     */\n    async signAndSendTransaction({ receiverId, actions }) {\n        const { accountId } = this;\n        const args = Buffer.from(JSON.stringify({\n            request: {\n                receiver_id: receiverId,\n                actions: convertActions(actions, accountId, receiverId)\n            }\n        }));\n        let result;\n        try {\n            result = await super.signAndSendTransaction({\n                receiverId: accountId,\n                actions: [\n                    functionCall('add_request_and_confirm', args, constants_1.MULTISIG_GAS, constants_1.MULTISIG_DEPOSIT)\n                ]\n            });\n        }\n        catch (e) {\n            if (e.toString().includes('Account has too many active requests. Confirm or delete some')) {\n                await this.deleteUnconfirmedRequests();\n                return await this.signAndSendTransaction({ receiverId, actions });\n            }\n            throw e;\n        }\n        // TODO: Are following even needed? Seems like it throws on error already\n        if (!result.status) {\n            throw new Error('Request failed');\n        }\n        const status = { ...result.status };\n        if (!status.SuccessValue || typeof status.SuccessValue !== 'string') {\n            throw new Error('Request failed');\n        }\n        this.setRequest({\n            accountId,\n            actions,\n            requestId: parseInt(Buffer.from(status.SuccessValue, 'base64').toString('ascii'), 10)\n        });\n        if (this.onAddRequestResult) {\n            await this.onAddRequestResult(result);\n        }\n        // NOTE there is no await on purpose to avoid blocking for 2fa\n        this.deleteUnconfirmedRequests();\n        return result;\n    }\n    /**\n     * This method submits a canary transaction that is expected to always fail in order to determine whether the contract currently has valid multisig state\n     * and whether it is initialized. The canary transaction attempts to delete a request at index u32_max and will go through if a request exists at that index.\n     * a u32_max + 1 and -1 value cannot be used for the canary due to expected u32 error thrown before deserialization attempt.\n     * @param contractBytes The bytecode of the multisig contract.\n     * @returns {Promise<{ codeStatus: MultisigCodeStatus; stateStatus: MultisigStateStatus }>} A promise that resolves to the status of the code and state.\n     */\n    async checkMultisigCodeAndStateStatus(contractBytes) {\n        const u32_max = 4_294_967_295;\n        const validCodeStatusIfNoDeploy = contractBytes ? MultisigCodeStatus.UNKNOWN_CODE : MultisigCodeStatus.VALID_CODE;\n        try {\n            if (contractBytes) {\n                await super.signAndSendTransaction({\n                    receiverId: this.accountId, actions: [\n                        deployContract(contractBytes),\n                        functionCall('delete_request', { request_id: u32_max }, constants_1.MULTISIG_GAS, constants_1.MULTISIG_DEPOSIT)\n                    ]\n                });\n            }\n            else {\n                await this.deleteRequest(u32_max);\n            }\n            return { codeStatus: MultisigCodeStatus.VALID_CODE, stateStatus: types_1.MultisigStateStatus.VALID_STATE };\n        }\n        catch (e) {\n            if (new RegExp(types_1.MultisigDeleteRequestRejectionError.CANNOT_DESERIALIZE_STATE).test(e && e.kind && e.kind.ExecutionError)) {\n                return { codeStatus: validCodeStatusIfNoDeploy, stateStatus: types_1.MultisigStateStatus.INVALID_STATE };\n            }\n            else if (new RegExp(types_1.MultisigDeleteRequestRejectionError.MULTISIG_NOT_INITIALIZED).test(e && e.kind && e.kind.ExecutionError)) {\n                return { codeStatus: validCodeStatusIfNoDeploy, stateStatus: types_1.MultisigStateStatus.STATE_NOT_INITIALIZED };\n            }\n            else if (new RegExp(types_1.MultisigDeleteRequestRejectionError.NO_SUCH_REQUEST).test(e && e.kind && e.kind.ExecutionError)) {\n                return { codeStatus: validCodeStatusIfNoDeploy, stateStatus: types_1.MultisigStateStatus.VALID_STATE };\n            }\n            else if (new RegExp(types_1.MultisigDeleteRequestRejectionError.METHOD_NOT_FOUND).test(e && e.message)) {\n                // not reachable if transaction included a deploy\n                return { codeStatus: MultisigCodeStatus.INVALID_CODE, stateStatus: types_1.MultisigStateStatus.UNKNOWN_STATE };\n            }\n            throw e;\n        }\n    }\n    /**\n     * Delete a multisig request by its ID.\n     * @param request_id The ID of the multisig request to be deleted.\n     * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the deletion.\n     */\n    deleteRequest(request_id) {\n        return super.signAndSendTransaction({\n            receiverId: this.accountId,\n            actions: [functionCall('delete_request', { request_id }, constants_1.MULTISIG_GAS, constants_1.MULTISIG_DEPOSIT)]\n        });\n    }\n    /**\n     * Delete all multisig requests associated with the account.\n     * @returns {Promise<void>} A promise that resolves when all requests are deleted.\n     */\n    async deleteAllRequests() {\n        const request_ids = await this.getRequestIds();\n        if (request_ids.length) {\n            await Promise.all(request_ids.map((id) => this.deleteRequest(id)));\n        }\n    }\n    /**\n     * Delete unconfirmed multisig requests associated with the account.\n     * @returns {Promise<void>} A promise that resolves when unconfirmed requests are deleted.\n     */\n    async deleteUnconfirmedRequests() {\n        // TODO: Delete in batch, don't delete unexpired\n        // TODO: Delete in batch, don't delete unexpired (can reduce gas usage dramatically)\n        const request_ids = await this.getRequestIds();\n        const { requestId } = this.getRequest();\n        for (const requestIdToDelete of request_ids) {\n            if (requestIdToDelete == requestId) {\n                continue;\n            }\n            try {\n                await super.signAndSendTransaction({\n                    receiverId: this.accountId,\n                    actions: [functionCall('delete_request', { request_id: requestIdToDelete }, constants_1.MULTISIG_GAS, constants_1.MULTISIG_DEPOSIT)]\n                });\n            }\n            catch (e) {\n                utils_1.Logger.warn('Attempt to delete an earlier request before 15 minutes failed. Will try again.');\n            }\n        }\n    }\n    // helpers\n    async getRequestIds() {\n        // TODO: Read requests from state to allow filtering by expiration time\n        // TODO: https://github.com/near/core-contracts/blob/305d1db4f4f2cf5ce4c1ef3479f7544957381f11/multisig/src/lib.rs#L84\n        return this.viewFunction({\n            contractId: this.accountId,\n            methodName: 'list_request_ids',\n        });\n    }\n    getRequest() {\n        if (this.storage) {\n            return JSON.parse(this.storage.getItem(constants_1.MULTISIG_STORAGE_KEY) || '{}');\n        }\n        return storageFallback[constants_1.MULTISIG_STORAGE_KEY];\n    }\n    setRequest(data) {\n        if (this.storage) {\n            return this.storage.setItem(constants_1.MULTISIG_STORAGE_KEY, JSON.stringify(data));\n        }\n        storageFallback[constants_1.MULTISIG_STORAGE_KEY] = data;\n    }\n}\nexports.AccountMultisig = AccountMultisig;\nconst convertPKForContract = (pk) => pk.toString().replace('ed25519:', '');\nconst convertActions = (actions, accountId, receiverId) => actions.map((a) => {\n    const type = a.enum;\n    const { gas, publicKey, methodName, args, deposit, accessKey, code } = a[type];\n    const action = {\n        type: type[0].toUpperCase() + type.substr(1),\n        gas: (gas && gas.toString()) || undefined,\n        public_key: (publicKey && convertPKForContract(publicKey)) || undefined,\n        method_name: methodName,\n        args: (args && Buffer.from(args).toString('base64')) || undefined,\n        code: (code && Buffer.from(code).toString('base64')) || undefined,\n        amount: (deposit && deposit.toString()) || undefined,\n        deposit: (deposit && deposit.toString()) || '0',\n        permission: undefined,\n    };\n    if (accessKey) {\n        if (receiverId === accountId && accessKey.permission.enum !== 'fullAccess') {\n            action.permission = {\n                receiver_id: accountId,\n                allowance: constants_1.MULTISIG_ALLOWANCE.toString(),\n                method_names: constants_1.MULTISIG_CHANGE_METHODS,\n            };\n        }\n        if (accessKey.permission.enum === 'functionCall') {\n            const { receiverId: receiver_id, methodNames: method_names, allowance } = accessKey.permission.functionCall;\n            action.permission = {\n                receiver_id,\n                allowance: (allowance && allowance.toString()) || undefined,\n                method_names\n            };\n        }\n    }\n    return action;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMS4zLjEvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9jb21tb25qcy9hY2NvdW50X211bHRpc2lnLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUI7QUFDdkIsdUJBQXVCLG1CQUFPLENBQUMsK0lBQXVCO0FBQ3RELGdCQUFnQixtQkFBTyxDQUFDLDBIQUFnQjtBQUN4QyxrQkFBa0IsbUJBQU8sQ0FBQyxpSUFBZTtBQUN6QyxvQkFBb0IsbUJBQU8sQ0FBQyxxSUFBaUI7QUFDN0MsZ0JBQWdCLG1CQUFPLENBQUMsNkhBQWE7QUFDckMsUUFBUSwrQkFBK0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0RBQWdEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQ0FBZ0M7QUFDakQ7QUFDQTtBQUNBLDhDQUE4QyxxQkFBcUI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdDQUFnQztBQUNqRDtBQUNBLG1DQUFtQyxxQkFBcUI7QUFDeEQsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxxQkFBcUI7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFVBQVUsZ0NBQWdDLGtDQUFrQyxHQUFHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxxQkFBcUI7QUFDOUU7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0NBQWdDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFlBQVk7QUFDbkUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCwrQkFBK0I7QUFDOUYsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZEQUE2RDtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdFQUFnRTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hhY2thdGhvbi1uZWFyLXJlZGFjdGVkLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BuZWFyLWpzK2FjY291bnRzQDEuMy4xL25vZGVfbW9kdWxlcy9AbmVhci1qcy9hY2NvdW50cy9saWIvY29tbW9uanMvYWNjb3VudF9tdWx0aXNpZy5janM/NDUzZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWNjb3VudE11bHRpc2lnID0gdm9pZCAwO1xuY29uc3QgdHJhbnNhY3Rpb25zXzEgPSByZXF1aXJlKFwiQG5lYXItanMvdHJhbnNhY3Rpb25zXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbmVhci1qcy91dGlsc1wiKTtcbmNvbnN0IGFjY291bnRfMSA9IHJlcXVpcmUoXCIuL2FjY291bnQuY2pzXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHMuY2pzXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzLmNqc1wiKTtcbmNvbnN0IHsgZGVwbG95Q29udHJhY3QsIGZ1bmN0aW9uQ2FsbCB9ID0gdHJhbnNhY3Rpb25zXzEuYWN0aW9uQ3JlYXRvcnM7XG52YXIgTXVsdGlzaWdDb2RlU3RhdHVzO1xuKGZ1bmN0aW9uIChNdWx0aXNpZ0NvZGVTdGF0dXMpIHtcbiAgICBNdWx0aXNpZ0NvZGVTdGF0dXNbTXVsdGlzaWdDb2RlU3RhdHVzW1wiSU5WQUxJRF9DT0RFXCJdID0gMF0gPSBcIklOVkFMSURfQ09ERVwiO1xuICAgIE11bHRpc2lnQ29kZVN0YXR1c1tNdWx0aXNpZ0NvZGVTdGF0dXNbXCJWQUxJRF9DT0RFXCJdID0gMV0gPSBcIlZBTElEX0NPREVcIjtcbiAgICBNdWx0aXNpZ0NvZGVTdGF0dXNbTXVsdGlzaWdDb2RlU3RhdHVzW1wiVU5LTk9XTl9DT0RFXCJdID0gMl0gPSBcIlVOS05PV05fQ09ERVwiO1xufSkoTXVsdGlzaWdDb2RlU3RhdHVzIHx8IChNdWx0aXNpZ0NvZGVTdGF0dXMgPSB7fSkpO1xuLy8gaW4gbWVtb3J5IHJlcXVlc3QgY2FjaGUgZm9yIG5vZGUgdy9vIGxvY2FsU3RvcmFnZVxuY29uc3Qgc3RvcmFnZUZhbGxiYWNrID0ge1xuICAgIFtjb25zdGFudHNfMS5NVUxUSVNJR19TVE9SQUdFX0tFWV06IG51bGxcbn07XG5jbGFzcyBBY2NvdW50TXVsdGlzaWcgZXh0ZW5kcyBhY2NvdW50XzEuQWNjb3VudCB7XG4gICAgc3RvcmFnZTtcbiAgICBvbkFkZFJlcXVlc3RSZXN1bHQ7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhbiBpbnN0YW5jZSBvZiB0aGUgYEFjY291bnRNdWx0aXNpZ2AgY2xhc3MuXG4gICAgICogQHBhcmFtIGNvbm5lY3Rpb24gVGhlIE5FQVIgY29ubmVjdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIGFjY291bnRJZCBUaGUgTkVBUiBhY2NvdW50IElELlxuICAgICAqIEBwYXJhbSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIG11bHRpc2lnIGFjY291bnQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc3RvcmFnZSBTdG9yYWdlIHRvIHN0b3JlIGRhdGEgcmVsYXRlZCB0byBtdWx0aXNpZyBvcGVyYXRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm9uQWRkUmVxdWVzdFJlc3VsdCBDYWxsYmFjayBmdW5jdGlvbiB0byBoYW5kbGUgdGhlIHJlc3VsdCBvZiBhZGRpbmcgYSByZXF1ZXN0LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb24sIGFjY291bnRJZCwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcihjb25uZWN0aW9uLCBhY2NvdW50SWQpO1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBvcHRpb25zLnN0b3JhZ2U7XG4gICAgICAgIHRoaXMub25BZGRSZXF1ZXN0UmVzdWx0ID0gb3B0aW9ucy5vbkFkZFJlcXVlc3RSZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ24gYW5kIHNlbmQgYSB0cmFuc2FjdGlvbiB3aXRoIHRoZSBtdWx0aXNpZyBhY2NvdW50IGFzIHRoZSBzZW5kZXIuXG4gICAgICogQHBhcmFtIHJlY2VpdmVySWQgLSBUaGUgTkVBUiBhY2NvdW50IElEIG9mIHRoZSB0cmFuc2FjdGlvbiByZWNlaXZlci5cbiAgICAgKiBAcGFyYW0gYWN0aW9ucyAtIFRoZSBsaXN0IG9mIGFjdGlvbnMgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZpbmFsRXhlY3V0aW9uT3V0Y29tZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBmaW5hbCBleGVjdXRpb24gb3V0Y29tZSBvZiB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgYXN5bmMgc2lnbkFuZFNlbmRUcmFuc2FjdGlvbldpdGhBY2NvdW50KHJlY2VpdmVySWQsIGFjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb24oeyByZWNlaXZlcklkLCBhY3Rpb25zIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWduIGFuZCBzZW5kIGEgbXVsdGlzaWcgdHJhbnNhY3Rpb24gdG8gYWRkIGEgcmVxdWVzdCBhbmQgY29uZmlybSBpdC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGZvciB0aGUgbXVsdGlzaWcgdHJhbnNhY3Rpb24uXG4gICAgICogQHBhcmFtIG9wdGlvbnMucmVjZWl2ZXJJZCBUaGUgTkVBUiBhY2NvdW50IElEIG9mIHRoZSB0cmFuc2FjdGlvbiByZWNlaXZlci5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hY3Rpb25zIFRoZSBsaXN0IG9mIGFjdGlvbnMgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZpbmFsRXhlY3V0aW9uT3V0Y29tZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBmaW5hbCBleGVjdXRpb24gb3V0Y29tZSBvZiB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgYXN5bmMgc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih7IHJlY2VpdmVySWQsIGFjdGlvbnMgfSkge1xuICAgICAgICBjb25zdCB7IGFjY291bnRJZCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgYXJncyA9IEJ1ZmZlci5mcm9tKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHJlcXVlc3Q6IHtcbiAgICAgICAgICAgICAgICByZWNlaXZlcl9pZDogcmVjZWl2ZXJJZCxcbiAgICAgICAgICAgICAgICBhY3Rpb25zOiBjb252ZXJ0QWN0aW9ucyhhY3Rpb25zLCBhY2NvdW50SWQsIHJlY2VpdmVySWQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IHN1cGVyLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgICAgIHJlY2VpdmVySWQ6IGFjY291bnRJZCxcbiAgICAgICAgICAgICAgICBhY3Rpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uQ2FsbCgnYWRkX3JlcXVlc3RfYW5kX2NvbmZpcm0nLCBhcmdzLCBjb25zdGFudHNfMS5NVUxUSVNJR19HQVMsIGNvbnN0YW50c18xLk1VTFRJU0lHX0RFUE9TSVQpXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlLnRvU3RyaW5nKCkuaW5jbHVkZXMoJ0FjY291bnQgaGFzIHRvbyBtYW55IGFjdGl2ZSByZXF1ZXN0cy4gQ29uZmlybSBvciBkZWxldGUgc29tZScpKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5kZWxldGVVbmNvbmZpcm1lZFJlcXVlc3RzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih7IHJlY2VpdmVySWQsIGFjdGlvbnMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IEFyZSBmb2xsb3dpbmcgZXZlbiBuZWVkZWQ/IFNlZW1zIGxpa2UgaXQgdGhyb3dzIG9uIGVycm9yIGFscmVhZHlcbiAgICAgICAgaWYgKCFyZXN1bHQuc3RhdHVzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVlc3QgZmFpbGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhdHVzID0geyAuLi5yZXN1bHQuc3RhdHVzIH07XG4gICAgICAgIGlmICghc3RhdHVzLlN1Y2Nlc3NWYWx1ZSB8fCB0eXBlb2Ygc3RhdHVzLlN1Y2Nlc3NWYWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVxdWVzdCBmYWlsZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFJlcXVlc3Qoe1xuICAgICAgICAgICAgYWNjb3VudElkLFxuICAgICAgICAgICAgYWN0aW9ucyxcbiAgICAgICAgICAgIHJlcXVlc3RJZDogcGFyc2VJbnQoQnVmZmVyLmZyb20oc3RhdHVzLlN1Y2Nlc3NWYWx1ZSwgJ2Jhc2U2NCcpLnRvU3RyaW5nKCdhc2NpaScpLCAxMClcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLm9uQWRkUmVxdWVzdFJlc3VsdCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5vbkFkZFJlcXVlc3RSZXN1bHQocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOT1RFIHRoZXJlIGlzIG5vIGF3YWl0IG9uIHB1cnBvc2UgdG8gYXZvaWQgYmxvY2tpbmcgZm9yIDJmYVxuICAgICAgICB0aGlzLmRlbGV0ZVVuY29uZmlybWVkUmVxdWVzdHMoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2Qgc3VibWl0cyBhIGNhbmFyeSB0cmFuc2FjdGlvbiB0aGF0IGlzIGV4cGVjdGVkIHRvIGFsd2F5cyBmYWlsIGluIG9yZGVyIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBjb250cmFjdCBjdXJyZW50bHkgaGFzIHZhbGlkIG11bHRpc2lnIHN0YXRlXG4gICAgICogYW5kIHdoZXRoZXIgaXQgaXMgaW5pdGlhbGl6ZWQuIFRoZSBjYW5hcnkgdHJhbnNhY3Rpb24gYXR0ZW1wdHMgdG8gZGVsZXRlIGEgcmVxdWVzdCBhdCBpbmRleCB1MzJfbWF4IGFuZCB3aWxsIGdvIHRocm91Z2ggaWYgYSByZXF1ZXN0IGV4aXN0cyBhdCB0aGF0IGluZGV4LlxuICAgICAqIGEgdTMyX21heCArIDEgYW5kIC0xIHZhbHVlIGNhbm5vdCBiZSB1c2VkIGZvciB0aGUgY2FuYXJ5IGR1ZSB0byBleHBlY3RlZCB1MzIgZXJyb3IgdGhyb3duIGJlZm9yZSBkZXNlcmlhbGl6YXRpb24gYXR0ZW1wdC5cbiAgICAgKiBAcGFyYW0gY29udHJhY3RCeXRlcyBUaGUgYnl0ZWNvZGUgb2YgdGhlIG11bHRpc2lnIGNvbnRyYWN0LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHsgY29kZVN0YXR1czogTXVsdGlzaWdDb2RlU3RhdHVzOyBzdGF0ZVN0YXR1czogTXVsdGlzaWdTdGF0ZVN0YXR1cyB9Pn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHN0YXR1cyBvZiB0aGUgY29kZSBhbmQgc3RhdGUuXG4gICAgICovXG4gICAgYXN5bmMgY2hlY2tNdWx0aXNpZ0NvZGVBbmRTdGF0ZVN0YXR1cyhjb250cmFjdEJ5dGVzKSB7XG4gICAgICAgIGNvbnN0IHUzMl9tYXggPSA0XzI5NF85NjdfMjk1O1xuICAgICAgICBjb25zdCB2YWxpZENvZGVTdGF0dXNJZk5vRGVwbG95ID0gY29udHJhY3RCeXRlcyA/IE11bHRpc2lnQ29kZVN0YXR1cy5VTktOT1dOX0NPREUgOiBNdWx0aXNpZ0NvZGVTdGF0dXMuVkFMSURfQ09ERTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChjb250cmFjdEJ5dGVzKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgc3VwZXIuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmVySWQ6IHRoaXMuYWNjb3VudElkLCBhY3Rpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXBsb3lDb250cmFjdChjb250cmFjdEJ5dGVzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uQ2FsbCgnZGVsZXRlX3JlcXVlc3QnLCB7IHJlcXVlc3RfaWQ6IHUzMl9tYXggfSwgY29uc3RhbnRzXzEuTVVMVElTSUdfR0FTLCBjb25zdGFudHNfMS5NVUxUSVNJR19ERVBPU0lUKVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmRlbGV0ZVJlcXVlc3QodTMyX21heCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBjb2RlU3RhdHVzOiBNdWx0aXNpZ0NvZGVTdGF0dXMuVkFMSURfQ09ERSwgc3RhdGVTdGF0dXM6IHR5cGVzXzEuTXVsdGlzaWdTdGF0ZVN0YXR1cy5WQUxJRF9TVEFURSB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAobmV3IFJlZ0V4cCh0eXBlc18xLk11bHRpc2lnRGVsZXRlUmVxdWVzdFJlamVjdGlvbkVycm9yLkNBTk5PVF9ERVNFUklBTElaRV9TVEFURSkudGVzdChlICYmIGUua2luZCAmJiBlLmtpbmQuRXhlY3V0aW9uRXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgY29kZVN0YXR1czogdmFsaWRDb2RlU3RhdHVzSWZOb0RlcGxveSwgc3RhdGVTdGF0dXM6IHR5cGVzXzEuTXVsdGlzaWdTdGF0ZVN0YXR1cy5JTlZBTElEX1NUQVRFIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZXcgUmVnRXhwKHR5cGVzXzEuTXVsdGlzaWdEZWxldGVSZXF1ZXN0UmVqZWN0aW9uRXJyb3IuTVVMVElTSUdfTk9UX0lOSVRJQUxJWkVEKS50ZXN0KGUgJiYgZS5raW5kICYmIGUua2luZC5FeGVjdXRpb25FcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBjb2RlU3RhdHVzOiB2YWxpZENvZGVTdGF0dXNJZk5vRGVwbG95LCBzdGF0ZVN0YXR1czogdHlwZXNfMS5NdWx0aXNpZ1N0YXRlU3RhdHVzLlNUQVRFX05PVF9JTklUSUFMSVpFRCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmV3IFJlZ0V4cCh0eXBlc18xLk11bHRpc2lnRGVsZXRlUmVxdWVzdFJlamVjdGlvbkVycm9yLk5PX1NVQ0hfUkVRVUVTVCkudGVzdChlICYmIGUua2luZCAmJiBlLmtpbmQuRXhlY3V0aW9uRXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgY29kZVN0YXR1czogdmFsaWRDb2RlU3RhdHVzSWZOb0RlcGxveSwgc3RhdGVTdGF0dXM6IHR5cGVzXzEuTXVsdGlzaWdTdGF0ZVN0YXR1cy5WQUxJRF9TVEFURSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmV3IFJlZ0V4cCh0eXBlc18xLk11bHRpc2lnRGVsZXRlUmVxdWVzdFJlamVjdGlvbkVycm9yLk1FVEhPRF9OT1RfRk9VTkQpLnRlc3QoZSAmJiBlLm1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgLy8gbm90IHJlYWNoYWJsZSBpZiB0cmFuc2FjdGlvbiBpbmNsdWRlZCBhIGRlcGxveVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGNvZGVTdGF0dXM6IE11bHRpc2lnQ29kZVN0YXR1cy5JTlZBTElEX0NPREUsIHN0YXRlU3RhdHVzOiB0eXBlc18xLk11bHRpc2lnU3RhdGVTdGF0dXMuVU5LTk9XTl9TVEFURSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSBtdWx0aXNpZyByZXF1ZXN0IGJ5IGl0cyBJRC5cbiAgICAgKiBAcGFyYW0gcmVxdWVzdF9pZCBUaGUgSUQgb2YgdGhlIG11bHRpc2lnIHJlcXVlc3QgdG8gYmUgZGVsZXRlZC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGaW5hbEV4ZWN1dGlvbk91dGNvbWU+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgZmluYWwgZXhlY3V0aW9uIG91dGNvbWUgb2YgdGhlIGRlbGV0aW9uLlxuICAgICAqL1xuICAgIGRlbGV0ZVJlcXVlc3QocmVxdWVzdF9pZCkge1xuICAgICAgICByZXR1cm4gc3VwZXIuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICByZWNlaXZlcklkOiB0aGlzLmFjY291bnRJZCxcbiAgICAgICAgICAgIGFjdGlvbnM6IFtmdW5jdGlvbkNhbGwoJ2RlbGV0ZV9yZXF1ZXN0JywgeyByZXF1ZXN0X2lkIH0sIGNvbnN0YW50c18xLk1VTFRJU0lHX0dBUywgY29uc3RhbnRzXzEuTVVMVElTSUdfREVQT1NJVCldXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYWxsIG11bHRpc2lnIHJlcXVlc3RzIGFzc29jaWF0ZWQgd2l0aCB0aGUgYWNjb3VudC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBhbGwgcmVxdWVzdHMgYXJlIGRlbGV0ZWQuXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlQWxsUmVxdWVzdHMoKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RfaWRzID0gYXdhaXQgdGhpcy5nZXRSZXF1ZXN0SWRzKCk7XG4gICAgICAgIGlmIChyZXF1ZXN0X2lkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJlcXVlc3RfaWRzLm1hcCgoaWQpID0+IHRoaXMuZGVsZXRlUmVxdWVzdChpZCkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgdW5jb25maXJtZWQgbXVsdGlzaWcgcmVxdWVzdHMgYXNzb2NpYXRlZCB3aXRoIHRoZSBhY2NvdW50LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHVuY29uZmlybWVkIHJlcXVlc3RzIGFyZSBkZWxldGVkLlxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZVVuY29uZmlybWVkUmVxdWVzdHMoKSB7XG4gICAgICAgIC8vIFRPRE86IERlbGV0ZSBpbiBiYXRjaCwgZG9uJ3QgZGVsZXRlIHVuZXhwaXJlZFxuICAgICAgICAvLyBUT0RPOiBEZWxldGUgaW4gYmF0Y2gsIGRvbid0IGRlbGV0ZSB1bmV4cGlyZWQgKGNhbiByZWR1Y2UgZ2FzIHVzYWdlIGRyYW1hdGljYWxseSlcbiAgICAgICAgY29uc3QgcmVxdWVzdF9pZHMgPSBhd2FpdCB0aGlzLmdldFJlcXVlc3RJZHMoKTtcbiAgICAgICAgY29uc3QgeyByZXF1ZXN0SWQgfSA9IHRoaXMuZ2V0UmVxdWVzdCgpO1xuICAgICAgICBmb3IgKGNvbnN0IHJlcXVlc3RJZFRvRGVsZXRlIG9mIHJlcXVlc3RfaWRzKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdElkVG9EZWxldGUgPT0gcmVxdWVzdElkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHN1cGVyLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICByZWNlaXZlcklkOiB0aGlzLmFjY291bnRJZCxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uczogW2Z1bmN0aW9uQ2FsbCgnZGVsZXRlX3JlcXVlc3QnLCB7IHJlcXVlc3RfaWQ6IHJlcXVlc3RJZFRvRGVsZXRlIH0sIGNvbnN0YW50c18xLk1VTFRJU0lHX0dBUywgY29uc3RhbnRzXzEuTVVMVElTSUdfREVQT1NJVCldXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHV0aWxzXzEuTG9nZ2VyLndhcm4oJ0F0dGVtcHQgdG8gZGVsZXRlIGFuIGVhcmxpZXIgcmVxdWVzdCBiZWZvcmUgMTUgbWludXRlcyBmYWlsZWQuIFdpbGwgdHJ5IGFnYWluLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGhlbHBlcnNcbiAgICBhc3luYyBnZXRSZXF1ZXN0SWRzKCkge1xuICAgICAgICAvLyBUT0RPOiBSZWFkIHJlcXVlc3RzIGZyb20gc3RhdGUgdG8gYWxsb3cgZmlsdGVyaW5nIGJ5IGV4cGlyYXRpb24gdGltZVxuICAgICAgICAvLyBUT0RPOiBodHRwczovL2dpdGh1Yi5jb20vbmVhci9jb3JlLWNvbnRyYWN0cy9ibG9iLzMwNWQxZGI0ZjRmMmNmNWNlNGMxZWYzNDc5Zjc1NDQ5NTczODFmMTEvbXVsdGlzaWcvc3JjL2xpYi5ycyNMODRcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld0Z1bmN0aW9uKHtcbiAgICAgICAgICAgIGNvbnRyYWN0SWQ6IHRoaXMuYWNjb3VudElkLFxuICAgICAgICAgICAgbWV0aG9kTmFtZTogJ2xpc3RfcmVxdWVzdF9pZHMnLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0UmVxdWVzdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RvcmFnZSkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGhpcy5zdG9yYWdlLmdldEl0ZW0oY29uc3RhbnRzXzEuTVVMVElTSUdfU1RPUkFHRV9LRVkpIHx8ICd7fScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdG9yYWdlRmFsbGJhY2tbY29uc3RhbnRzXzEuTVVMVElTSUdfU1RPUkFHRV9LRVldO1xuICAgIH1cbiAgICBzZXRSZXF1ZXN0KGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RvcmFnZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5zZXRJdGVtKGNvbnN0YW50c18xLk1VTFRJU0lHX1NUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeShkYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RvcmFnZUZhbGxiYWNrW2NvbnN0YW50c18xLk1VTFRJU0lHX1NUT1JBR0VfS0VZXSA9IGRhdGE7XG4gICAgfVxufVxuZXhwb3J0cy5BY2NvdW50TXVsdGlzaWcgPSBBY2NvdW50TXVsdGlzaWc7XG5jb25zdCBjb252ZXJ0UEtGb3JDb250cmFjdCA9IChwaykgPT4gcGsudG9TdHJpbmcoKS5yZXBsYWNlKCdlZDI1NTE5OicsICcnKTtcbmNvbnN0IGNvbnZlcnRBY3Rpb25zID0gKGFjdGlvbnMsIGFjY291bnRJZCwgcmVjZWl2ZXJJZCkgPT4gYWN0aW9ucy5tYXAoKGEpID0+IHtcbiAgICBjb25zdCB0eXBlID0gYS5lbnVtO1xuICAgIGNvbnN0IHsgZ2FzLCBwdWJsaWNLZXksIG1ldGhvZE5hbWUsIGFyZ3MsIGRlcG9zaXQsIGFjY2Vzc0tleSwgY29kZSB9ID0gYVt0eXBlXTtcbiAgICBjb25zdCBhY3Rpb24gPSB7XG4gICAgICAgIHR5cGU6IHR5cGVbMF0udG9VcHBlckNhc2UoKSArIHR5cGUuc3Vic3RyKDEpLFxuICAgICAgICBnYXM6IChnYXMgJiYgZ2FzLnRvU3RyaW5nKCkpIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgcHVibGljX2tleTogKHB1YmxpY0tleSAmJiBjb252ZXJ0UEtGb3JDb250cmFjdChwdWJsaWNLZXkpKSB8fCB1bmRlZmluZWQsXG4gICAgICAgIG1ldGhvZF9uYW1lOiBtZXRob2ROYW1lLFxuICAgICAgICBhcmdzOiAoYXJncyAmJiBCdWZmZXIuZnJvbShhcmdzKS50b1N0cmluZygnYmFzZTY0JykpIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgY29kZTogKGNvZGUgJiYgQnVmZmVyLmZyb20oY29kZSkudG9TdHJpbmcoJ2Jhc2U2NCcpKSB8fCB1bmRlZmluZWQsXG4gICAgICAgIGFtb3VudDogKGRlcG9zaXQgJiYgZGVwb3NpdC50b1N0cmluZygpKSB8fCB1bmRlZmluZWQsXG4gICAgICAgIGRlcG9zaXQ6IChkZXBvc2l0ICYmIGRlcG9zaXQudG9TdHJpbmcoKSkgfHwgJzAnLFxuICAgICAgICBwZXJtaXNzaW9uOiB1bmRlZmluZWQsXG4gICAgfTtcbiAgICBpZiAoYWNjZXNzS2V5KSB7XG4gICAgICAgIGlmIChyZWNlaXZlcklkID09PSBhY2NvdW50SWQgJiYgYWNjZXNzS2V5LnBlcm1pc3Npb24uZW51bSAhPT0gJ2Z1bGxBY2Nlc3MnKSB7XG4gICAgICAgICAgICBhY3Rpb24ucGVybWlzc2lvbiA9IHtcbiAgICAgICAgICAgICAgICByZWNlaXZlcl9pZDogYWNjb3VudElkLFxuICAgICAgICAgICAgICAgIGFsbG93YW5jZTogY29uc3RhbnRzXzEuTVVMVElTSUdfQUxMT1dBTkNFLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgbWV0aG9kX25hbWVzOiBjb25zdGFudHNfMS5NVUxUSVNJR19DSEFOR0VfTUVUSE9EUyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjY2Vzc0tleS5wZXJtaXNzaW9uLmVudW0gPT09ICdmdW5jdGlvbkNhbGwnKSB7XG4gICAgICAgICAgICBjb25zdCB7IHJlY2VpdmVySWQ6IHJlY2VpdmVyX2lkLCBtZXRob2ROYW1lczogbWV0aG9kX25hbWVzLCBhbGxvd2FuY2UgfSA9IGFjY2Vzc0tleS5wZXJtaXNzaW9uLmZ1bmN0aW9uQ2FsbDtcbiAgICAgICAgICAgIGFjdGlvbi5wZXJtaXNzaW9uID0ge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVyX2lkLFxuICAgICAgICAgICAgICAgIGFsbG93YW5jZTogKGFsbG93YW5jZSAmJiBhbGxvd2FuY2UudG9TdHJpbmcoKSkgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIG1ldGhvZF9uYW1lc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWN0aW9uO1xufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/account_multisig.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/connection.cjs":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/connection.cjs ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Connection = void 0;\nconst signers_1 = __webpack_require__(/*! @near-js/signers */ \"(ssr)/./node_modules/.pnpm/@near-js+signers@0.2.1/node_modules/@near-js/signers/lib/commonjs/index.cjs\");\nconst providers_1 = __webpack_require__(/*! @near-js/providers */ \"(ssr)/./node_modules/.pnpm/@near-js+providers@1.0.1/node_modules/@near-js/providers/lib/commonjs/index.cjs\");\n/**\n * @param config Contains connection info details\n * @returns {Provider}\n */\nfunction getProvider(config) {\n    switch (config.type) {\n        case undefined:\n            return config;\n        case 'JsonRpcProvider': return new providers_1.JsonRpcProvider({ ...config.args });\n        case 'FailoverRpcProvider': {\n            const providers = (config?.args || []).map((arg) => new providers_1.JsonRpcProvider(arg));\n            return new providers_1.FailoverRpcProvider(providers);\n        }\n        default: throw new Error(`Unknown provider type ${config.type}`);\n    }\n}\n/**\n * @param config Contains connection info details\n * @returns {Signer}\n */\nfunction getSigner(config) {\n    switch (config.type) {\n        case undefined:\n            return config;\n        case 'InMemorySigner': {\n            return new signers_1.InMemorySigner(config.keyStore);\n        }\n        default: throw new Error(`Unknown signer type ${config.type}`);\n    }\n}\n/**\n * Connects an account to a given network via a given provider\n */\nclass Connection {\n    networkId;\n    provider;\n    signer;\n    jsvmAccountId;\n    constructor(networkId, provider, signer, jsvmAccountId) {\n        this.networkId = networkId;\n        this.provider = provider;\n        this.signer = signer;\n        this.jsvmAccountId = jsvmAccountId;\n    }\n    getConnection() {\n        return this;\n    }\n    /**\n     * @param config Contains connection info details\n     */\n    static fromConfig(config) {\n        const provider = getProvider(config.provider);\n        const signer = getSigner(config.signer);\n        return new Connection(config.networkId, provider, signer, config.jsvmAccountId);\n    }\n}\nexports.Connection = Connection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMS4zLjEvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9jb21tb25qcy9jb25uZWN0aW9uLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0I7QUFDbEIsa0JBQWtCLG1CQUFPLENBQUMsZ0lBQWtCO0FBQzVDLG9CQUFvQixtQkFBTyxDQUFDLHNJQUFvQjtBQUNoRDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsZ0JBQWdCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFlBQVk7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxZQUFZO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGFja2F0aG9uLW5lYXItcmVkYWN0ZWQvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMS4zLjEvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9jb21tb25qcy9jb25uZWN0aW9uLmNqcz9jNzZiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db25uZWN0aW9uID0gdm9pZCAwO1xuY29uc3Qgc2lnbmVyc18xID0gcmVxdWlyZShcIkBuZWFyLWpzL3NpZ25lcnNcIik7XG5jb25zdCBwcm92aWRlcnNfMSA9IHJlcXVpcmUoXCJAbmVhci1qcy9wcm92aWRlcnNcIik7XG4vKipcbiAqIEBwYXJhbSBjb25maWcgQ29udGFpbnMgY29ubmVjdGlvbiBpbmZvIGRldGFpbHNcbiAqIEByZXR1cm5zIHtQcm92aWRlcn1cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvdmlkZXIoY29uZmlnKSB7XG4gICAgc3dpdGNoIChjb25maWcudHlwZSkge1xuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgIHJldHVybiBjb25maWc7XG4gICAgICAgIGNhc2UgJ0pzb25ScGNQcm92aWRlcic6IHJldHVybiBuZXcgcHJvdmlkZXJzXzEuSnNvblJwY1Byb3ZpZGVyKHsgLi4uY29uZmlnLmFyZ3MgfSk7XG4gICAgICAgIGNhc2UgJ0ZhaWxvdmVyUnBjUHJvdmlkZXInOiB7XG4gICAgICAgICAgICBjb25zdCBwcm92aWRlcnMgPSAoY29uZmlnPy5hcmdzIHx8IFtdKS5tYXAoKGFyZykgPT4gbmV3IHByb3ZpZGVyc18xLkpzb25ScGNQcm92aWRlcihhcmcpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgcHJvdmlkZXJzXzEuRmFpbG92ZXJScGNQcm92aWRlcihwcm92aWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcihgVW5rbm93biBwcm92aWRlciB0eXBlICR7Y29uZmlnLnR5cGV9YCk7XG4gICAgfVxufVxuLyoqXG4gKiBAcGFyYW0gY29uZmlnIENvbnRhaW5zIGNvbm5lY3Rpb24gaW5mbyBkZXRhaWxzXG4gKiBAcmV0dXJucyB7U2lnbmVyfVxuICovXG5mdW5jdGlvbiBnZXRTaWduZXIoY29uZmlnKSB7XG4gICAgc3dpdGNoIChjb25maWcudHlwZSkge1xuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgIHJldHVybiBjb25maWc7XG4gICAgICAgIGNhc2UgJ0luTWVtb3J5U2lnbmVyJzoge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBzaWduZXJzXzEuSW5NZW1vcnlTaWduZXIoY29uZmlnLmtleVN0b3JlKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc2lnbmVyIHR5cGUgJHtjb25maWcudHlwZX1gKTtcbiAgICB9XG59XG4vKipcbiAqIENvbm5lY3RzIGFuIGFjY291bnQgdG8gYSBnaXZlbiBuZXR3b3JrIHZpYSBhIGdpdmVuIHByb3ZpZGVyXG4gKi9cbmNsYXNzIENvbm5lY3Rpb24ge1xuICAgIG5ldHdvcmtJZDtcbiAgICBwcm92aWRlcjtcbiAgICBzaWduZXI7XG4gICAganN2bUFjY291bnRJZDtcbiAgICBjb25zdHJ1Y3RvcihuZXR3b3JrSWQsIHByb3ZpZGVyLCBzaWduZXIsIGpzdm1BY2NvdW50SWQpIHtcbiAgICAgICAgdGhpcy5uZXR3b3JrSWQgPSBuZXR3b3JrSWQ7XG4gICAgICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgdGhpcy5zaWduZXIgPSBzaWduZXI7XG4gICAgICAgIHRoaXMuanN2bUFjY291bnRJZCA9IGpzdm1BY2NvdW50SWQ7XG4gICAgfVxuICAgIGdldENvbm5lY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gY29uZmlnIENvbnRhaW5zIGNvbm5lY3Rpb24gaW5mbyBkZXRhaWxzXG4gICAgICovXG4gICAgc3RhdGljIGZyb21Db25maWcoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIoY29uZmlnLnByb3ZpZGVyKTtcbiAgICAgICAgY29uc3Qgc2lnbmVyID0gZ2V0U2lnbmVyKGNvbmZpZy5zaWduZXIpO1xuICAgICAgICByZXR1cm4gbmV3IENvbm5lY3Rpb24oY29uZmlnLm5ldHdvcmtJZCwgcHJvdmlkZXIsIHNpZ25lciwgY29uZmlnLmpzdm1BY2NvdW50SWQpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29ubmVjdGlvbiA9IENvbm5lY3Rpb247XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/connection.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/constants.cjs":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/constants.cjs ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MULTISIG_CONFIRM_METHODS = exports.MULTISIG_CHANGE_METHODS = exports.MULTISIG_DEPOSIT = exports.MULTISIG_GAS = exports.MULTISIG_ALLOWANCE = exports.MULTISIG_STORAGE_KEY = void 0;\nconst utils_1 = __webpack_require__(/*! @near-js/utils */ \"(ssr)/./node_modules/.pnpm/@near-js+utils@1.0.1/node_modules/@near-js/utils/lib/commonjs/index.cjs\");\nexports.MULTISIG_STORAGE_KEY = '__multisigRequest';\nexports.MULTISIG_ALLOWANCE = BigInt((0, utils_1.parseNearAmount)('1'));\n// TODO: Different gas value for different requests (can reduce gas usage dramatically)\nexports.MULTISIG_GAS = 100000000000000n;\nexports.MULTISIG_DEPOSIT = 0n;\nexports.MULTISIG_CHANGE_METHODS = ['add_request', 'add_request_and_confirm', 'delete_request', 'confirm'];\nexports.MULTISIG_CONFIRM_METHODS = ['confirm'];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMS4zLjEvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9jb21tb25qcy9jb25zdGFudHMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdDQUFnQyxHQUFHLCtCQUErQixHQUFHLHdCQUF3QixHQUFHLG9CQUFvQixHQUFHLDBCQUEwQixHQUFHLDRCQUE0QjtBQUNoTCxnQkFBZ0IsbUJBQU8sQ0FBQywwSEFBZ0I7QUFDeEMsNEJBQTRCO0FBQzVCLDBCQUEwQjtBQUMxQjtBQUNBLG9CQUFvQjtBQUNwQix3QkFBd0I7QUFDeEIsK0JBQStCO0FBQy9CLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hhY2thdGhvbi1uZWFyLXJlZGFjdGVkLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BuZWFyLWpzK2FjY291bnRzQDEuMy4xL25vZGVfbW9kdWxlcy9AbmVhci1qcy9hY2NvdW50cy9saWIvY29tbW9uanMvY29uc3RhbnRzLmNqcz9mZGRhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NVUxUSVNJR19DT05GSVJNX01FVEhPRFMgPSBleHBvcnRzLk1VTFRJU0lHX0NIQU5HRV9NRVRIT0RTID0gZXhwb3J0cy5NVUxUSVNJR19ERVBPU0lUID0gZXhwb3J0cy5NVUxUSVNJR19HQVMgPSBleHBvcnRzLk1VTFRJU0lHX0FMTE9XQU5DRSA9IGV4cG9ydHMuTVVMVElTSUdfU1RPUkFHRV9LRVkgPSB2b2lkIDA7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBuZWFyLWpzL3V0aWxzXCIpO1xuZXhwb3J0cy5NVUxUSVNJR19TVE9SQUdFX0tFWSA9ICdfX211bHRpc2lnUmVxdWVzdCc7XG5leHBvcnRzLk1VTFRJU0lHX0FMTE9XQU5DRSA9IEJpZ0ludCgoMCwgdXRpbHNfMS5wYXJzZU5lYXJBbW91bnQpKCcxJykpO1xuLy8gVE9ETzogRGlmZmVyZW50IGdhcyB2YWx1ZSBmb3IgZGlmZmVyZW50IHJlcXVlc3RzIChjYW4gcmVkdWNlIGdhcyB1c2FnZSBkcmFtYXRpY2FsbHkpXG5leHBvcnRzLk1VTFRJU0lHX0dBUyA9IDEwMDAwMDAwMDAwMDAwMG47XG5leHBvcnRzLk1VTFRJU0lHX0RFUE9TSVQgPSAwbjtcbmV4cG9ydHMuTVVMVElTSUdfQ0hBTkdFX01FVEhPRFMgPSBbJ2FkZF9yZXF1ZXN0JywgJ2FkZF9yZXF1ZXN0X2FuZF9jb25maXJtJywgJ2RlbGV0ZV9yZXF1ZXN0JywgJ2NvbmZpcm0nXTtcbmV4cG9ydHMuTVVMVElTSUdfQ09ORklSTV9NRVRIT0RTID0gWydjb25maXJtJ107XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/constants.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/contract.cjs":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/contract.cjs ***!
  \*************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Contract = void 0;\nconst utils_1 = __webpack_require__(/*! @near-js/utils */ \"(ssr)/./node_modules/.pnpm/@near-js+utils@1.0.1/node_modules/@near-js/utils/lib/commonjs/index.cjs\");\nconst types_1 = __webpack_require__(/*! @near-js/types */ \"(ssr)/./node_modules/.pnpm/@near-js+types@0.3.1/node_modules/@near-js/types/lib/commonjs/index.cjs\");\nconst local_view_execution_1 = __webpack_require__(/*! ./local-view-execution/index.cjs */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/local-view-execution/index.cjs\");\nconst is_my_json_valid_1 = __importDefault(__webpack_require__(/*! is-my-json-valid */ \"(ssr)/./node_modules/.pnpm/is-my-json-valid@2.20.6/node_modules/is-my-json-valid/index.js\"));\nconst depd_1 = __importDefault(__webpack_require__(/*! depd */ \"(ssr)/./node_modules/.pnpm/depd@2.0.0/node_modules/depd/index.js\"));\nconst near_abi_1 = __webpack_require__(/*! near-abi */ \"(ssr)/./node_modules/.pnpm/near-abi@0.1.1/node_modules/near-abi/lib/index.js\");\nconst account_1 = __webpack_require__(/*! ./account.cjs */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/account.cjs\");\nconst errors_1 = __webpack_require__(/*! ./errors.cjs */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/errors.cjs\");\nconst utils_2 = __webpack_require__(/*! ./utils.cjs */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/utils.cjs\");\n// Makes `function.name` return given name\nfunction nameFunction(name, body) {\n    return {\n        [name](...args) {\n            return body(...args);\n        },\n    }[name];\n}\nfunction validateArguments(args, abiFunction, abiRoot) {\n    if (!isObject(args))\n        return;\n    if (abiFunction.params &&\n        abiFunction.params.serialization_type !== near_abi_1.AbiSerializationType.Json) {\n        throw new errors_1.UnsupportedSerializationError(abiFunction.name, abiFunction.params.serialization_type);\n    }\n    if (abiFunction.result &&\n        abiFunction.result.serialization_type !== near_abi_1.AbiSerializationType.Json) {\n        throw new errors_1.UnsupportedSerializationError(abiFunction.name, abiFunction.result.serialization_type);\n    }\n    const params = abiFunction.params?.args || [];\n    for (const p of params) {\n        const arg = args[p.name];\n        const typeSchema = p.type_schema;\n        typeSchema.definitions = abiRoot.body.root_schema.definitions;\n        const validate = (0, is_my_json_valid_1.default)(typeSchema);\n        const valid = validate(arg);\n        if (!valid) {\n            throw new errors_1.ArgumentSchemaError(p.name, validate.errors);\n        }\n    }\n    // Check there are no extra unknown arguments passed\n    for (const argName of Object.keys(args)) {\n        const param = params.find((p) => p.name === argName);\n        if (!param) {\n            throw new errors_1.UnknownArgumentError(argName, params.map((p) => p.name));\n        }\n    }\n}\nconst isUint8Array = (x) => x && x.byteLength !== undefined && x.byteLength === x.length;\nconst isObject = (x) => Object.prototype.toString.call(x) === \"[object Object]\";\n/**\n * Defines a smart contract on NEAR including the change (mutable) and view (non-mutable) methods\n *\n * @see [https://docs.near.org/tools/near-api-js/quick-reference#contract](https://docs.near.org/tools/near-api-js/quick-reference#contract)\n * @example\n * ```js\n * import { Contract } from 'near-api-js';\n *\n * async function contractExample() {\n *   const methodOptions = {\n *     viewMethods: ['getMessageByAccountId'],\n *     changeMethods: ['addMessage']\n *   };\n *   const contract = new Contract(\n *     wallet.account(),\n *     'contract-id.testnet',\n *     methodOptions\n *   );\n *\n *   // use a contract view method\n *   const messages = await contract.getMessages({\n *     accountId: 'example-account.testnet'\n *   });\n *\n *   // use a contract change method\n *   await contract.addMessage({\n *      meta: 'some info',\n *      callbackUrl: 'https://example.com/callback',\n *      args: { text: 'my message' },\n *      amount: 1\n *   })\n * }\n * ```\n */\nclass Contract {\n    /** @deprecated */\n    account;\n    connection;\n    contractId;\n    lve;\n    /**\n     * @param account NEAR account to sign change method transactions\n     * @param contractId NEAR account id where the contract is deployed\n     * @param options NEAR smart contract methods that your application will use. These will be available as `contract.methodName`\n     */\n    constructor(connection, contractId, options) {\n        this.connection = connection.getConnection();\n        if (connection instanceof account_1.Account) {\n            const deprecate = (0, depd_1.default)(\"new Contract(account, contractId, options)\");\n            deprecate(\"use `new Contract(connection, contractId, options)` instead\");\n            this.account = connection;\n        }\n        this.contractId = contractId;\n        this.lve = new local_view_execution_1.LocalViewExecution(connection);\n        const { viewMethods = [], changeMethods = [], abi: abiRoot, useLocalViewExecution, } = options;\n        let viewMethodsWithAbi = viewMethods.map((name) => ({\n            name,\n            abi: null,\n        }));\n        let changeMethodsWithAbi = changeMethods.map((name) => ({\n            name,\n            abi: null,\n        }));\n        if (abiRoot) {\n            if (viewMethodsWithAbi.length > 0 ||\n                changeMethodsWithAbi.length > 0) {\n                throw new errors_1.ConflictingOptions();\n            }\n            viewMethodsWithAbi = abiRoot.body.functions\n                .filter((m) => m.kind === near_abi_1.AbiFunctionKind.View)\n                .map((m) => ({ name: m.name, abi: m }));\n            changeMethodsWithAbi = abiRoot.body.functions\n                .filter((methodAbi) => methodAbi.kind === near_abi_1.AbiFunctionKind.Call)\n                .map((methodAbi) => ({ name: methodAbi.name, abi: methodAbi }));\n        }\n        viewMethodsWithAbi.forEach(({ name, abi }) => {\n            Object.defineProperty(this, name, {\n                writable: false,\n                enumerable: true,\n                value: nameFunction(name, async (args = {}, options = {}, ...ignored) => {\n                    if (ignored.length ||\n                        !(isObject(args) || isUint8Array(args)) ||\n                        !isObject(options)) {\n                        throw new types_1.PositionalArgsError();\n                    }\n                    if (abi) {\n                        validateArguments(args, abi, abiRoot);\n                    }\n                    if (useLocalViewExecution) {\n                        try {\n                            return await this.lve.viewFunction({\n                                contractId: this.contractId,\n                                methodName: name,\n                                args,\n                                ...options,\n                            });\n                        }\n                        catch (error) {\n                            utils_1.Logger.warn(`Local view execution failed with: \"${error.message}\"`);\n                            utils_1.Logger.warn(`Fallback to normal RPC call`);\n                        }\n                    }\n                    if (this.account) {\n                        return this.account.viewFunction({\n                            contractId: this.contractId,\n                            methodName: name,\n                            args,\n                            ...options,\n                        });\n                    }\n                    return (0, utils_2.viewFunction)(this.connection, {\n                        contractId: this.contractId,\n                        methodName: name,\n                        args,\n                        ...options,\n                    });\n                }),\n            });\n        });\n        changeMethodsWithAbi.forEach(({ name, abi }) => {\n            Object.defineProperty(this, name, {\n                writable: false,\n                enumerable: true,\n                value: nameFunction(name, async (...args) => {\n                    if (args.length &&\n                        (args.length > 3 ||\n                            !(isObject(args[0]) || isUint8Array(args[0])))) {\n                        throw new types_1.PositionalArgsError();\n                    }\n                    if (args.length > 1 || !(args[0] && args[0].args)) {\n                        const deprecate = (0, depd_1.default)(\"contract.methodName(args, gas, amount)\");\n                        deprecate(\"use `contract.methodName({ signerAccount, args, gas?, amount?, callbackUrl?, meta? })` instead\");\n                        args[0] = {\n                            args: args[0],\n                            gas: args[1],\n                            amount: args[2],\n                        };\n                    }\n                    if (abi) {\n                        validateArguments(args[0].args, abi, abiRoot);\n                    }\n                    return this._changeMethod({ methodName: name, ...args[0] });\n                }),\n            });\n        });\n    }\n    async _changeMethod({ signerAccount, args, methodName, gas, amount, meta, callbackUrl, }) {\n        validateBNLike({ gas, amount });\n        const account = this.account || signerAccount;\n        if (!account)\n            throw new Error(`signerAccount must be specified`);\n        const rawResult = await account.functionCall({\n            contractId: this.contractId,\n            methodName,\n            args,\n            gas,\n            attachedDeposit: amount,\n            walletMeta: meta,\n            walletCallbackUrl: callbackUrl,\n        });\n        return (0, utils_1.getTransactionLastResult)(rawResult);\n    }\n}\nexports.Contract = Contract;\n/**\n * Throws if an argument is not in BigInt format or otherwise invalid\n * @param argMap\n */\nfunction validateBNLike(argMap) {\n    const bnLike = \"number, decimal string or BigInt\";\n    for (const argName of Object.keys(argMap)) {\n        const argValue = argMap[argName];\n        if (argValue && typeof argValue !== \"bigint\" && isNaN(argValue)) {\n            throw new types_1.ArgumentTypeError(argName, bnLike, argValue);\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMS4zLjEvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9jb21tb25qcy9jb250cmFjdC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEIsZ0JBQWdCLG1CQUFPLENBQUMsMEhBQWdCO0FBQ3hDLGdCQUFnQixtQkFBTyxDQUFDLDBIQUFnQjtBQUN4QywrQkFBK0IsbUJBQU8sQ0FBQyx1S0FBa0M7QUFDekUsMkNBQTJDLG1CQUFPLENBQUMsbUhBQWtCO0FBQ3JFLCtCQUErQixtQkFBTyxDQUFDLDhFQUFNO0FBQzdDLG1CQUFtQixtQkFBTyxDQUFDLDhGQUFVO0FBQ3JDLGtCQUFrQixtQkFBTyxDQUFDLGlJQUFlO0FBQ3pDLGlCQUFpQixtQkFBTyxDQUFDLCtIQUFjO0FBQ3ZDLGdCQUFnQixtQkFBTyxDQUFDLDZIQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2RUFBNkU7QUFDN0Y7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzQkFBc0I7QUFDckQ7QUFDQTtBQUNBLHVDQUF1QyxzQ0FBc0M7QUFDN0U7QUFDQSxzQ0FBc0MsV0FBVztBQUNqRDtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsY0FBYztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLHNGQUFzRixjQUFjO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Qsd0NBQXdDLFdBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCx5REFBeUQ7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDhCQUE4QjtBQUM5RSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLDBCQUEwQixrRUFBa0U7QUFDNUYseUJBQXlCLGFBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oYWNrYXRob24tbmVhci1yZWRhY3RlZC8uL25vZGVfbW9kdWxlcy8ucG5wbS9AbmVhci1qcythY2NvdW50c0AxLjMuMS9ub2RlX21vZHVsZXMvQG5lYXItanMvYWNjb3VudHMvbGliL2NvbW1vbmpzL2NvbnRyYWN0LmNqcz80YWRjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db250cmFjdCA9IHZvaWQgMDtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG5lYXItanMvdXRpbHNcIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIkBuZWFyLWpzL3R5cGVzXCIpO1xuY29uc3QgbG9jYWxfdmlld19leGVjdXRpb25fMSA9IHJlcXVpcmUoXCIuL2xvY2FsLXZpZXctZXhlY3V0aW9uL2luZGV4LmNqc1wiKTtcbmNvbnN0IGlzX215X2pzb25fdmFsaWRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiaXMtbXktanNvbi12YWxpZFwiKSk7XG5jb25zdCBkZXBkXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlcGRcIikpO1xuY29uc3QgbmVhcl9hYmlfMSA9IHJlcXVpcmUoXCJuZWFyLWFiaVwiKTtcbmNvbnN0IGFjY291bnRfMSA9IHJlcXVpcmUoXCIuL2FjY291bnQuY2pzXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnMuY2pzXCIpO1xuY29uc3QgdXRpbHNfMiA9IHJlcXVpcmUoXCIuL3V0aWxzLmNqc1wiKTtcbi8vIE1ha2VzIGBmdW5jdGlvbi5uYW1lYCByZXR1cm4gZ2l2ZW4gbmFtZVxuZnVuY3Rpb24gbmFtZUZ1bmN0aW9uKG5hbWUsIGJvZHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBbbmFtZV0oLi4uYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIGJvZHkoLi4uYXJncyk7XG4gICAgICAgIH0sXG4gICAgfVtuYW1lXTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQXJndW1lbnRzKGFyZ3MsIGFiaUZ1bmN0aW9uLCBhYmlSb290KSB7XG4gICAgaWYgKCFpc09iamVjdChhcmdzKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChhYmlGdW5jdGlvbi5wYXJhbXMgJiZcbiAgICAgICAgYWJpRnVuY3Rpb24ucGFyYW1zLnNlcmlhbGl6YXRpb25fdHlwZSAhPT0gbmVhcl9hYmlfMS5BYmlTZXJpYWxpemF0aW9uVHlwZS5Kc29uKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbnN1cHBvcnRlZFNlcmlhbGl6YXRpb25FcnJvcihhYmlGdW5jdGlvbi5uYW1lLCBhYmlGdW5jdGlvbi5wYXJhbXMuc2VyaWFsaXphdGlvbl90eXBlKTtcbiAgICB9XG4gICAgaWYgKGFiaUZ1bmN0aW9uLnJlc3VsdCAmJlxuICAgICAgICBhYmlGdW5jdGlvbi5yZXN1bHQuc2VyaWFsaXphdGlvbl90eXBlICE9PSBuZWFyX2FiaV8xLkFiaVNlcmlhbGl6YXRpb25UeXBlLkpzb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuc3VwcG9ydGVkU2VyaWFsaXphdGlvbkVycm9yKGFiaUZ1bmN0aW9uLm5hbWUsIGFiaUZ1bmN0aW9uLnJlc3VsdC5zZXJpYWxpemF0aW9uX3R5cGUpO1xuICAgIH1cbiAgICBjb25zdCBwYXJhbXMgPSBhYmlGdW5jdGlvbi5wYXJhbXM/LmFyZ3MgfHwgW107XG4gICAgZm9yIChjb25zdCBwIG9mIHBhcmFtcykge1xuICAgICAgICBjb25zdCBhcmcgPSBhcmdzW3AubmFtZV07XG4gICAgICAgIGNvbnN0IHR5cGVTY2hlbWEgPSBwLnR5cGVfc2NoZW1hO1xuICAgICAgICB0eXBlU2NoZW1hLmRlZmluaXRpb25zID0gYWJpUm9vdC5ib2R5LnJvb3Rfc2NoZW1hLmRlZmluaXRpb25zO1xuICAgICAgICBjb25zdCB2YWxpZGF0ZSA9ICgwLCBpc19teV9qc29uX3ZhbGlkXzEuZGVmYXVsdCkodHlwZVNjaGVtYSk7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gdmFsaWRhdGUoYXJnKTtcbiAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkFyZ3VtZW50U2NoZW1hRXJyb3IocC5uYW1lLCB2YWxpZGF0ZS5lcnJvcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENoZWNrIHRoZXJlIGFyZSBubyBleHRyYSB1bmtub3duIGFyZ3VtZW50cyBwYXNzZWRcbiAgICBmb3IgKGNvbnN0IGFyZ05hbWUgb2YgT2JqZWN0LmtleXMoYXJncykpIHtcbiAgICAgICAgY29uc3QgcGFyYW0gPSBwYXJhbXMuZmluZCgocCkgPT4gcC5uYW1lID09PSBhcmdOYW1lKTtcbiAgICAgICAgaWYgKCFwYXJhbSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVua25vd25Bcmd1bWVudEVycm9yKGFyZ05hbWUsIHBhcmFtcy5tYXAoKHApID0+IHAubmFtZSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgaXNVaW50OEFycmF5ID0gKHgpID0+IHggJiYgeC5ieXRlTGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgeC5ieXRlTGVuZ3RoID09PSB4Lmxlbmd0aDtcbmNvbnN0IGlzT2JqZWN0ID0gKHgpID0+IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbi8qKlxuICogRGVmaW5lcyBhIHNtYXJ0IGNvbnRyYWN0IG9uIE5FQVIgaW5jbHVkaW5nIHRoZSBjaGFuZ2UgKG11dGFibGUpIGFuZCB2aWV3IChub24tbXV0YWJsZSkgbWV0aG9kc1xuICpcbiAqIEBzZWUgW2h0dHBzOi8vZG9jcy5uZWFyLm9yZy90b29scy9uZWFyLWFwaS1qcy9xdWljay1yZWZlcmVuY2UjY29udHJhY3RdKGh0dHBzOi8vZG9jcy5uZWFyLm9yZy90b29scy9uZWFyLWFwaS1qcy9xdWljay1yZWZlcmVuY2UjY29udHJhY3QpXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGltcG9ydCB7IENvbnRyYWN0IH0gZnJvbSAnbmVhci1hcGktanMnO1xuICpcbiAqIGFzeW5jIGZ1bmN0aW9uIGNvbnRyYWN0RXhhbXBsZSgpIHtcbiAqICAgY29uc3QgbWV0aG9kT3B0aW9ucyA9IHtcbiAqICAgICB2aWV3TWV0aG9kczogWydnZXRNZXNzYWdlQnlBY2NvdW50SWQnXSxcbiAqICAgICBjaGFuZ2VNZXRob2RzOiBbJ2FkZE1lc3NhZ2UnXVxuICogICB9O1xuICogICBjb25zdCBjb250cmFjdCA9IG5ldyBDb250cmFjdChcbiAqICAgICB3YWxsZXQuYWNjb3VudCgpLFxuICogICAgICdjb250cmFjdC1pZC50ZXN0bmV0JyxcbiAqICAgICBtZXRob2RPcHRpb25zXG4gKiAgICk7XG4gKlxuICogICAvLyB1c2UgYSBjb250cmFjdCB2aWV3IG1ldGhvZFxuICogICBjb25zdCBtZXNzYWdlcyA9IGF3YWl0IGNvbnRyYWN0LmdldE1lc3NhZ2VzKHtcbiAqICAgICBhY2NvdW50SWQ6ICdleGFtcGxlLWFjY291bnQudGVzdG5ldCdcbiAqICAgfSk7XG4gKlxuICogICAvLyB1c2UgYSBjb250cmFjdCBjaGFuZ2UgbWV0aG9kXG4gKiAgIGF3YWl0IGNvbnRyYWN0LmFkZE1lc3NhZ2Uoe1xuICogICAgICBtZXRhOiAnc29tZSBpbmZvJyxcbiAqICAgICAgY2FsbGJhY2tVcmw6ICdodHRwczovL2V4YW1wbGUuY29tL2NhbGxiYWNrJyxcbiAqICAgICAgYXJnczogeyB0ZXh0OiAnbXkgbWVzc2FnZScgfSxcbiAqICAgICAgYW1vdW50OiAxXG4gKiAgIH0pXG4gKiB9XG4gKiBgYGBcbiAqL1xuY2xhc3MgQ29udHJhY3Qge1xuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIGFjY291bnQ7XG4gICAgY29ubmVjdGlvbjtcbiAgICBjb250cmFjdElkO1xuICAgIGx2ZTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gYWNjb3VudCBORUFSIGFjY291bnQgdG8gc2lnbiBjaGFuZ2UgbWV0aG9kIHRyYW5zYWN0aW9uc1xuICAgICAqIEBwYXJhbSBjb250cmFjdElkIE5FQVIgYWNjb3VudCBpZCB3aGVyZSB0aGUgY29udHJhY3QgaXMgZGVwbG95ZWRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBORUFSIHNtYXJ0IGNvbnRyYWN0IG1ldGhvZHMgdGhhdCB5b3VyIGFwcGxpY2F0aW9uIHdpbGwgdXNlLiBUaGVzZSB3aWxsIGJlIGF2YWlsYWJsZSBhcyBgY29udHJhY3QubWV0aG9kTmFtZWBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uLCBjb250cmFjdElkLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb24uZ2V0Q29ubmVjdGlvbigpO1xuICAgICAgICBpZiAoY29ubmVjdGlvbiBpbnN0YW5jZW9mIGFjY291bnRfMS5BY2NvdW50KSB7XG4gICAgICAgICAgICBjb25zdCBkZXByZWNhdGUgPSAoMCwgZGVwZF8xLmRlZmF1bHQpKFwibmV3IENvbnRyYWN0KGFjY291bnQsIGNvbnRyYWN0SWQsIG9wdGlvbnMpXCIpO1xuICAgICAgICAgICAgZGVwcmVjYXRlKFwidXNlIGBuZXcgQ29udHJhY3QoY29ubmVjdGlvbiwgY29udHJhY3RJZCwgb3B0aW9ucylgIGluc3RlYWRcIik7XG4gICAgICAgICAgICB0aGlzLmFjY291bnQgPSBjb25uZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29udHJhY3RJZCA9IGNvbnRyYWN0SWQ7XG4gICAgICAgIHRoaXMubHZlID0gbmV3IGxvY2FsX3ZpZXdfZXhlY3V0aW9uXzEuTG9jYWxWaWV3RXhlY3V0aW9uKGNvbm5lY3Rpb24pO1xuICAgICAgICBjb25zdCB7IHZpZXdNZXRob2RzID0gW10sIGNoYW5nZU1ldGhvZHMgPSBbXSwgYWJpOiBhYmlSb290LCB1c2VMb2NhbFZpZXdFeGVjdXRpb24sIH0gPSBvcHRpb25zO1xuICAgICAgICBsZXQgdmlld01ldGhvZHNXaXRoQWJpID0gdmlld01ldGhvZHMubWFwKChuYW1lKSA9PiAoe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGFiaTogbnVsbCxcbiAgICAgICAgfSkpO1xuICAgICAgICBsZXQgY2hhbmdlTWV0aG9kc1dpdGhBYmkgPSBjaGFuZ2VNZXRob2RzLm1hcCgobmFtZSkgPT4gKHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBhYmk6IG51bGwsXG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYgKGFiaVJvb3QpIHtcbiAgICAgICAgICAgIGlmICh2aWV3TWV0aG9kc1dpdGhBYmkubGVuZ3RoID4gMCB8fFxuICAgICAgICAgICAgICAgIGNoYW5nZU1ldGhvZHNXaXRoQWJpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQ29uZmxpY3RpbmdPcHRpb25zKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2aWV3TWV0aG9kc1dpdGhBYmkgPSBhYmlSb290LmJvZHkuZnVuY3Rpb25zXG4gICAgICAgICAgICAgICAgLmZpbHRlcigobSkgPT4gbS5raW5kID09PSBuZWFyX2FiaV8xLkFiaUZ1bmN0aW9uS2luZC5WaWV3KVxuICAgICAgICAgICAgICAgIC5tYXAoKG0pID0+ICh7IG5hbWU6IG0ubmFtZSwgYWJpOiBtIH0pKTtcbiAgICAgICAgICAgIGNoYW5nZU1ldGhvZHNXaXRoQWJpID0gYWJpUm9vdC5ib2R5LmZ1bmN0aW9uc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoKG1ldGhvZEFiaSkgPT4gbWV0aG9kQWJpLmtpbmQgPT09IG5lYXJfYWJpXzEuQWJpRnVuY3Rpb25LaW5kLkNhbGwpXG4gICAgICAgICAgICAgICAgLm1hcCgobWV0aG9kQWJpKSA9PiAoeyBuYW1lOiBtZXRob2RBYmkubmFtZSwgYWJpOiBtZXRob2RBYmkgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHZpZXdNZXRob2RzV2l0aEFiaS5mb3JFYWNoKCh7IG5hbWUsIGFiaSB9KSA9PiB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgbmFtZSwge1xuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBuYW1lRnVuY3Rpb24obmFtZSwgYXN5bmMgKGFyZ3MgPSB7fSwgb3B0aW9ucyA9IHt9LCAuLi5pZ25vcmVkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpZ25vcmVkLmxlbmd0aCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIShpc09iamVjdChhcmdzKSB8fCBpc1VpbnQ4QXJyYXkoYXJncykpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAhaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyB0eXBlc18xLlBvc2l0aW9uYWxBcmdzRXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWJpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUFyZ3VtZW50cyhhcmdzLCBhYmksIGFiaVJvb3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh1c2VMb2NhbFZpZXdFeGVjdXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubHZlLnZpZXdGdW5jdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0SWQ6IHRoaXMuY29udHJhY3RJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kTmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxzXzEuTG9nZ2VyLndhcm4oYExvY2FsIHZpZXcgZXhlY3V0aW9uIGZhaWxlZCB3aXRoOiBcIiR7ZXJyb3IubWVzc2FnZX1cImApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxzXzEuTG9nZ2VyLndhcm4oYEZhbGxiYWNrIHRvIG5vcm1hbCBSUEMgY2FsbGApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFjY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFjY291bnQudmlld0Z1bmN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cmFjdElkOiB0aGlzLmNvbnRyYWN0SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kTmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzIudmlld0Z1bmN0aW9uKSh0aGlzLmNvbm5lY3Rpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0SWQ6IHRoaXMuY29udHJhY3RJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZE5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNoYW5nZU1ldGhvZHNXaXRoQWJpLmZvckVhY2goKHsgbmFtZSwgYWJpIH0pID0+IHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBuYW1lLCB7XG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG5hbWVGdW5jdGlvbihuYW1lLCBhc3luYyAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChhcmdzLmxlbmd0aCA+IDMgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhKGlzT2JqZWN0KGFyZ3NbMF0pIHx8IGlzVWludDhBcnJheShhcmdzWzBdKSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgdHlwZXNfMS5Qb3NpdGlvbmFsQXJnc0Vycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMSB8fCAhKGFyZ3NbMF0gJiYgYXJnc1swXS5hcmdzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVwcmVjYXRlID0gKDAsIGRlcGRfMS5kZWZhdWx0KShcImNvbnRyYWN0Lm1ldGhvZE5hbWUoYXJncywgZ2FzLCBhbW91bnQpXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVwcmVjYXRlKFwidXNlIGBjb250cmFjdC5tZXRob2ROYW1lKHsgc2lnbmVyQWNjb3VudCwgYXJncywgZ2FzPywgYW1vdW50PywgY2FsbGJhY2tVcmw/LCBtZXRhPyB9KWAgaW5zdGVhZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbMF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogYXJnc1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYXM6IGFyZ3NbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW1vdW50OiBhcmdzWzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWJpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUFyZ3VtZW50cyhhcmdzWzBdLmFyZ3MsIGFiaSwgYWJpUm9vdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoYW5nZU1ldGhvZCh7IG1ldGhvZE5hbWU6IG5hbWUsIC4uLmFyZ3NbMF0gfSk7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9jaGFuZ2VNZXRob2QoeyBzaWduZXJBY2NvdW50LCBhcmdzLCBtZXRob2ROYW1lLCBnYXMsIGFtb3VudCwgbWV0YSwgY2FsbGJhY2tVcmwsIH0pIHtcbiAgICAgICAgdmFsaWRhdGVCTkxpa2UoeyBnYXMsIGFtb3VudCB9KTtcbiAgICAgICAgY29uc3QgYWNjb3VudCA9IHRoaXMuYWNjb3VudCB8fCBzaWduZXJBY2NvdW50O1xuICAgICAgICBpZiAoIWFjY291bnQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHNpZ25lckFjY291bnQgbXVzdCBiZSBzcGVjaWZpZWRgKTtcbiAgICAgICAgY29uc3QgcmF3UmVzdWx0ID0gYXdhaXQgYWNjb3VudC5mdW5jdGlvbkNhbGwoe1xuICAgICAgICAgICAgY29udHJhY3RJZDogdGhpcy5jb250cmFjdElkLFxuICAgICAgICAgICAgbWV0aG9kTmFtZSxcbiAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICBnYXMsXG4gICAgICAgICAgICBhdHRhY2hlZERlcG9zaXQ6IGFtb3VudCxcbiAgICAgICAgICAgIHdhbGxldE1ldGE6IG1ldGEsXG4gICAgICAgICAgICB3YWxsZXRDYWxsYmFja1VybDogY2FsbGJhY2tVcmwsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEuZ2V0VHJhbnNhY3Rpb25MYXN0UmVzdWx0KShyYXdSZXN1bHQpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29udHJhY3QgPSBDb250cmFjdDtcbi8qKlxuICogVGhyb3dzIGlmIGFuIGFyZ3VtZW50IGlzIG5vdCBpbiBCaWdJbnQgZm9ybWF0IG9yIG90aGVyd2lzZSBpbnZhbGlkXG4gKiBAcGFyYW0gYXJnTWFwXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQk5MaWtlKGFyZ01hcCkge1xuICAgIGNvbnN0IGJuTGlrZSA9IFwibnVtYmVyLCBkZWNpbWFsIHN0cmluZyBvciBCaWdJbnRcIjtcbiAgICBmb3IgKGNvbnN0IGFyZ05hbWUgb2YgT2JqZWN0LmtleXMoYXJnTWFwKSkge1xuICAgICAgICBjb25zdCBhcmdWYWx1ZSA9IGFyZ01hcFthcmdOYW1lXTtcbiAgICAgICAgaWYgKGFyZ1ZhbHVlICYmIHR5cGVvZiBhcmdWYWx1ZSAhPT0gXCJiaWdpbnRcIiAmJiBpc05hTihhcmdWYWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyB0eXBlc18xLkFyZ3VtZW50VHlwZUVycm9yKGFyZ05hbWUsIGJuTGlrZSwgYXJnVmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/contract.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/errors.cjs":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/errors.cjs ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConflictingOptions = exports.ArgumentSchemaError = exports.UnknownArgumentError = exports.UnsupportedSerializationError = void 0;\nclass UnsupportedSerializationError extends Error {\n    constructor(methodName, serializationType) {\n        super(`Contract method '${methodName}' is using an unsupported serialization type ${serializationType}`);\n    }\n}\nexports.UnsupportedSerializationError = UnsupportedSerializationError;\nclass UnknownArgumentError extends Error {\n    constructor(actualArgName, expectedArgNames) {\n        super(`Unrecognized argument '${actualArgName}', expected '${JSON.stringify(expectedArgNames)}'`);\n    }\n}\nexports.UnknownArgumentError = UnknownArgumentError;\nclass ArgumentSchemaError extends Error {\n    constructor(argName, errors) {\n        super(`Argument '${argName}' does not conform to the specified ABI schema: '${JSON.stringify(errors)}'`);\n    }\n}\nexports.ArgumentSchemaError = ArgumentSchemaError;\nclass ConflictingOptions extends Error {\n    constructor() {\n        super('Conflicting contract method options have been passed. You can either specify ABI or a list of view/call methods.');\n    }\n}\nexports.ConflictingOptions = ConflictingOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMS4zLjEvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9jb21tb25qcy9lcnJvcnMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQixHQUFHLDJCQUEyQixHQUFHLDRCQUE0QixHQUFHLHFDQUFxQztBQUMvSDtBQUNBO0FBQ0Esa0NBQWtDLFdBQVcsK0NBQStDLGtCQUFrQjtBQUM5RztBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYyxlQUFlLGlDQUFpQztBQUN0RztBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSwyQkFBMkIsUUFBUSxtREFBbUQsdUJBQXVCO0FBQzdHO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiIsInNvdXJjZXMiOlsid2VicGFjazovL2hhY2thdGhvbi1uZWFyLXJlZGFjdGVkLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BuZWFyLWpzK2FjY291bnRzQDEuMy4xL25vZGVfbW9kdWxlcy9AbmVhci1qcy9hY2NvdW50cy9saWIvY29tbW9uanMvZXJyb3JzLmNqcz81ZGExIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db25mbGljdGluZ09wdGlvbnMgPSBleHBvcnRzLkFyZ3VtZW50U2NoZW1hRXJyb3IgPSBleHBvcnRzLlVua25vd25Bcmd1bWVudEVycm9yID0gZXhwb3J0cy5VbnN1cHBvcnRlZFNlcmlhbGl6YXRpb25FcnJvciA9IHZvaWQgMDtcbmNsYXNzIFVuc3VwcG9ydGVkU2VyaWFsaXphdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZE5hbWUsIHNlcmlhbGl6YXRpb25UeXBlKSB7XG4gICAgICAgIHN1cGVyKGBDb250cmFjdCBtZXRob2QgJyR7bWV0aG9kTmFtZX0nIGlzIHVzaW5nIGFuIHVuc3VwcG9ydGVkIHNlcmlhbGl6YXRpb24gdHlwZSAke3NlcmlhbGl6YXRpb25UeXBlfWApO1xuICAgIH1cbn1cbmV4cG9ydHMuVW5zdXBwb3J0ZWRTZXJpYWxpemF0aW9uRXJyb3IgPSBVbnN1cHBvcnRlZFNlcmlhbGl6YXRpb25FcnJvcjtcbmNsYXNzIFVua25vd25Bcmd1bWVudEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGFjdHVhbEFyZ05hbWUsIGV4cGVjdGVkQXJnTmFtZXMpIHtcbiAgICAgICAgc3VwZXIoYFVucmVjb2duaXplZCBhcmd1bWVudCAnJHthY3R1YWxBcmdOYW1lfScsIGV4cGVjdGVkICcke0pTT04uc3RyaW5naWZ5KGV4cGVjdGVkQXJnTmFtZXMpfSdgKTtcbiAgICB9XG59XG5leHBvcnRzLlVua25vd25Bcmd1bWVudEVycm9yID0gVW5rbm93bkFyZ3VtZW50RXJyb3I7XG5jbGFzcyBBcmd1bWVudFNjaGVtYUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGFyZ05hbWUsIGVycm9ycykge1xuICAgICAgICBzdXBlcihgQXJndW1lbnQgJyR7YXJnTmFtZX0nIGRvZXMgbm90IGNvbmZvcm0gdG8gdGhlIHNwZWNpZmllZCBBQkkgc2NoZW1hOiAnJHtKU09OLnN0cmluZ2lmeShlcnJvcnMpfSdgKTtcbiAgICB9XG59XG5leHBvcnRzLkFyZ3VtZW50U2NoZW1hRXJyb3IgPSBBcmd1bWVudFNjaGVtYUVycm9yO1xuY2xhc3MgQ29uZmxpY3RpbmdPcHRpb25zIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignQ29uZmxpY3RpbmcgY29udHJhY3QgbWV0aG9kIG9wdGlvbnMgaGF2ZSBiZWVuIHBhc3NlZC4gWW91IGNhbiBlaXRoZXIgc3BlY2lmeSBBQkkgb3IgYSBsaXN0IG9mIHZpZXcvY2FsbCBtZXRob2RzLicpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29uZmxpY3RpbmdPcHRpb25zID0gQ29uZmxpY3RpbmdPcHRpb25zO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/errors.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/index.cjs":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/index.cjs ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MultisigStateStatus = exports.MultisigDeleteRequestRejectionError = exports.UnsupportedSerializationError = exports.UnknownArgumentError = exports.ConflictingOptions = exports.ArgumentSchemaError = exports.Contract = exports.MULTISIG_CONFIRM_METHODS = exports.MULTISIG_CHANGE_METHODS = exports.MULTISIG_DEPOSIT = exports.MULTISIG_GAS = exports.MULTISIG_ALLOWANCE = exports.MULTISIG_STORAGE_KEY = exports.Connection = exports.AccountMultisig = exports.UrlAccountCreator = exports.LocalAccountCreator = exports.AccountCreator = exports.Account2FA = exports.Account = void 0;\nvar account_1 = __webpack_require__(/*! ./account.cjs */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/account.cjs\");\nObject.defineProperty(exports, \"Account\", ({ enumerable: true, get: function () { return account_1.Account; } }));\nvar account_2fa_1 = __webpack_require__(/*! ./account_2fa.cjs */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/account_2fa.cjs\");\nObject.defineProperty(exports, \"Account2FA\", ({ enumerable: true, get: function () { return account_2fa_1.Account2FA; } }));\nvar account_creator_1 = __webpack_require__(/*! ./account_creator.cjs */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/account_creator.cjs\");\nObject.defineProperty(exports, \"AccountCreator\", ({ enumerable: true, get: function () { return account_creator_1.AccountCreator; } }));\nObject.defineProperty(exports, \"LocalAccountCreator\", ({ enumerable: true, get: function () { return account_creator_1.LocalAccountCreator; } }));\nObject.defineProperty(exports, \"UrlAccountCreator\", ({ enumerable: true, get: function () { return account_creator_1.UrlAccountCreator; } }));\nvar account_multisig_1 = __webpack_require__(/*! ./account_multisig.cjs */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/account_multisig.cjs\");\nObject.defineProperty(exports, \"AccountMultisig\", ({ enumerable: true, get: function () { return account_multisig_1.AccountMultisig; } }));\nvar connection_1 = __webpack_require__(/*! ./connection.cjs */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/connection.cjs\");\nObject.defineProperty(exports, \"Connection\", ({ enumerable: true, get: function () { return connection_1.Connection; } }));\nvar constants_1 = __webpack_require__(/*! ./constants.cjs */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/constants.cjs\");\nObject.defineProperty(exports, \"MULTISIG_STORAGE_KEY\", ({ enumerable: true, get: function () { return constants_1.MULTISIG_STORAGE_KEY; } }));\nObject.defineProperty(exports, \"MULTISIG_ALLOWANCE\", ({ enumerable: true, get: function () { return constants_1.MULTISIG_ALLOWANCE; } }));\nObject.defineProperty(exports, \"MULTISIG_GAS\", ({ enumerable: true, get: function () { return constants_1.MULTISIG_GAS; } }));\nObject.defineProperty(exports, \"MULTISIG_DEPOSIT\", ({ enumerable: true, get: function () { return constants_1.MULTISIG_DEPOSIT; } }));\nObject.defineProperty(exports, \"MULTISIG_CHANGE_METHODS\", ({ enumerable: true, get: function () { return constants_1.MULTISIG_CHANGE_METHODS; } }));\nObject.defineProperty(exports, \"MULTISIG_CONFIRM_METHODS\", ({ enumerable: true, get: function () { return constants_1.MULTISIG_CONFIRM_METHODS; } }));\nvar contract_1 = __webpack_require__(/*! ./contract.cjs */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/contract.cjs\");\nObject.defineProperty(exports, \"Contract\", ({ enumerable: true, get: function () { return contract_1.Contract; } }));\nvar errors_1 = __webpack_require__(/*! ./errors.cjs */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/errors.cjs\");\nObject.defineProperty(exports, \"ArgumentSchemaError\", ({ enumerable: true, get: function () { return errors_1.ArgumentSchemaError; } }));\nObject.defineProperty(exports, \"ConflictingOptions\", ({ enumerable: true, get: function () { return errors_1.ConflictingOptions; } }));\nObject.defineProperty(exports, \"UnknownArgumentError\", ({ enumerable: true, get: function () { return errors_1.UnknownArgumentError; } }));\nObject.defineProperty(exports, \"UnsupportedSerializationError\", ({ enumerable: true, get: function () { return errors_1.UnsupportedSerializationError; } }));\nvar types_1 = __webpack_require__(/*! ./types.cjs */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/types.cjs\");\nObject.defineProperty(exports, \"MultisigDeleteRequestRejectionError\", ({ enumerable: true, get: function () { return types_1.MultisigDeleteRequestRejectionError; } }));\nObject.defineProperty(exports, \"MultisigStateStatus\", ({ enumerable: true, get: function () { return types_1.MultisigStateStatus; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMS4zLjEvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9jb21tb25qcy9pbmRleC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCLEdBQUcsMkNBQTJDLEdBQUcscUNBQXFDLEdBQUcsNEJBQTRCLEdBQUcsMEJBQTBCLEdBQUcsMkJBQTJCLEdBQUcsZ0JBQWdCLEdBQUcsZ0NBQWdDLEdBQUcsK0JBQStCLEdBQUcsd0JBQXdCLEdBQUcsb0JBQW9CLEdBQUcsMEJBQTBCLEdBQUcsNEJBQTRCLEdBQUcsa0JBQWtCLEdBQUcsdUJBQXVCLEdBQUcseUJBQXlCLEdBQUcsMkJBQTJCLEdBQUcsc0JBQXNCLEdBQUcsa0JBQWtCLEdBQUcsZUFBZTtBQUMxakIsZ0JBQWdCLG1CQUFPLENBQUMsaUlBQWU7QUFDdkMsMkNBQTBDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQy9HLG9CQUFvQixtQkFBTyxDQUFDLHlJQUFtQjtBQUMvQyw4Q0FBNkMsRUFBRSxxQ0FBcUMsb0NBQW9DLEVBQUM7QUFDekgsd0JBQXdCLG1CQUFPLENBQUMsaUpBQXVCO0FBQ3ZELGtEQUFpRCxFQUFFLHFDQUFxQyw0Q0FBNEMsRUFBQztBQUNySSx1REFBc0QsRUFBRSxxQ0FBcUMsaURBQWlELEVBQUM7QUFDL0kscURBQW9ELEVBQUUscUNBQXFDLCtDQUErQyxFQUFDO0FBQzNJLHlCQUF5QixtQkFBTyxDQUFDLG1KQUF3QjtBQUN6RCxtREFBa0QsRUFBRSxxQ0FBcUMsOENBQThDLEVBQUM7QUFDeEksbUJBQW1CLG1CQUFPLENBQUMsdUlBQWtCO0FBQzdDLDhDQUE2QyxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUN4SCxrQkFBa0IsbUJBQU8sQ0FBQyxxSUFBaUI7QUFDM0Msd0RBQXVELEVBQUUscUNBQXFDLDRDQUE0QyxFQUFDO0FBQzNJLHNEQUFxRCxFQUFFLHFDQUFxQywwQ0FBMEMsRUFBQztBQUN2SSxnREFBK0MsRUFBRSxxQ0FBcUMsb0NBQW9DLEVBQUM7QUFDM0gsb0RBQW1ELEVBQUUscUNBQXFDLHdDQUF3QyxFQUFDO0FBQ25JLDJEQUEwRCxFQUFFLHFDQUFxQywrQ0FBK0MsRUFBQztBQUNqSiw0REFBMkQsRUFBRSxxQ0FBcUMsZ0RBQWdELEVBQUM7QUFDbkosaUJBQWlCLG1CQUFPLENBQUMsbUlBQWdCO0FBQ3pDLDRDQUEyQyxFQUFFLHFDQUFxQywrQkFBK0IsRUFBQztBQUNsSCxlQUFlLG1CQUFPLENBQUMsK0hBQWM7QUFDckMsdURBQXNELEVBQUUscUNBQXFDLHdDQUF3QyxFQUFDO0FBQ3RJLHNEQUFxRCxFQUFFLHFDQUFxQyx1Q0FBdUMsRUFBQztBQUNwSSx3REFBdUQsRUFBRSxxQ0FBcUMseUNBQXlDLEVBQUM7QUFDeEksaUVBQWdFLEVBQUUscUNBQXFDLGtEQUFrRCxFQUFDO0FBQzFKLGNBQWMsbUJBQU8sQ0FBQyw2SEFBYTtBQUNuQyx1RUFBc0UsRUFBRSxxQ0FBcUMsdURBQXVELEVBQUM7QUFDckssdURBQXNELEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGFja2F0aG9uLW5lYXItcmVkYWN0ZWQvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMS4zLjEvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9jb21tb25qcy9pbmRleC5janM/MmUyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTXVsdGlzaWdTdGF0ZVN0YXR1cyA9IGV4cG9ydHMuTXVsdGlzaWdEZWxldGVSZXF1ZXN0UmVqZWN0aW9uRXJyb3IgPSBleHBvcnRzLlVuc3VwcG9ydGVkU2VyaWFsaXphdGlvbkVycm9yID0gZXhwb3J0cy5Vbmtub3duQXJndW1lbnRFcnJvciA9IGV4cG9ydHMuQ29uZmxpY3RpbmdPcHRpb25zID0gZXhwb3J0cy5Bcmd1bWVudFNjaGVtYUVycm9yID0gZXhwb3J0cy5Db250cmFjdCA9IGV4cG9ydHMuTVVMVElTSUdfQ09ORklSTV9NRVRIT0RTID0gZXhwb3J0cy5NVUxUSVNJR19DSEFOR0VfTUVUSE9EUyA9IGV4cG9ydHMuTVVMVElTSUdfREVQT1NJVCA9IGV4cG9ydHMuTVVMVElTSUdfR0FTID0gZXhwb3J0cy5NVUxUSVNJR19BTExPV0FOQ0UgPSBleHBvcnRzLk1VTFRJU0lHX1NUT1JBR0VfS0VZID0gZXhwb3J0cy5Db25uZWN0aW9uID0gZXhwb3J0cy5BY2NvdW50TXVsdGlzaWcgPSBleHBvcnRzLlVybEFjY291bnRDcmVhdG9yID0gZXhwb3J0cy5Mb2NhbEFjY291bnRDcmVhdG9yID0gZXhwb3J0cy5BY2NvdW50Q3JlYXRvciA9IGV4cG9ydHMuQWNjb3VudDJGQSA9IGV4cG9ydHMuQWNjb3VudCA9IHZvaWQgMDtcbnZhciBhY2NvdW50XzEgPSByZXF1aXJlKFwiLi9hY2NvdW50LmNqc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFjY291bnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFjY291bnRfMS5BY2NvdW50OyB9IH0pO1xudmFyIGFjY291bnRfMmZhXzEgPSByZXF1aXJlKFwiLi9hY2NvdW50XzJmYS5janNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBY2NvdW50MkZBXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhY2NvdW50XzJmYV8xLkFjY291bnQyRkE7IH0gfSk7XG52YXIgYWNjb3VudF9jcmVhdG9yXzEgPSByZXF1aXJlKFwiLi9hY2NvdW50X2NyZWF0b3IuY2pzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQWNjb3VudENyZWF0b3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFjY291bnRfY3JlYXRvcl8xLkFjY291bnRDcmVhdG9yOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTG9jYWxBY2NvdW50Q3JlYXRvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWNjb3VudF9jcmVhdG9yXzEuTG9jYWxBY2NvdW50Q3JlYXRvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVybEFjY291bnRDcmVhdG9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhY2NvdW50X2NyZWF0b3JfMS5VcmxBY2NvdW50Q3JlYXRvcjsgfSB9KTtcbnZhciBhY2NvdW50X211bHRpc2lnXzEgPSByZXF1aXJlKFwiLi9hY2NvdW50X211bHRpc2lnLmNqc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFjY291bnRNdWx0aXNpZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWNjb3VudF9tdWx0aXNpZ18xLkFjY291bnRNdWx0aXNpZzsgfSB9KTtcbnZhciBjb25uZWN0aW9uXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aW9uLmNqc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbm5lY3Rpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5Db25uZWN0aW9uOyB9IH0pO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzLmNqc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1VTFRJU0lHX1NUT1JBR0VfS0VZXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25zdGFudHNfMS5NVUxUSVNJR19TVE9SQUdFX0tFWTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1VTFRJU0lHX0FMTE9XQU5DRVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uc3RhbnRzXzEuTVVMVElTSUdfQUxMT1dBTkNFOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTVVMVElTSUdfR0FTXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25zdGFudHNfMS5NVUxUSVNJR19HQVM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNVUxUSVNJR19ERVBPU0lUXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25zdGFudHNfMS5NVUxUSVNJR19ERVBPU0lUOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTVVMVElTSUdfQ0hBTkdFX01FVEhPRFNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnN0YW50c18xLk1VTFRJU0lHX0NIQU5HRV9NRVRIT0RTOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTVVMVElTSUdfQ09ORklSTV9NRVRIT0RTXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25zdGFudHNfMS5NVUxUSVNJR19DT05GSVJNX01FVEhPRFM7IH0gfSk7XG52YXIgY29udHJhY3RfMSA9IHJlcXVpcmUoXCIuL2NvbnRyYWN0LmNqc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbnRyYWN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb250cmFjdF8xLkNvbnRyYWN0OyB9IH0pO1xudmFyIGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzLmNqc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFyZ3VtZW50U2NoZW1hRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yc18xLkFyZ3VtZW50U2NoZW1hRXJyb3I7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb25mbGljdGluZ09wdGlvbnNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yc18xLkNvbmZsaWN0aW5nT3B0aW9uczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVua25vd25Bcmd1bWVudEVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvcnNfMS5Vbmtub3duQXJndW1lbnRFcnJvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVuc3VwcG9ydGVkU2VyaWFsaXphdGlvbkVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvcnNfMS5VbnN1cHBvcnRlZFNlcmlhbGl6YXRpb25FcnJvcjsgfSB9KTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXMuY2pzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTXVsdGlzaWdEZWxldGVSZXF1ZXN0UmVqZWN0aW9uRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVzXzEuTXVsdGlzaWdEZWxldGVSZXF1ZXN0UmVqZWN0aW9uRXJyb3I7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNdWx0aXNpZ1N0YXRlU3RhdHVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlc18xLk11bHRpc2lnU3RhdGVTdGF0dXM7IH0gfSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/index.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/local-view-execution/index.cjs":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/local-view-execution/index.cjs ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LocalViewExecution = void 0;\nconst utils_1 = __webpack_require__(/*! @near-js/utils */ \"(ssr)/./node_modules/.pnpm/@near-js+utils@1.0.1/node_modules/@near-js/utils/lib/commonjs/index.cjs\");\nconst storage_1 = __webpack_require__(/*! ./storage.cjs */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/local-view-execution/storage.cjs\");\nconst runtime_1 = __webpack_require__(/*! ./runtime.cjs */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/local-view-execution/runtime.cjs\");\nconst utils_2 = __webpack_require__(/*! ../utils.cjs */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/utils.cjs\");\nclass LocalViewExecution {\n    connection;\n    storage;\n    constructor(connection) {\n        this.connection = connection.getConnection();\n        this.storage = new storage_1.Storage();\n    }\n    async fetchContractCode(contractId, blockQuery) {\n        const result = await this.connection.provider.query({\n            request_type: 'view_code',\n            account_id: contractId,\n            ...blockQuery,\n        });\n        return result.code_base64;\n    }\n    async fetchContractState(contractId, blockQuery) {\n        return (0, utils_2.viewState)(this.connection, contractId, '', blockQuery);\n    }\n    async fetch(contractId, blockQuery) {\n        const block = await this.connection.provider.block(blockQuery);\n        const blockHash = block.header.hash;\n        const blockHeight = block.header.height;\n        const blockTimestamp = block.header.timestamp;\n        const contractCode = await this.fetchContractCode(contractId, blockQuery);\n        const contractState = await this.fetchContractState(contractId, blockQuery);\n        return {\n            blockHash,\n            blockHeight,\n            blockTimestamp,\n            contractCode,\n            contractState,\n        };\n    }\n    async loadOrFetch(contractId, blockQuery) {\n        const stored = this.storage.load(blockQuery);\n        if (stored) {\n            return stored;\n        }\n        const { blockHash, ...fetched } = await this.fetch(contractId, blockQuery);\n        this.storage.save(blockHash, fetched);\n        return fetched;\n    }\n    /**\n     * Calls a view function on a contract, fetching the contract code and state if needed.\n     * @param options Options for calling the view function.\n     * @param options.contractId The contract account ID.\n     * @param options.methodName The name of the view function to call.\n     * @param options.args The arguments to pass to the view function.\n     * @param options.blockQuery The block query options.\n     * @returns {Promise<any>} - A promise that resolves to the result of the view function.\n     */\n    async viewFunction({ contractId, methodName, args = {}, blockQuery = { finality: 'optimistic' } }) {\n        const methodArgs = JSON.stringify(args);\n        const { contractCode, contractState, blockHeight, blockTimestamp } = await this.loadOrFetch(contractId, blockQuery);\n        const runtime = new runtime_1.Runtime({ contractId, contractCode, contractState, blockHeight, blockTimestamp, methodArgs });\n        const { result, logs } = await runtime.execute(methodName);\n        if (logs) {\n            (0, utils_1.printTxOutcomeLogs)({ contractId, logs });\n        }\n        return JSON.parse(Buffer.from(result).toString());\n    }\n}\nexports.LocalViewExecution = LocalViewExecution;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMS4zLjEvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9jb21tb25qcy9sb2NhbC12aWV3LWV4ZWN1dGlvbi9pbmRleC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCO0FBQzFCLGdCQUFnQixtQkFBTyxDQUFDLDBIQUFnQjtBQUN4QyxrQkFBa0IsbUJBQU8sQ0FBQyxzSkFBZTtBQUN6QyxrQkFBa0IsbUJBQU8sQ0FBQyxzSkFBZTtBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQyw4SEFBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0JBQXdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQSx5QkFBeUIsaUNBQWlDLGlCQUFpQiwwQkFBMEI7QUFDckc7QUFDQSxnQkFBZ0IsMkRBQTJEO0FBQzNFLGdEQUFnRCxrRkFBa0Y7QUFDbEksZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQSw4Q0FBOEMsa0JBQWtCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGFja2F0aG9uLW5lYXItcmVkYWN0ZWQvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMS4zLjEvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9jb21tb25qcy9sb2NhbC12aWV3LWV4ZWN1dGlvbi9pbmRleC5janM/Y2Q4NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTG9jYWxWaWV3RXhlY3V0aW9uID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbmVhci1qcy91dGlsc1wiKTtcbmNvbnN0IHN0b3JhZ2VfMSA9IHJlcXVpcmUoXCIuL3N0b3JhZ2UuY2pzXCIpO1xuY29uc3QgcnVudGltZV8xID0gcmVxdWlyZShcIi4vcnVudGltZS5janNcIik7XG5jb25zdCB1dGlsc18yID0gcmVxdWlyZShcIi4uL3V0aWxzLmNqc1wiKTtcbmNsYXNzIExvY2FsVmlld0V4ZWN1dGlvbiB7XG4gICAgY29ubmVjdGlvbjtcbiAgICBzdG9yYWdlO1xuICAgIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gY29ubmVjdGlvbi5nZXRDb25uZWN0aW9uKCk7XG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IG5ldyBzdG9yYWdlXzEuU3RvcmFnZSgpO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaENvbnRyYWN0Q29kZShjb250cmFjdElkLCBibG9ja1F1ZXJ5KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuY29ubmVjdGlvbi5wcm92aWRlci5xdWVyeSh7XG4gICAgICAgICAgICByZXF1ZXN0X3R5cGU6ICd2aWV3X2NvZGUnLFxuICAgICAgICAgICAgYWNjb3VudF9pZDogY29udHJhY3RJZCxcbiAgICAgICAgICAgIC4uLmJsb2NrUXVlcnksXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0LmNvZGVfYmFzZTY0O1xuICAgIH1cbiAgICBhc3luYyBmZXRjaENvbnRyYWN0U3RhdGUoY29udHJhY3RJZCwgYmxvY2tRdWVyeSkge1xuICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzIudmlld1N0YXRlKSh0aGlzLmNvbm5lY3Rpb24sIGNvbnRyYWN0SWQsICcnLCBibG9ja1F1ZXJ5KTtcbiAgICB9XG4gICAgYXN5bmMgZmV0Y2goY29udHJhY3RJZCwgYmxvY2tRdWVyeSkge1xuICAgICAgICBjb25zdCBibG9jayA9IGF3YWl0IHRoaXMuY29ubmVjdGlvbi5wcm92aWRlci5ibG9jayhibG9ja1F1ZXJ5KTtcbiAgICAgICAgY29uc3QgYmxvY2tIYXNoID0gYmxvY2suaGVhZGVyLmhhc2g7XG4gICAgICAgIGNvbnN0IGJsb2NrSGVpZ2h0ID0gYmxvY2suaGVhZGVyLmhlaWdodDtcbiAgICAgICAgY29uc3QgYmxvY2tUaW1lc3RhbXAgPSBibG9jay5oZWFkZXIudGltZXN0YW1wO1xuICAgICAgICBjb25zdCBjb250cmFjdENvZGUgPSBhd2FpdCB0aGlzLmZldGNoQ29udHJhY3RDb2RlKGNvbnRyYWN0SWQsIGJsb2NrUXVlcnkpO1xuICAgICAgICBjb25zdCBjb250cmFjdFN0YXRlID0gYXdhaXQgdGhpcy5mZXRjaENvbnRyYWN0U3RhdGUoY29udHJhY3RJZCwgYmxvY2tRdWVyeSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBibG9ja0hhc2gsXG4gICAgICAgICAgICBibG9ja0hlaWdodCxcbiAgICAgICAgICAgIGJsb2NrVGltZXN0YW1wLFxuICAgICAgICAgICAgY29udHJhY3RDb2RlLFxuICAgICAgICAgICAgY29udHJhY3RTdGF0ZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgbG9hZE9yRmV0Y2goY29udHJhY3RJZCwgYmxvY2tRdWVyeSkge1xuICAgICAgICBjb25zdCBzdG9yZWQgPSB0aGlzLnN0b3JhZ2UubG9hZChibG9ja1F1ZXJ5KTtcbiAgICAgICAgaWYgKHN0b3JlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0b3JlZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGJsb2NrSGFzaCwgLi4uZmV0Y2hlZCB9ID0gYXdhaXQgdGhpcy5mZXRjaChjb250cmFjdElkLCBibG9ja1F1ZXJ5KTtcbiAgICAgICAgdGhpcy5zdG9yYWdlLnNhdmUoYmxvY2tIYXNoLCBmZXRjaGVkKTtcbiAgICAgICAgcmV0dXJuIGZldGNoZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxzIGEgdmlldyBmdW5jdGlvbiBvbiBhIGNvbnRyYWN0LCBmZXRjaGluZyB0aGUgY29udHJhY3QgY29kZSBhbmQgc3RhdGUgaWYgbmVlZGVkLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgZm9yIGNhbGxpbmcgdGhlIHZpZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIG9wdGlvbnMuY29udHJhY3RJZCBUaGUgY29udHJhY3QgYWNjb3VudCBJRC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5tZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSB2aWV3IGZ1bmN0aW9uIHRvIGNhbGwuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYXJncyBUaGUgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIHZpZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYmxvY2tRdWVyeSBUaGUgYmxvY2sgcXVlcnkgb3B0aW9ucy5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSByZXN1bHQgb2YgdGhlIHZpZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgYXN5bmMgdmlld0Z1bmN0aW9uKHsgY29udHJhY3RJZCwgbWV0aG9kTmFtZSwgYXJncyA9IHt9LCBibG9ja1F1ZXJ5ID0geyBmaW5hbGl0eTogJ29wdGltaXN0aWMnIH0gfSkge1xuICAgICAgICBjb25zdCBtZXRob2RBcmdzID0gSlNPTi5zdHJpbmdpZnkoYXJncyk7XG4gICAgICAgIGNvbnN0IHsgY29udHJhY3RDb2RlLCBjb250cmFjdFN0YXRlLCBibG9ja0hlaWdodCwgYmxvY2tUaW1lc3RhbXAgfSA9IGF3YWl0IHRoaXMubG9hZE9yRmV0Y2goY29udHJhY3RJZCwgYmxvY2tRdWVyeSk7XG4gICAgICAgIGNvbnN0IHJ1bnRpbWUgPSBuZXcgcnVudGltZV8xLlJ1bnRpbWUoeyBjb250cmFjdElkLCBjb250cmFjdENvZGUsIGNvbnRyYWN0U3RhdGUsIGJsb2NrSGVpZ2h0LCBibG9ja1RpbWVzdGFtcCwgbWV0aG9kQXJncyB9KTtcbiAgICAgICAgY29uc3QgeyByZXN1bHQsIGxvZ3MgfSA9IGF3YWl0IHJ1bnRpbWUuZXhlY3V0ZShtZXRob2ROYW1lKTtcbiAgICAgICAgaWYgKGxvZ3MpIHtcbiAgICAgICAgICAgICgwLCB1dGlsc18xLnByaW50VHhPdXRjb21lTG9ncykoeyBjb250cmFjdElkLCBsb2dzIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKEJ1ZmZlci5mcm9tKHJlc3VsdCkudG9TdHJpbmcoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5Mb2NhbFZpZXdFeGVjdXRpb24gPSBMb2NhbFZpZXdFeGVjdXRpb247XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/local-view-execution/index.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/local-view-execution/runtime.cjs":
/*!*********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/local-view-execution/runtime.cjs ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Runtime = void 0;\nconst sha256_1 = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/sha256.js\");\nconst notImplemented = (name) => () => {\n    throw new Error('method not implemented: ' + name);\n};\nconst prohibitedInView = (name) => () => {\n    throw new Error('method not available for view calls: ' + name);\n};\nclass Runtime {\n    context;\n    wasm;\n    memory;\n    registers;\n    logs;\n    result;\n    constructor({ contractCode, ...context }) {\n        this.context = context;\n        this.wasm = this.prepareWASM(Buffer.from(contractCode, 'base64'));\n        this.memory = new WebAssembly.Memory({ initial: 1024, maximum: 2048 });\n        this.registers = {};\n        this.logs = [];\n        this.result = Buffer.from([]);\n    }\n    readUTF16CStr(ptr) {\n        const arr = [];\n        const mem = new Uint16Array(this.memory.buffer);\n        let key = Number(ptr) / 2;\n        while (mem[key] != 0) {\n            arr.push(mem[key]);\n            key++;\n        }\n        return Buffer.from(Uint16Array.from(arr).buffer).toString('ucs2');\n    }\n    readUTF8CStr(len, ptr) {\n        const arr = [];\n        const mem = new Uint8Array(this.memory.buffer);\n        let key = Number(ptr);\n        for (let i = 0; i < len && mem[key] != 0; i++) {\n            arr.push(mem[key]);\n            key++;\n        }\n        return Buffer.from(arr).toString('utf8');\n    }\n    storageRead(keyLen, keyPtr) {\n        const storageKey = Buffer.from(new Uint8Array(this.memory.buffer, Number(keyPtr), Number(keyLen)));\n        const stateVal = this.context.contractState.filter((obj) => Buffer.compare(obj.key, storageKey) === 0).map((obj) => obj.value);\n        if (stateVal.length === 0)\n            return null;\n        return stateVal.length > 1 ? stateVal : stateVal[0];\n    }\n    prepareWASM(input) {\n        const parts = [];\n        const magic = input.subarray(0, 4);\n        if (magic.toString('utf8') !== '\\0asm') {\n            throw new Error('Invalid magic number');\n        }\n        const version = input.readUInt32LE(4);\n        if (version != 1) {\n            throw new Error('Invalid version: ' + version);\n        }\n        let offset = 8;\n        parts.push(input.subarray(0, offset));\n        function decodeLEB128() {\n            let result = 0;\n            let shift = 0;\n            let byte;\n            do {\n                byte = input[offset++];\n                result |= (byte & 0x7f) << shift;\n                shift += 7;\n            } while (byte & 0x80);\n            return result;\n        }\n        function decodeLimits() {\n            const flags = input[offset++];\n            const hasMax = flags & 0x1;\n            const initial = decodeLEB128();\n            const max = hasMax ? decodeLEB128() : null;\n            return { initial, max };\n        }\n        function decodeString() {\n            const length = decodeLEB128();\n            const result = input.subarray(offset, offset + length);\n            offset += length;\n            return result.toString('utf8');\n        }\n        function encodeLEB128(value) {\n            const result = [];\n            do {\n                let byte = value & 0x7f;\n                value >>= 7;\n                if (value !== 0) {\n                    byte |= 0x80;\n                }\n                result.push(byte);\n            } while (value !== 0);\n            return Buffer.from(result);\n        }\n        function encodeString(value) {\n            const result = Buffer.from(value, 'utf8');\n            return Buffer.concat([encodeLEB128(result.length), result]);\n        }\n        do {\n            const sectionStart = offset;\n            const sectionId = input.readUInt8(offset);\n            offset++;\n            const sectionSize = decodeLEB128();\n            const sectionEnd = offset + sectionSize;\n            if (sectionId == 5) {\n                // Memory section\n                // Make sure it's empty and only imported memory is used\n                parts.push(Buffer.from([5, 1, 0]));\n            }\n            else if (sectionId == 2) {\n                // Import section\n                const sectionParts = [];\n                const numImports = decodeLEB128();\n                for (let i = 0; i < numImports; i++) {\n                    const importStart = offset;\n                    decodeString();\n                    decodeString();\n                    const kind = input.readUInt8(offset);\n                    offset++;\n                    let skipImport = false;\n                    switch (kind) {\n                        case 0:\n                            // Function import\n                            decodeLEB128(); // index\n                            break;\n                        case 1:\n                            // Table import\n                            offset++; // type\n                            decodeLimits();\n                            break;\n                        case 2:\n                            // Memory import\n                            decodeLimits();\n                            // NOTE: existing memory import is removed (so no need to add it to sectionParts)\n                            skipImport = true;\n                            break;\n                        case 3:\n                            // Global import\n                            offset++; // type\n                            offset++; // mutability\n                            break;\n                        default:\n                            throw new Error('Invalid import kind: ' + kind);\n                    }\n                    if (!skipImport) {\n                        sectionParts.push(input.subarray(importStart, offset));\n                    }\n                }\n                const importMemory = Buffer.concat([\n                    encodeString('env'),\n                    encodeString('memory'),\n                    Buffer.from([2]), // Memory import\n                    Buffer.from([0]),\n                    encodeLEB128(1),\n                ]);\n                sectionParts.push(importMemory);\n                const sectionData = Buffer.concat([\n                    encodeLEB128(sectionParts.length),\n                    ...sectionParts,\n                ]);\n                parts.push(Buffer.concat([\n                    Buffer.from([2]), // Import section\n                    encodeLEB128(sectionData.length),\n                    sectionData\n                ]));\n            }\n            else if (sectionId == 7) {\n                // Export section\n                const sectionParts = [];\n                const numExports = decodeLEB128();\n                for (let i = 0; i < numExports; i++) {\n                    const exportStart = offset;\n                    decodeString();\n                    const kind = input.readUInt8(offset);\n                    offset++;\n                    decodeLEB128();\n                    if (kind !== 2) {\n                        // Pass through all exports except memory\n                        sectionParts.push(input.subarray(exportStart, offset));\n                    }\n                }\n                const sectionData = Buffer.concat([\n                    encodeLEB128(sectionParts.length),\n                    ...sectionParts,\n                ]);\n                parts.push(Buffer.concat([\n                    Buffer.from([7]), // Export section\n                    encodeLEB128(sectionData.length),\n                    sectionData\n                ]));\n            }\n            else {\n                parts.push(input.subarray(sectionStart, sectionEnd));\n            }\n            offset = sectionEnd;\n        } while (offset < input.length);\n        return Buffer.concat(parts);\n    }\n    // Host functions\n    getRegisterLength(registerId) {\n        return BigInt(this.registers[registerId.toString()] ? this.registers[registerId.toString()].length : Number.MAX_SAFE_INTEGER);\n    }\n    readFromRegister(registerId, ptr) {\n        const mem = new Uint8Array(this.memory.buffer);\n        mem.set(this.registers[registerId.toString()] || Buffer.from([]), Number(ptr));\n    }\n    getCurrentAccountId(registerId) {\n        this.registers[registerId.toString()] = Buffer.from(this.context.contractId);\n    }\n    inputMethodArgs(registerId) {\n        this.registers[registerId.toString()] = Buffer.from(this.context.methodArgs);\n    }\n    getBlockHeight() {\n        return BigInt(this.context.blockHeight);\n    }\n    getBlockTimestamp() {\n        return BigInt(this.context.blockTimestamp);\n    }\n    sha256(valueLen, valuePtr, registerId) {\n        const value = new Uint8Array(this.memory.buffer, Number(valuePtr), Number(valueLen));\n        this.registers[registerId.toString()] = (0, sha256_1.sha256)(value);\n    }\n    returnValue(valueLen, valuePtr) {\n        this.result = Buffer.from(new Uint8Array(this.memory.buffer, Number(valuePtr), Number(valueLen)));\n    }\n    panic(message) {\n        throw new Error('panic: ' + message);\n    }\n    abort(msg_ptr, filename_ptr, line, col) {\n        const msg = this.readUTF16CStr(msg_ptr);\n        const filename = this.readUTF16CStr(filename_ptr);\n        const message = `${msg} ${filename}:${line}:${col}`;\n        if (!msg || !filename) {\n            throw new Error('abort: ' + 'String encoding is bad UTF-16 sequence.');\n        }\n        throw new Error('abort: ' + message);\n    }\n    appendToLog(len, ptr) {\n        this.logs.push(this.readUTF8CStr(len, ptr));\n    }\n    readStorage(key_len, key_ptr, register_id) {\n        const result = this.storageRead(key_len, key_ptr);\n        if (result == null) {\n            return 0n;\n        }\n        this.registers[register_id] = result;\n        return 1n;\n    }\n    hasStorageKey(key_len, key_ptr) {\n        const result = this.storageRead(key_len, key_ptr);\n        if (result == null) {\n            return 0n;\n        }\n        return 1n;\n    }\n    getHostImports() {\n        return {\n            register_len: this.getRegisterLength.bind(this),\n            read_register: this.readFromRegister.bind(this),\n            current_account_id: this.getCurrentAccountId.bind(this),\n            input: this.inputMethodArgs.bind(this),\n            block_index: this.getBlockHeight.bind(this),\n            block_timestamp: this.getBlockTimestamp.bind(this),\n            sha256: this.sha256.bind(this),\n            value_return: this.returnValue.bind(this),\n            abort: this.abort.bind(this),\n            log_utf8: this.appendToLog.bind(this),\n            log_utf16: this.appendToLog.bind(this),\n            storage_read: this.readStorage.bind(this),\n            storage_has_key: this.hasStorageKey.bind(this),\n            panic: () => this.panic('explicit guest panic'),\n            panic_utf8: (len, ptr) => this.panic(this.readUTF8CStr(len, ptr)),\n            // Not implemented\n            epoch_height: notImplemented('epoch_height'),\n            storage_usage: notImplemented('storage_usage'),\n            account_balance: notImplemented('account_balance'),\n            account_locked_balance: notImplemented('account_locked_balance'),\n            random_seed: notImplemented('random_seed'),\n            ripemd160: notImplemented('ripemd160'),\n            keccak256: notImplemented('keccak256'),\n            keccak512: notImplemented('keccak512'),\n            ecrecover: notImplemented('ecrecover'),\n            validator_stake: notImplemented('validator_stake'),\n            validator_total_stake: notImplemented('validator_total_stake'),\n            // Prohibited\n            write_register: prohibitedInView('write_register'),\n            signer_account_id: prohibitedInView('signer_account_id'),\n            signer_account_pk: prohibitedInView('signer_account_pk'),\n            predecessor_account_id: prohibitedInView('predecessor_account_id'),\n            attached_deposit: prohibitedInView('attached_deposit'),\n            prepaid_gas: prohibitedInView('prepaid_gas'),\n            used_gas: prohibitedInView('used_gas'),\n            promise_create: prohibitedInView('promise_create'),\n            promise_then: prohibitedInView('promise_then'),\n            promise_and: prohibitedInView('promise_and'),\n            promise_batch_create: prohibitedInView('promise_batch_create'),\n            promise_batch_then: prohibitedInView('promise_batch_then'),\n            promise_batch_action_create_account: prohibitedInView('promise_batch_action_create_account'),\n            promise_batch_action_deploy_contract: prohibitedInView('promise_batch_action_deploy_contract'),\n            promise_batch_action_function_call: prohibitedInView('promise_batch_action_function_call'),\n            promise_batch_action_function_call_weight: prohibitedInView('promise_batch_action_function_call_weight'),\n            promise_batch_action_transfer: prohibitedInView('promise_batch_action_transfer'),\n            promise_batch_action_stake: prohibitedInView('promise_batch_action_stake'),\n            promise_batch_action_add_key_with_full_access: prohibitedInView('promise_batch_action_add_key_with_full_access'),\n            promise_batch_action_add_key_with_function_call: prohibitedInView('promise_batch_action_add_key_with_function_call'),\n            promise_batch_action_delete_key: prohibitedInView('promise_batch_action_delete_key'),\n            promise_batch_action_delete_account: prohibitedInView('promise_batch_action_delete_account'),\n            promise_results_count: prohibitedInView('promise_results_count'),\n            promise_result: prohibitedInView('promise_result'),\n            promise_return: prohibitedInView('promise_return'),\n            storage_write: prohibitedInView('storage_write'),\n            storage_remove: prohibitedInView('storage_remove'),\n        };\n    }\n    async execute(methodName) {\n        const module = await WebAssembly.compile(this.wasm);\n        const instance = await WebAssembly.instantiate(module, { env: { ...this.getHostImports(), memory: this.memory } });\n        const callMethod = instance.exports[methodName];\n        if (callMethod == undefined) {\n            throw new Error(`Contract method '${methodName}' does not exists in contract ${this.context.contractId} for block id ${this.context.blockHeight}`);\n        }\n        callMethod();\n        return {\n            result: this.result,\n            logs: this.logs\n        };\n    }\n}\nexports.Runtime = Runtime;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMS4zLjEvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9jb21tb25qcy9sb2NhbC12aWV3LWV4ZWN1dGlvbi9ydW50aW1lLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlO0FBQ2YsaUJBQWlCLG1CQUFPLENBQUMsaUhBQXNCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDBCQUEwQjtBQUM1QztBQUNBO0FBQ0EsK0NBQStDLDhCQUE4QjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdCQUFnQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLEtBQUssRUFBRSxTQUFTLEdBQUcsS0FBSyxHQUFHLElBQUk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLE9BQU8saURBQWlEO0FBQ3pIO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVyxnQ0FBZ0MseUJBQXlCLGVBQWUseUJBQXlCO0FBQzVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGFja2F0aG9uLW5lYXItcmVkYWN0ZWQvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMS4zLjEvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9jb21tb25qcy9sb2NhbC12aWV3LWV4ZWN1dGlvbi9ydW50aW1lLmNqcz8xOTRmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SdW50aW1lID0gdm9pZCAwO1xuY29uc3Qgc2hhMjU2XzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9zaGEyNTZcIik7XG5jb25zdCBub3RJbXBsZW1lbnRlZCA9IChuYW1lKSA9PiAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2Qgbm90IGltcGxlbWVudGVkOiAnICsgbmFtZSk7XG59O1xuY29uc3QgcHJvaGliaXRlZEluVmlldyA9IChuYW1lKSA9PiAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2Qgbm90IGF2YWlsYWJsZSBmb3IgdmlldyBjYWxsczogJyArIG5hbWUpO1xufTtcbmNsYXNzIFJ1bnRpbWUge1xuICAgIGNvbnRleHQ7XG4gICAgd2FzbTtcbiAgICBtZW1vcnk7XG4gICAgcmVnaXN0ZXJzO1xuICAgIGxvZ3M7XG4gICAgcmVzdWx0O1xuICAgIGNvbnN0cnVjdG9yKHsgY29udHJhY3RDb2RlLCAuLi5jb250ZXh0IH0pIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy53YXNtID0gdGhpcy5wcmVwYXJlV0FTTShCdWZmZXIuZnJvbShjb250cmFjdENvZGUsICdiYXNlNjQnKSk7XG4gICAgICAgIHRoaXMubWVtb3J5ID0gbmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7IGluaXRpYWw6IDEwMjQsIG1heGltdW06IDIwNDggfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJzID0ge307XG4gICAgICAgIHRoaXMubG9ncyA9IFtdO1xuICAgICAgICB0aGlzLnJlc3VsdCA9IEJ1ZmZlci5mcm9tKFtdKTtcbiAgICB9XG4gICAgcmVhZFVURjE2Q1N0cihwdHIpIHtcbiAgICAgICAgY29uc3QgYXJyID0gW107XG4gICAgICAgIGNvbnN0IG1lbSA9IG5ldyBVaW50MTZBcnJheSh0aGlzLm1lbW9yeS5idWZmZXIpO1xuICAgICAgICBsZXQga2V5ID0gTnVtYmVyKHB0cikgLyAyO1xuICAgICAgICB3aGlsZSAobWVtW2tleV0gIT0gMCkge1xuICAgICAgICAgICAgYXJyLnB1c2gobWVtW2tleV0pO1xuICAgICAgICAgICAga2V5Kys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFVpbnQxNkFycmF5LmZyb20oYXJyKS5idWZmZXIpLnRvU3RyaW5nKCd1Y3MyJyk7XG4gICAgfVxuICAgIHJlYWRVVEY4Q1N0cihsZW4sIHB0cikge1xuICAgICAgICBjb25zdCBhcnIgPSBbXTtcbiAgICAgICAgY29uc3QgbWVtID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5tZW1vcnkuYnVmZmVyKTtcbiAgICAgICAgbGV0IGtleSA9IE51bWJlcihwdHIpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbiAmJiBtZW1ba2V5XSAhPSAwOyBpKyspIHtcbiAgICAgICAgICAgIGFyci5wdXNoKG1lbVtrZXldKTtcbiAgICAgICAgICAgIGtleSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShhcnIpLnRvU3RyaW5nKCd1dGY4Jyk7XG4gICAgfVxuICAgIHN0b3JhZ2VSZWFkKGtleUxlbiwga2V5UHRyKSB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VLZXkgPSBCdWZmZXIuZnJvbShuZXcgVWludDhBcnJheSh0aGlzLm1lbW9yeS5idWZmZXIsIE51bWJlcihrZXlQdHIpLCBOdW1iZXIoa2V5TGVuKSkpO1xuICAgICAgICBjb25zdCBzdGF0ZVZhbCA9IHRoaXMuY29udGV4dC5jb250cmFjdFN0YXRlLmZpbHRlcigob2JqKSA9PiBCdWZmZXIuY29tcGFyZShvYmoua2V5LCBzdG9yYWdlS2V5KSA9PT0gMCkubWFwKChvYmopID0+IG9iai52YWx1ZSk7XG4gICAgICAgIGlmIChzdGF0ZVZhbC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHN0YXRlVmFsLmxlbmd0aCA+IDEgPyBzdGF0ZVZhbCA6IHN0YXRlVmFsWzBdO1xuICAgIH1cbiAgICBwcmVwYXJlV0FTTShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgICAgICBjb25zdCBtYWdpYyA9IGlucHV0LnN1YmFycmF5KDAsIDQpO1xuICAgICAgICBpZiAobWFnaWMudG9TdHJpbmcoJ3V0ZjgnKSAhPT0gJ1xcMGFzbScpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtYWdpYyBudW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2ZXJzaW9uID0gaW5wdXQucmVhZFVJbnQzMkxFKDQpO1xuICAgICAgICBpZiAodmVyc2lvbiAhPSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmVyc2lvbjogJyArIHZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvZmZzZXQgPSA4O1xuICAgICAgICBwYXJ0cy5wdXNoKGlucHV0LnN1YmFycmF5KDAsIG9mZnNldCkpO1xuICAgICAgICBmdW5jdGlvbiBkZWNvZGVMRUIxMjgoKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICAgICAgICAgIGxldCBzaGlmdCA9IDA7XG4gICAgICAgICAgICBsZXQgYnl0ZTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBieXRlID0gaW5wdXRbb2Zmc2V0KytdO1xuICAgICAgICAgICAgICAgIHJlc3VsdCB8PSAoYnl0ZSAmIDB4N2YpIDw8IHNoaWZ0O1xuICAgICAgICAgICAgICAgIHNoaWZ0ICs9IDc7XG4gICAgICAgICAgICB9IHdoaWxlIChieXRlICYgMHg4MCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRlY29kZUxpbWl0cygpIHtcbiAgICAgICAgICAgIGNvbnN0IGZsYWdzID0gaW5wdXRbb2Zmc2V0KytdO1xuICAgICAgICAgICAgY29uc3QgaGFzTWF4ID0gZmxhZ3MgJiAweDE7XG4gICAgICAgICAgICBjb25zdCBpbml0aWFsID0gZGVjb2RlTEVCMTI4KCk7XG4gICAgICAgICAgICBjb25zdCBtYXggPSBoYXNNYXggPyBkZWNvZGVMRUIxMjgoKSA6IG51bGw7XG4gICAgICAgICAgICByZXR1cm4geyBpbml0aWFsLCBtYXggfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkZWNvZGVTdHJpbmcoKSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBkZWNvZGVMRUIxMjgoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGlucHV0LnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICAgICAgICAgIG9mZnNldCArPSBsZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRvU3RyaW5nKCd1dGY4Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZW5jb2RlTEVCMTI4KHZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBsZXQgYnl0ZSA9IHZhbHVlICYgMHg3ZjtcbiAgICAgICAgICAgICAgICB2YWx1ZSA+Pj0gNztcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZSB8PSAweDgwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChieXRlKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKHZhbHVlICE9PSAwKTtcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGVuY29kZVN0cmluZyh2YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gQnVmZmVyLmZyb20odmFsdWUsICd1dGY4Jyk7XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbZW5jb2RlTEVCMTI4KHJlc3VsdC5sZW5ndGgpLCByZXN1bHRdKTtcbiAgICAgICAgfVxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjb25zdCBzZWN0aW9uU3RhcnQgPSBvZmZzZXQ7XG4gICAgICAgICAgICBjb25zdCBzZWN0aW9uSWQgPSBpbnB1dC5yZWFkVUludDgob2Zmc2V0KTtcbiAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgY29uc3Qgc2VjdGlvblNpemUgPSBkZWNvZGVMRUIxMjgoKTtcbiAgICAgICAgICAgIGNvbnN0IHNlY3Rpb25FbmQgPSBvZmZzZXQgKyBzZWN0aW9uU2l6ZTtcbiAgICAgICAgICAgIGlmIChzZWN0aW9uSWQgPT0gNSkge1xuICAgICAgICAgICAgICAgIC8vIE1lbW9yeSBzZWN0aW9uXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGl0J3MgZW1wdHkgYW5kIG9ubHkgaW1wb3J0ZWQgbWVtb3J5IGlzIHVzZWRcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKEJ1ZmZlci5mcm9tKFs1LCAxLCAwXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2VjdGlvbklkID09IDIpIHtcbiAgICAgICAgICAgICAgICAvLyBJbXBvcnQgc2VjdGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IHNlY3Rpb25QYXJ0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IG51bUltcG9ydHMgPSBkZWNvZGVMRUIxMjgoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUltcG9ydHM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbXBvcnRTdGFydCA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGRlY29kZVN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBraW5kID0gaW5wdXQucmVhZFVJbnQ4KG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2tpcEltcG9ydCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGdW5jdGlvbiBpbXBvcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVMRUIxMjgoKTsgLy8gaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUYWJsZSBpbXBvcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQrKzsgLy8gdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZUxpbWl0cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1lbW9yeSBpbXBvcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVMaW1pdHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBleGlzdGluZyBtZW1vcnkgaW1wb3J0IGlzIHJlbW92ZWQgKHNvIG5vIG5lZWQgdG8gYWRkIGl0IHRvIHNlY3Rpb25QYXJ0cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBza2lwSW1wb3J0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHbG9iYWwgaW1wb3J0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0Kys7IC8vIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQrKzsgLy8gbXV0YWJpbGl0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW1wb3J0IGtpbmQ6ICcgKyBraW5kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNraXBJbXBvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlY3Rpb25QYXJ0cy5wdXNoKGlucHV0LnN1YmFycmF5KGltcG9ydFN0YXJ0LCBvZmZzZXQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpbXBvcnRNZW1vcnkgPSBCdWZmZXIuY29uY2F0KFtcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlU3RyaW5nKCdlbnYnKSxcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlU3RyaW5nKCdtZW1vcnknKSxcbiAgICAgICAgICAgICAgICAgICAgQnVmZmVyLmZyb20oWzJdKSwgLy8gTWVtb3J5IGltcG9ydFxuICAgICAgICAgICAgICAgICAgICBCdWZmZXIuZnJvbShbMF0pLFxuICAgICAgICAgICAgICAgICAgICBlbmNvZGVMRUIxMjgoMSksXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgc2VjdGlvblBhcnRzLnB1c2goaW1wb3J0TWVtb3J5KTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWN0aW9uRGF0YSA9IEJ1ZmZlci5jb25jYXQoW1xuICAgICAgICAgICAgICAgICAgICBlbmNvZGVMRUIxMjgoc2VjdGlvblBhcnRzLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgIC4uLnNlY3Rpb25QYXJ0cyxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKEJ1ZmZlci5jb25jYXQoW1xuICAgICAgICAgICAgICAgICAgICBCdWZmZXIuZnJvbShbMl0pLCAvLyBJbXBvcnQgc2VjdGlvblxuICAgICAgICAgICAgICAgICAgICBlbmNvZGVMRUIxMjgoc2VjdGlvbkRhdGEubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgc2VjdGlvbkRhdGFcbiAgICAgICAgICAgICAgICBdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZWN0aW9uSWQgPT0gNykge1xuICAgICAgICAgICAgICAgIC8vIEV4cG9ydCBzZWN0aW9uXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VjdGlvblBhcnRzID0gW107XG4gICAgICAgICAgICAgICAgY29uc3QgbnVtRXhwb3J0cyA9IGRlY29kZUxFQjEyOCgpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtRXhwb3J0czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cG9ydFN0YXJ0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBkZWNvZGVTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2luZCA9IGlucHV0LnJlYWRVSW50OChvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlTEVCMTI4KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChraW5kICE9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQYXNzIHRocm91Z2ggYWxsIGV4cG9ydHMgZXhjZXB0IG1lbW9yeVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VjdGlvblBhcnRzLnB1c2goaW5wdXQuc3ViYXJyYXkoZXhwb3J0U3RhcnQsIG9mZnNldCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNlY3Rpb25EYXRhID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgICAgIGVuY29kZUxFQjEyOChzZWN0aW9uUGFydHMubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgLi4uc2VjdGlvblBhcnRzLFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goQnVmZmVyLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5mcm9tKFs3XSksIC8vIEV4cG9ydCBzZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGVuY29kZUxFQjEyOChzZWN0aW9uRGF0YS5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICBzZWN0aW9uRGF0YVxuICAgICAgICAgICAgICAgIF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goaW5wdXQuc3ViYXJyYXkoc2VjdGlvblN0YXJ0LCBzZWN0aW9uRW5kKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgPSBzZWN0aW9uRW5kO1xuICAgICAgICB9IHdoaWxlIChvZmZzZXQgPCBpbnB1dC5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChwYXJ0cyk7XG4gICAgfVxuICAgIC8vIEhvc3QgZnVuY3Rpb25zXG4gICAgZ2V0UmVnaXN0ZXJMZW5ndGgocmVnaXN0ZXJJZCkge1xuICAgICAgICByZXR1cm4gQmlnSW50KHRoaXMucmVnaXN0ZXJzW3JlZ2lzdGVySWQudG9TdHJpbmcoKV0gPyB0aGlzLnJlZ2lzdGVyc1tyZWdpc3RlcklkLnRvU3RyaW5nKCldLmxlbmd0aCA6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKTtcbiAgICB9XG4gICAgcmVhZEZyb21SZWdpc3RlcihyZWdpc3RlcklkLCBwdHIpIHtcbiAgICAgICAgY29uc3QgbWVtID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5tZW1vcnkuYnVmZmVyKTtcbiAgICAgICAgbWVtLnNldCh0aGlzLnJlZ2lzdGVyc1tyZWdpc3RlcklkLnRvU3RyaW5nKCldIHx8IEJ1ZmZlci5mcm9tKFtdKSwgTnVtYmVyKHB0cikpO1xuICAgIH1cbiAgICBnZXRDdXJyZW50QWNjb3VudElkKHJlZ2lzdGVySWQpIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlcnNbcmVnaXN0ZXJJZC50b1N0cmluZygpXSA9IEJ1ZmZlci5mcm9tKHRoaXMuY29udGV4dC5jb250cmFjdElkKTtcbiAgICB9XG4gICAgaW5wdXRNZXRob2RBcmdzKHJlZ2lzdGVySWQpIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlcnNbcmVnaXN0ZXJJZC50b1N0cmluZygpXSA9IEJ1ZmZlci5mcm9tKHRoaXMuY29udGV4dC5tZXRob2RBcmdzKTtcbiAgICB9XG4gICAgZ2V0QmxvY2tIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiBCaWdJbnQodGhpcy5jb250ZXh0LmJsb2NrSGVpZ2h0KTtcbiAgICB9XG4gICAgZ2V0QmxvY2tUaW1lc3RhbXAoKSB7XG4gICAgICAgIHJldHVybiBCaWdJbnQodGhpcy5jb250ZXh0LmJsb2NrVGltZXN0YW1wKTtcbiAgICB9XG4gICAgc2hhMjU2KHZhbHVlTGVuLCB2YWx1ZVB0ciwgcmVnaXN0ZXJJZCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG5ldyBVaW50OEFycmF5KHRoaXMubWVtb3J5LmJ1ZmZlciwgTnVtYmVyKHZhbHVlUHRyKSwgTnVtYmVyKHZhbHVlTGVuKSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJzW3JlZ2lzdGVySWQudG9TdHJpbmcoKV0gPSAoMCwgc2hhMjU2XzEuc2hhMjU2KSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVyblZhbHVlKHZhbHVlTGVuLCB2YWx1ZVB0cikge1xuICAgICAgICB0aGlzLnJlc3VsdCA9IEJ1ZmZlci5mcm9tKG5ldyBVaW50OEFycmF5KHRoaXMubWVtb3J5LmJ1ZmZlciwgTnVtYmVyKHZhbHVlUHRyKSwgTnVtYmVyKHZhbHVlTGVuKSkpO1xuICAgIH1cbiAgICBwYW5pYyhtZXNzYWdlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFuaWM6ICcgKyBtZXNzYWdlKTtcbiAgICB9XG4gICAgYWJvcnQobXNnX3B0ciwgZmlsZW5hbWVfcHRyLCBsaW5lLCBjb2wpIHtcbiAgICAgICAgY29uc3QgbXNnID0gdGhpcy5yZWFkVVRGMTZDU3RyKG1zZ19wdHIpO1xuICAgICAgICBjb25zdCBmaWxlbmFtZSA9IHRoaXMucmVhZFVURjE2Q1N0cihmaWxlbmFtZV9wdHIpO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gYCR7bXNnfSAke2ZpbGVuYW1lfToke2xpbmV9OiR7Y29sfWA7XG4gICAgICAgIGlmICghbXNnIHx8ICFmaWxlbmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhYm9ydDogJyArICdTdHJpbmcgZW5jb2RpbmcgaXMgYmFkIFVURi0xNiBzZXF1ZW5jZS4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fib3J0OiAnICsgbWVzc2FnZSk7XG4gICAgfVxuICAgIGFwcGVuZFRvTG9nKGxlbiwgcHRyKSB7XG4gICAgICAgIHRoaXMubG9ncy5wdXNoKHRoaXMucmVhZFVURjhDU3RyKGxlbiwgcHRyKSk7XG4gICAgfVxuICAgIHJlYWRTdG9yYWdlKGtleV9sZW4sIGtleV9wdHIsIHJlZ2lzdGVyX2lkKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuc3RvcmFnZVJlYWQoa2V5X2xlbiwga2V5X3B0cik7XG4gICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIDBuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVnaXN0ZXJzW3JlZ2lzdGVyX2lkXSA9IHJlc3VsdDtcbiAgICAgICAgcmV0dXJuIDFuO1xuICAgIH1cbiAgICBoYXNTdG9yYWdlS2V5KGtleV9sZW4sIGtleV9wdHIpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5zdG9yYWdlUmVhZChrZXlfbGVuLCBrZXlfcHRyKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gMG47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDFuO1xuICAgIH1cbiAgICBnZXRIb3N0SW1wb3J0cygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlZ2lzdGVyX2xlbjogdGhpcy5nZXRSZWdpc3Rlckxlbmd0aC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgcmVhZF9yZWdpc3RlcjogdGhpcy5yZWFkRnJvbVJlZ2lzdGVyLmJpbmQodGhpcyksXG4gICAgICAgICAgICBjdXJyZW50X2FjY291bnRfaWQ6IHRoaXMuZ2V0Q3VycmVudEFjY291bnRJZC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgaW5wdXQ6IHRoaXMuaW5wdXRNZXRob2RBcmdzLmJpbmQodGhpcyksXG4gICAgICAgICAgICBibG9ja19pbmRleDogdGhpcy5nZXRCbG9ja0hlaWdodC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgYmxvY2tfdGltZXN0YW1wOiB0aGlzLmdldEJsb2NrVGltZXN0YW1wLmJpbmQodGhpcyksXG4gICAgICAgICAgICBzaGEyNTY6IHRoaXMuc2hhMjU2LmJpbmQodGhpcyksXG4gICAgICAgICAgICB2YWx1ZV9yZXR1cm46IHRoaXMucmV0dXJuVmFsdWUuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGFib3J0OiB0aGlzLmFib3J0LmJpbmQodGhpcyksXG4gICAgICAgICAgICBsb2dfdXRmODogdGhpcy5hcHBlbmRUb0xvZy5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgbG9nX3V0ZjE2OiB0aGlzLmFwcGVuZFRvTG9nLmJpbmQodGhpcyksXG4gICAgICAgICAgICBzdG9yYWdlX3JlYWQ6IHRoaXMucmVhZFN0b3JhZ2UuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHN0b3JhZ2VfaGFzX2tleTogdGhpcy5oYXNTdG9yYWdlS2V5LmJpbmQodGhpcyksXG4gICAgICAgICAgICBwYW5pYzogKCkgPT4gdGhpcy5wYW5pYygnZXhwbGljaXQgZ3Vlc3QgcGFuaWMnKSxcbiAgICAgICAgICAgIHBhbmljX3V0Zjg6IChsZW4sIHB0cikgPT4gdGhpcy5wYW5pYyh0aGlzLnJlYWRVVEY4Q1N0cihsZW4sIHB0cikpLFxuICAgICAgICAgICAgLy8gTm90IGltcGxlbWVudGVkXG4gICAgICAgICAgICBlcG9jaF9oZWlnaHQ6IG5vdEltcGxlbWVudGVkKCdlcG9jaF9oZWlnaHQnKSxcbiAgICAgICAgICAgIHN0b3JhZ2VfdXNhZ2U6IG5vdEltcGxlbWVudGVkKCdzdG9yYWdlX3VzYWdlJyksXG4gICAgICAgICAgICBhY2NvdW50X2JhbGFuY2U6IG5vdEltcGxlbWVudGVkKCdhY2NvdW50X2JhbGFuY2UnKSxcbiAgICAgICAgICAgIGFjY291bnRfbG9ja2VkX2JhbGFuY2U6IG5vdEltcGxlbWVudGVkKCdhY2NvdW50X2xvY2tlZF9iYWxhbmNlJyksXG4gICAgICAgICAgICByYW5kb21fc2VlZDogbm90SW1wbGVtZW50ZWQoJ3JhbmRvbV9zZWVkJyksXG4gICAgICAgICAgICByaXBlbWQxNjA6IG5vdEltcGxlbWVudGVkKCdyaXBlbWQxNjAnKSxcbiAgICAgICAgICAgIGtlY2NhazI1Njogbm90SW1wbGVtZW50ZWQoJ2tlY2NhazI1NicpLFxuICAgICAgICAgICAga2VjY2FrNTEyOiBub3RJbXBsZW1lbnRlZCgna2VjY2FrNTEyJyksXG4gICAgICAgICAgICBlY3JlY292ZXI6IG5vdEltcGxlbWVudGVkKCdlY3JlY292ZXInKSxcbiAgICAgICAgICAgIHZhbGlkYXRvcl9zdGFrZTogbm90SW1wbGVtZW50ZWQoJ3ZhbGlkYXRvcl9zdGFrZScpLFxuICAgICAgICAgICAgdmFsaWRhdG9yX3RvdGFsX3N0YWtlOiBub3RJbXBsZW1lbnRlZCgndmFsaWRhdG9yX3RvdGFsX3N0YWtlJyksXG4gICAgICAgICAgICAvLyBQcm9oaWJpdGVkXG4gICAgICAgICAgICB3cml0ZV9yZWdpc3RlcjogcHJvaGliaXRlZEluVmlldygnd3JpdGVfcmVnaXN0ZXInKSxcbiAgICAgICAgICAgIHNpZ25lcl9hY2NvdW50X2lkOiBwcm9oaWJpdGVkSW5WaWV3KCdzaWduZXJfYWNjb3VudF9pZCcpLFxuICAgICAgICAgICAgc2lnbmVyX2FjY291bnRfcGs6IHByb2hpYml0ZWRJblZpZXcoJ3NpZ25lcl9hY2NvdW50X3BrJyksXG4gICAgICAgICAgICBwcmVkZWNlc3Nvcl9hY2NvdW50X2lkOiBwcm9oaWJpdGVkSW5WaWV3KCdwcmVkZWNlc3Nvcl9hY2NvdW50X2lkJyksXG4gICAgICAgICAgICBhdHRhY2hlZF9kZXBvc2l0OiBwcm9oaWJpdGVkSW5WaWV3KCdhdHRhY2hlZF9kZXBvc2l0JyksXG4gICAgICAgICAgICBwcmVwYWlkX2dhczogcHJvaGliaXRlZEluVmlldygncHJlcGFpZF9nYXMnKSxcbiAgICAgICAgICAgIHVzZWRfZ2FzOiBwcm9oaWJpdGVkSW5WaWV3KCd1c2VkX2dhcycpLFxuICAgICAgICAgICAgcHJvbWlzZV9jcmVhdGU6IHByb2hpYml0ZWRJblZpZXcoJ3Byb21pc2VfY3JlYXRlJyksXG4gICAgICAgICAgICBwcm9taXNlX3RoZW46IHByb2hpYml0ZWRJblZpZXcoJ3Byb21pc2VfdGhlbicpLFxuICAgICAgICAgICAgcHJvbWlzZV9hbmQ6IHByb2hpYml0ZWRJblZpZXcoJ3Byb21pc2VfYW5kJyksXG4gICAgICAgICAgICBwcm9taXNlX2JhdGNoX2NyZWF0ZTogcHJvaGliaXRlZEluVmlldygncHJvbWlzZV9iYXRjaF9jcmVhdGUnKSxcbiAgICAgICAgICAgIHByb21pc2VfYmF0Y2hfdGhlbjogcHJvaGliaXRlZEluVmlldygncHJvbWlzZV9iYXRjaF90aGVuJyksXG4gICAgICAgICAgICBwcm9taXNlX2JhdGNoX2FjdGlvbl9jcmVhdGVfYWNjb3VudDogcHJvaGliaXRlZEluVmlldygncHJvbWlzZV9iYXRjaF9hY3Rpb25fY3JlYXRlX2FjY291bnQnKSxcbiAgICAgICAgICAgIHByb21pc2VfYmF0Y2hfYWN0aW9uX2RlcGxveV9jb250cmFjdDogcHJvaGliaXRlZEluVmlldygncHJvbWlzZV9iYXRjaF9hY3Rpb25fZGVwbG95X2NvbnRyYWN0JyksXG4gICAgICAgICAgICBwcm9taXNlX2JhdGNoX2FjdGlvbl9mdW5jdGlvbl9jYWxsOiBwcm9oaWJpdGVkSW5WaWV3KCdwcm9taXNlX2JhdGNoX2FjdGlvbl9mdW5jdGlvbl9jYWxsJyksXG4gICAgICAgICAgICBwcm9taXNlX2JhdGNoX2FjdGlvbl9mdW5jdGlvbl9jYWxsX3dlaWdodDogcHJvaGliaXRlZEluVmlldygncHJvbWlzZV9iYXRjaF9hY3Rpb25fZnVuY3Rpb25fY2FsbF93ZWlnaHQnKSxcbiAgICAgICAgICAgIHByb21pc2VfYmF0Y2hfYWN0aW9uX3RyYW5zZmVyOiBwcm9oaWJpdGVkSW5WaWV3KCdwcm9taXNlX2JhdGNoX2FjdGlvbl90cmFuc2ZlcicpLFxuICAgICAgICAgICAgcHJvbWlzZV9iYXRjaF9hY3Rpb25fc3Rha2U6IHByb2hpYml0ZWRJblZpZXcoJ3Byb21pc2VfYmF0Y2hfYWN0aW9uX3N0YWtlJyksXG4gICAgICAgICAgICBwcm9taXNlX2JhdGNoX2FjdGlvbl9hZGRfa2V5X3dpdGhfZnVsbF9hY2Nlc3M6IHByb2hpYml0ZWRJblZpZXcoJ3Byb21pc2VfYmF0Y2hfYWN0aW9uX2FkZF9rZXlfd2l0aF9mdWxsX2FjY2VzcycpLFxuICAgICAgICAgICAgcHJvbWlzZV9iYXRjaF9hY3Rpb25fYWRkX2tleV93aXRoX2Z1bmN0aW9uX2NhbGw6IHByb2hpYml0ZWRJblZpZXcoJ3Byb21pc2VfYmF0Y2hfYWN0aW9uX2FkZF9rZXlfd2l0aF9mdW5jdGlvbl9jYWxsJyksXG4gICAgICAgICAgICBwcm9taXNlX2JhdGNoX2FjdGlvbl9kZWxldGVfa2V5OiBwcm9oaWJpdGVkSW5WaWV3KCdwcm9taXNlX2JhdGNoX2FjdGlvbl9kZWxldGVfa2V5JyksXG4gICAgICAgICAgICBwcm9taXNlX2JhdGNoX2FjdGlvbl9kZWxldGVfYWNjb3VudDogcHJvaGliaXRlZEluVmlldygncHJvbWlzZV9iYXRjaF9hY3Rpb25fZGVsZXRlX2FjY291bnQnKSxcbiAgICAgICAgICAgIHByb21pc2VfcmVzdWx0c19jb3VudDogcHJvaGliaXRlZEluVmlldygncHJvbWlzZV9yZXN1bHRzX2NvdW50JyksXG4gICAgICAgICAgICBwcm9taXNlX3Jlc3VsdDogcHJvaGliaXRlZEluVmlldygncHJvbWlzZV9yZXN1bHQnKSxcbiAgICAgICAgICAgIHByb21pc2VfcmV0dXJuOiBwcm9oaWJpdGVkSW5WaWV3KCdwcm9taXNlX3JldHVybicpLFxuICAgICAgICAgICAgc3RvcmFnZV93cml0ZTogcHJvaGliaXRlZEluVmlldygnc3RvcmFnZV93cml0ZScpLFxuICAgICAgICAgICAgc3RvcmFnZV9yZW1vdmU6IHByb2hpYml0ZWRJblZpZXcoJ3N0b3JhZ2VfcmVtb3ZlJyksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIGV4ZWN1dGUobWV0aG9kTmFtZSkge1xuICAgICAgICBjb25zdCBtb2R1bGUgPSBhd2FpdCBXZWJBc3NlbWJseS5jb21waWxlKHRoaXMud2FzbSk7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUobW9kdWxlLCB7IGVudjogeyAuLi50aGlzLmdldEhvc3RJbXBvcnRzKCksIG1lbW9yeTogdGhpcy5tZW1vcnkgfSB9KTtcbiAgICAgICAgY29uc3QgY2FsbE1ldGhvZCA9IGluc3RhbmNlLmV4cG9ydHNbbWV0aG9kTmFtZV07XG4gICAgICAgIGlmIChjYWxsTWV0aG9kID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb250cmFjdCBtZXRob2QgJyR7bWV0aG9kTmFtZX0nIGRvZXMgbm90IGV4aXN0cyBpbiBjb250cmFjdCAke3RoaXMuY29udGV4dC5jb250cmFjdElkfSBmb3IgYmxvY2sgaWQgJHt0aGlzLmNvbnRleHQuYmxvY2tIZWlnaHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbE1ldGhvZCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdWx0OiB0aGlzLnJlc3VsdCxcbiAgICAgICAgICAgIGxvZ3M6IHRoaXMubG9nc1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuUnVudGltZSA9IFJ1bnRpbWU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/local-view-execution/runtime.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/local-view-execution/storage.cjs":
/*!*********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/local-view-execution/storage.cjs ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Storage = void 0;\nconst lru_map_1 = __webpack_require__(/*! lru_map */ \"(ssr)/./node_modules/.pnpm/lru_map@0.4.1/node_modules/lru_map/dist/lru.js\");\nclass Storage {\n    cache;\n    static MAX_ELEMENTS = 100;\n    // map block hash to block height\n    blockHeights;\n    constructor(options = { max: Storage.MAX_ELEMENTS }) {\n        this.cache = new lru_map_1.LRUMap(options.max);\n        this.blockHeights = new Map();\n    }\n    load(blockRef) {\n        const noBlockId = !('blockId' in blockRef);\n        if (noBlockId)\n            return undefined;\n        let blockId = blockRef.blockId;\n        // block hash is passed, so get its corresponding block height\n        if (blockId.toString().length == 44) {\n            blockId = this.blockHeights.get(blockId.toString());\n        }\n        // get cached values for the given block height\n        return this.cache.get(blockId);\n    }\n    save(blockHash, { blockHeight, blockTimestamp, contractCode, contractState }) {\n        this.blockHeights.set(blockHash, blockHeight);\n        this.cache.set(blockHeight, { blockHeight, blockTimestamp, contractCode, contractState });\n    }\n}\nexports.Storage = Storage;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMS4zLjEvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9jb21tb25qcy9sb2NhbC12aWV3LWV4ZWN1dGlvbi9zdG9yYWdlLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlO0FBQ2Ysa0JBQWtCLG1CQUFPLENBQUMsMEZBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyQkFBMkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBEQUEwRDtBQUNoRjtBQUNBLHNDQUFzQywwREFBMEQ7QUFDaEc7QUFDQTtBQUNBLGVBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oYWNrYXRob24tbmVhci1yZWRhY3RlZC8uL25vZGVfbW9kdWxlcy8ucG5wbS9AbmVhci1qcythY2NvdW50c0AxLjMuMS9ub2RlX21vZHVsZXMvQG5lYXItanMvYWNjb3VudHMvbGliL2NvbW1vbmpzL2xvY2FsLXZpZXctZXhlY3V0aW9uL3N0b3JhZ2UuY2pzP2VkNGQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN0b3JhZ2UgPSB2b2lkIDA7XG5jb25zdCBscnVfbWFwXzEgPSByZXF1aXJlKFwibHJ1X21hcFwiKTtcbmNsYXNzIFN0b3JhZ2Uge1xuICAgIGNhY2hlO1xuICAgIHN0YXRpYyBNQVhfRUxFTUVOVFMgPSAxMDA7XG4gICAgLy8gbWFwIGJsb2NrIGhhc2ggdG8gYmxvY2sgaGVpZ2h0XG4gICAgYmxvY2tIZWlnaHRzO1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7IG1heDogU3RvcmFnZS5NQVhfRUxFTUVOVFMgfSkge1xuICAgICAgICB0aGlzLmNhY2hlID0gbmV3IGxydV9tYXBfMS5MUlVNYXAob3B0aW9ucy5tYXgpO1xuICAgICAgICB0aGlzLmJsb2NrSGVpZ2h0cyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgbG9hZChibG9ja1JlZikge1xuICAgICAgICBjb25zdCBub0Jsb2NrSWQgPSAhKCdibG9ja0lkJyBpbiBibG9ja1JlZik7XG4gICAgICAgIGlmIChub0Jsb2NrSWQpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgYmxvY2tJZCA9IGJsb2NrUmVmLmJsb2NrSWQ7XG4gICAgICAgIC8vIGJsb2NrIGhhc2ggaXMgcGFzc2VkLCBzbyBnZXQgaXRzIGNvcnJlc3BvbmRpbmcgYmxvY2sgaGVpZ2h0XG4gICAgICAgIGlmIChibG9ja0lkLnRvU3RyaW5nKCkubGVuZ3RoID09IDQ0KSB7XG4gICAgICAgICAgICBibG9ja0lkID0gdGhpcy5ibG9ja0hlaWdodHMuZ2V0KGJsb2NrSWQudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZ2V0IGNhY2hlZCB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBibG9jayBoZWlnaHRcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuZ2V0KGJsb2NrSWQpO1xuICAgIH1cbiAgICBzYXZlKGJsb2NrSGFzaCwgeyBibG9ja0hlaWdodCwgYmxvY2tUaW1lc3RhbXAsIGNvbnRyYWN0Q29kZSwgY29udHJhY3RTdGF0ZSB9KSB7XG4gICAgICAgIHRoaXMuYmxvY2tIZWlnaHRzLnNldChibG9ja0hhc2gsIGJsb2NrSGVpZ2h0KTtcbiAgICAgICAgdGhpcy5jYWNoZS5zZXQoYmxvY2tIZWlnaHQsIHsgYmxvY2tIZWlnaHQsIGJsb2NrVGltZXN0YW1wLCBjb250cmFjdENvZGUsIGNvbnRyYWN0U3RhdGUgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5TdG9yYWdlID0gU3RvcmFnZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/local-view-execution/storage.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/types.cjs":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/types.cjs ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MultisigStateStatus = exports.MultisigDeleteRequestRejectionError = void 0;\nvar MultisigDeleteRequestRejectionError;\n(function (MultisigDeleteRequestRejectionError) {\n    MultisigDeleteRequestRejectionError[\"CANNOT_DESERIALIZE_STATE\"] = \"Cannot deserialize the contract state\";\n    MultisigDeleteRequestRejectionError[\"MULTISIG_NOT_INITIALIZED\"] = \"Smart contract panicked: Multisig contract should be initialized before usage\";\n    MultisigDeleteRequestRejectionError[\"NO_SUCH_REQUEST\"] = \"Smart contract panicked: panicked at 'No such request: either wrong number or already confirmed'\";\n    MultisigDeleteRequestRejectionError[\"REQUEST_COOLDOWN_ERROR\"] = \"Request cannot be deleted immediately after creation.\";\n    MultisigDeleteRequestRejectionError[\"METHOD_NOT_FOUND\"] = \"Contract method is not found\";\n})(MultisigDeleteRequestRejectionError || (exports.MultisigDeleteRequestRejectionError = MultisigDeleteRequestRejectionError = {}));\nvar MultisigStateStatus;\n(function (MultisigStateStatus) {\n    MultisigStateStatus[MultisigStateStatus[\"INVALID_STATE\"] = 0] = \"INVALID_STATE\";\n    MultisigStateStatus[MultisigStateStatus[\"STATE_NOT_INITIALIZED\"] = 1] = \"STATE_NOT_INITIALIZED\";\n    MultisigStateStatus[MultisigStateStatus[\"VALID_STATE\"] = 2] = \"VALID_STATE\";\n    MultisigStateStatus[MultisigStateStatus[\"UNKNOWN_STATE\"] = 3] = \"UNKNOWN_STATE\";\n})(MultisigStateStatus || (exports.MultisigStateStatus = MultisigStateStatus = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMS4zLjEvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9jb21tb25qcy90eXBlcy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCLEdBQUcsMkNBQTJDO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQ0FBMEMsMkNBQTJDLDJDQUEyQztBQUNqSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBCQUEwQiwyQkFBMkIsMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGFja2F0aG9uLW5lYXItcmVkYWN0ZWQvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMS4zLjEvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9jb21tb25qcy90eXBlcy5janM/NmQzZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTXVsdGlzaWdTdGF0ZVN0YXR1cyA9IGV4cG9ydHMuTXVsdGlzaWdEZWxldGVSZXF1ZXN0UmVqZWN0aW9uRXJyb3IgPSB2b2lkIDA7XG52YXIgTXVsdGlzaWdEZWxldGVSZXF1ZXN0UmVqZWN0aW9uRXJyb3I7XG4oZnVuY3Rpb24gKE11bHRpc2lnRGVsZXRlUmVxdWVzdFJlamVjdGlvbkVycm9yKSB7XG4gICAgTXVsdGlzaWdEZWxldGVSZXF1ZXN0UmVqZWN0aW9uRXJyb3JbXCJDQU5OT1RfREVTRVJJQUxJWkVfU1RBVEVcIl0gPSBcIkNhbm5vdCBkZXNlcmlhbGl6ZSB0aGUgY29udHJhY3Qgc3RhdGVcIjtcbiAgICBNdWx0aXNpZ0RlbGV0ZVJlcXVlc3RSZWplY3Rpb25FcnJvcltcIk1VTFRJU0lHX05PVF9JTklUSUFMSVpFRFwiXSA9IFwiU21hcnQgY29udHJhY3QgcGFuaWNrZWQ6IE11bHRpc2lnIGNvbnRyYWN0IHNob3VsZCBiZSBpbml0aWFsaXplZCBiZWZvcmUgdXNhZ2VcIjtcbiAgICBNdWx0aXNpZ0RlbGV0ZVJlcXVlc3RSZWplY3Rpb25FcnJvcltcIk5PX1NVQ0hfUkVRVUVTVFwiXSA9IFwiU21hcnQgY29udHJhY3QgcGFuaWNrZWQ6IHBhbmlja2VkIGF0ICdObyBzdWNoIHJlcXVlc3Q6IGVpdGhlciB3cm9uZyBudW1iZXIgb3IgYWxyZWFkeSBjb25maXJtZWQnXCI7XG4gICAgTXVsdGlzaWdEZWxldGVSZXF1ZXN0UmVqZWN0aW9uRXJyb3JbXCJSRVFVRVNUX0NPT0xET1dOX0VSUk9SXCJdID0gXCJSZXF1ZXN0IGNhbm5vdCBiZSBkZWxldGVkIGltbWVkaWF0ZWx5IGFmdGVyIGNyZWF0aW9uLlwiO1xuICAgIE11bHRpc2lnRGVsZXRlUmVxdWVzdFJlamVjdGlvbkVycm9yW1wiTUVUSE9EX05PVF9GT1VORFwiXSA9IFwiQ29udHJhY3QgbWV0aG9kIGlzIG5vdCBmb3VuZFwiO1xufSkoTXVsdGlzaWdEZWxldGVSZXF1ZXN0UmVqZWN0aW9uRXJyb3IgfHwgKGV4cG9ydHMuTXVsdGlzaWdEZWxldGVSZXF1ZXN0UmVqZWN0aW9uRXJyb3IgPSBNdWx0aXNpZ0RlbGV0ZVJlcXVlc3RSZWplY3Rpb25FcnJvciA9IHt9KSk7XG52YXIgTXVsdGlzaWdTdGF0ZVN0YXR1cztcbihmdW5jdGlvbiAoTXVsdGlzaWdTdGF0ZVN0YXR1cykge1xuICAgIE11bHRpc2lnU3RhdGVTdGF0dXNbTXVsdGlzaWdTdGF0ZVN0YXR1c1tcIklOVkFMSURfU1RBVEVcIl0gPSAwXSA9IFwiSU5WQUxJRF9TVEFURVwiO1xuICAgIE11bHRpc2lnU3RhdGVTdGF0dXNbTXVsdGlzaWdTdGF0ZVN0YXR1c1tcIlNUQVRFX05PVF9JTklUSUFMSVpFRFwiXSA9IDFdID0gXCJTVEFURV9OT1RfSU5JVElBTElaRURcIjtcbiAgICBNdWx0aXNpZ1N0YXRlU3RhdHVzW011bHRpc2lnU3RhdGVTdGF0dXNbXCJWQUxJRF9TVEFURVwiXSA9IDJdID0gXCJWQUxJRF9TVEFURVwiO1xuICAgIE11bHRpc2lnU3RhdGVTdGF0dXNbTXVsdGlzaWdTdGF0ZVN0YXR1c1tcIlVOS05PV05fU1RBVEVcIl0gPSAzXSA9IFwiVU5LTk9XTl9TVEFURVwiO1xufSkoTXVsdGlzaWdTdGF0ZVN0YXR1cyB8fCAoZXhwb3J0cy5NdWx0aXNpZ1N0YXRlU3RhdHVzID0gTXVsdGlzaWdTdGF0ZVN0YXR1cyA9IHt9KSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/types.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/utils.cjs":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/utils.cjs ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.viewFunction = exports.viewState = exports.encodeJSContractArgs = exports.validateArgs = void 0;\nconst types_1 = __webpack_require__(/*! @near-js/types */ \"(ssr)/./node_modules/.pnpm/@near-js+types@0.3.1/node_modules/@near-js/types/lib/commonjs/index.cjs\");\nconst utils_1 = __webpack_require__(/*! @near-js/utils */ \"(ssr)/./node_modules/.pnpm/@near-js+utils@1.0.1/node_modules/@near-js/utils/lib/commonjs/index.cjs\");\nfunction parseJsonFromRawResponse(response) {\n    return JSON.parse(Buffer.from(response).toString());\n}\nfunction bytesJsonStringify(input) {\n    return Buffer.from(JSON.stringify(input));\n}\nfunction validateArgs(args) {\n    const isUint8Array = args.byteLength !== undefined && args.byteLength === args.length;\n    if (isUint8Array) {\n        return;\n    }\n    if (Array.isArray(args) || typeof args !== 'object') {\n        throw new types_1.PositionalArgsError();\n    }\n}\nexports.validateArgs = validateArgs;\nfunction encodeJSContractArgs(contractId, method, args) {\n    return Buffer.concat([Buffer.from(contractId), Buffer.from([0]), Buffer.from(method), Buffer.from([0]), Buffer.from(args)]);\n}\nexports.encodeJSContractArgs = encodeJSContractArgs;\n/**\n * Returns the state (key value pairs) of account's contract based on the key prefix.\n * Pass an empty string for prefix if you would like to return the entire state.\n * @see [https://docs.near.org/api/rpc/contracts#view-contract-state](https://docs.near.org/api/rpc/contracts#view-contract-state)\n *\n * @param connection connection to query state from\n * @param accountId account whose state is viewed\n * @param prefix allows to filter which keys should be returned. Empty prefix means all keys. String prefix is utf-8 encoded.\n * @param blockQuery specifies which block to query state at. By default returns last \"optimistic\" block (i.e. not necessarily finalized).\n */\nasync function viewState(connection, accountId, prefix, blockQuery = { finality: 'optimistic' }) {\n    const { values } = await connection.provider.query({\n        request_type: 'view_state',\n        ...blockQuery,\n        account_id: accountId,\n        prefix_base64: Buffer.from(prefix).toString('base64')\n    });\n    return values.map(({ key, value }) => ({\n        key: Buffer.from(key, 'base64'),\n        value: Buffer.from(value, 'base64')\n    }));\n}\nexports.viewState = viewState;\n/**\n * Invoke a contract view function using the RPC API.\n * @see [https://docs.near.org/api/rpc/contracts#call-a-contract-function](https://docs.near.org/api/rpc/contracts#call-a-contract-function)\n *\n * @param options Function call options.\n * @param options.contractId NEAR account where the contract is deployed\n * @param options.methodName The view-only method (no state mutations) name on the contract as it is written in the contract code\n * @param options.args Any arguments to the view contract method, wrapped in JSON\n * @param options.parse Parse the result of the call. Receives a Buffer (bytes array) and converts it to any object. By default result will be treated as json.\n * @param options.stringify Convert input arguments into a bytes array. By default the input is treated as a JSON.\n * @param options.jsContract Is contract from JS SDK, automatically encodes args from JS SDK to binary.\n * @param options.blockQuery specifies which block to query state at. By default returns last \"optimistic\" block (i.e. not necessarily finalized).\n * @returns {Promise<any>}\n */\nasync function viewFunction(connection, { contractId, methodName, args = {}, parse = parseJsonFromRawResponse, stringify = bytesJsonStringify, jsContract = false, blockQuery = { finality: 'optimistic' } }) {\n    let encodedArgs;\n    validateArgs(args);\n    if (jsContract) {\n        encodedArgs = encodeJSContractArgs(contractId, methodName, Object.keys(args).length > 0 ? JSON.stringify(args) : '');\n    }\n    else {\n        encodedArgs = stringify(args);\n    }\n    const result = await connection.provider.query({\n        request_type: 'call_function',\n        ...blockQuery,\n        account_id: jsContract ? connection.jsvmAccountId : contractId,\n        method_name: jsContract ? 'view_js_contract' : methodName,\n        args_base64: encodedArgs.toString('base64')\n    });\n    if (result.logs) {\n        (0, utils_1.printTxOutcomeLogs)({ contractId, logs: result.logs });\n    }\n    return result.result && result.result.length > 0 && parse(Buffer.from(result.result));\n}\nexports.viewFunction = viewFunction;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMS4zLjEvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9jb21tb25qcy91dGlscy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CLEdBQUcsaUJBQWlCLEdBQUcsNEJBQTRCLEdBQUcsb0JBQW9CO0FBQzlGLGdCQUFnQixtQkFBTyxDQUFDLDBIQUFnQjtBQUN4QyxnQkFBZ0IsbUJBQU8sQ0FBQywwSEFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSx3QkFBd0I7QUFDL0YsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHlCQUF5QixZQUFZO0FBQ3JDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsMENBQTBDLGlDQUFpQyx1R0FBdUcsMEJBQTBCO0FBQzVNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwwQ0FBMEMsK0JBQStCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiIsInNvdXJjZXMiOlsid2VicGFjazovL2hhY2thdGhvbi1uZWFyLXJlZGFjdGVkLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BuZWFyLWpzK2FjY291bnRzQDEuMy4xL25vZGVfbW9kdWxlcy9AbmVhci1qcy9hY2NvdW50cy9saWIvY29tbW9uanMvdXRpbHMuY2pzP2I5YjEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZpZXdGdW5jdGlvbiA9IGV4cG9ydHMudmlld1N0YXRlID0gZXhwb3J0cy5lbmNvZGVKU0NvbnRyYWN0QXJncyA9IGV4cG9ydHMudmFsaWRhdGVBcmdzID0gdm9pZCAwO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCJAbmVhci1qcy90eXBlc1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG5lYXItanMvdXRpbHNcIik7XG5mdW5jdGlvbiBwYXJzZUpzb25Gcm9tUmF3UmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShCdWZmZXIuZnJvbShyZXNwb25zZSkudG9TdHJpbmcoKSk7XG59XG5mdW5jdGlvbiBieXRlc0pzb25TdHJpbmdpZnkoaW5wdXQpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oSlNPTi5zdHJpbmdpZnkoaW5wdXQpKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQXJncyhhcmdzKSB7XG4gICAgY29uc3QgaXNVaW50OEFycmF5ID0gYXJncy5ieXRlTGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgYXJncy5ieXRlTGVuZ3RoID09PSBhcmdzLmxlbmd0aDtcbiAgICBpZiAoaXNVaW50OEFycmF5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykgfHwgdHlwZW9mIGFyZ3MgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyB0eXBlc18xLlBvc2l0aW9uYWxBcmdzRXJyb3IoKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlQXJncyA9IHZhbGlkYXRlQXJncztcbmZ1bmN0aW9uIGVuY29kZUpTQ29udHJhY3RBcmdzKGNvbnRyYWN0SWQsIG1ldGhvZCwgYXJncykge1xuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbShjb250cmFjdElkKSwgQnVmZmVyLmZyb20oWzBdKSwgQnVmZmVyLmZyb20obWV0aG9kKSwgQnVmZmVyLmZyb20oWzBdKSwgQnVmZmVyLmZyb20oYXJncyldKTtcbn1cbmV4cG9ydHMuZW5jb2RlSlNDb250cmFjdEFyZ3MgPSBlbmNvZGVKU0NvbnRyYWN0QXJncztcbi8qKlxuICogUmV0dXJucyB0aGUgc3RhdGUgKGtleSB2YWx1ZSBwYWlycykgb2YgYWNjb3VudCdzIGNvbnRyYWN0IGJhc2VkIG9uIHRoZSBrZXkgcHJlZml4LlxuICogUGFzcyBhbiBlbXB0eSBzdHJpbmcgZm9yIHByZWZpeCBpZiB5b3Ugd291bGQgbGlrZSB0byByZXR1cm4gdGhlIGVudGlyZSBzdGF0ZS5cbiAqIEBzZWUgW2h0dHBzOi8vZG9jcy5uZWFyLm9yZy9hcGkvcnBjL2NvbnRyYWN0cyN2aWV3LWNvbnRyYWN0LXN0YXRlXShodHRwczovL2RvY3MubmVhci5vcmcvYXBpL3JwYy9jb250cmFjdHMjdmlldy1jb250cmFjdC1zdGF0ZSlcbiAqXG4gKiBAcGFyYW0gY29ubmVjdGlvbiBjb25uZWN0aW9uIHRvIHF1ZXJ5IHN0YXRlIGZyb21cbiAqIEBwYXJhbSBhY2NvdW50SWQgYWNjb3VudCB3aG9zZSBzdGF0ZSBpcyB2aWV3ZWRcbiAqIEBwYXJhbSBwcmVmaXggYWxsb3dzIHRvIGZpbHRlciB3aGljaCBrZXlzIHNob3VsZCBiZSByZXR1cm5lZC4gRW1wdHkgcHJlZml4IG1lYW5zIGFsbCBrZXlzLiBTdHJpbmcgcHJlZml4IGlzIHV0Zi04IGVuY29kZWQuXG4gKiBAcGFyYW0gYmxvY2tRdWVyeSBzcGVjaWZpZXMgd2hpY2ggYmxvY2sgdG8gcXVlcnkgc3RhdGUgYXQuIEJ5IGRlZmF1bHQgcmV0dXJucyBsYXN0IFwib3B0aW1pc3RpY1wiIGJsb2NrIChpLmUuIG5vdCBuZWNlc3NhcmlseSBmaW5hbGl6ZWQpLlxuICovXG5hc3luYyBmdW5jdGlvbiB2aWV3U3RhdGUoY29ubmVjdGlvbiwgYWNjb3VudElkLCBwcmVmaXgsIGJsb2NrUXVlcnkgPSB7IGZpbmFsaXR5OiAnb3B0aW1pc3RpYycgfSkge1xuICAgIGNvbnN0IHsgdmFsdWVzIH0gPSBhd2FpdCBjb25uZWN0aW9uLnByb3ZpZGVyLnF1ZXJ5KHtcbiAgICAgICAgcmVxdWVzdF90eXBlOiAndmlld19zdGF0ZScsXG4gICAgICAgIC4uLmJsb2NrUXVlcnksXG4gICAgICAgIGFjY291bnRfaWQ6IGFjY291bnRJZCxcbiAgICAgICAgcHJlZml4X2Jhc2U2NDogQnVmZmVyLmZyb20ocHJlZml4KS50b1N0cmluZygnYmFzZTY0JylcbiAgICB9KTtcbiAgICByZXR1cm4gdmFsdWVzLm1hcCgoeyBrZXksIHZhbHVlIH0pID0+ICh7XG4gICAgICAgIGtleTogQnVmZmVyLmZyb20oa2V5LCAnYmFzZTY0JyksXG4gICAgICAgIHZhbHVlOiBCdWZmZXIuZnJvbSh2YWx1ZSwgJ2Jhc2U2NCcpXG4gICAgfSkpO1xufVxuZXhwb3J0cy52aWV3U3RhdGUgPSB2aWV3U3RhdGU7XG4vKipcbiAqIEludm9rZSBhIGNvbnRyYWN0IHZpZXcgZnVuY3Rpb24gdXNpbmcgdGhlIFJQQyBBUEkuXG4gKiBAc2VlIFtodHRwczovL2RvY3MubmVhci5vcmcvYXBpL3JwYy9jb250cmFjdHMjY2FsbC1hLWNvbnRyYWN0LWZ1bmN0aW9uXShodHRwczovL2RvY3MubmVhci5vcmcvYXBpL3JwYy9jb250cmFjdHMjY2FsbC1hLWNvbnRyYWN0LWZ1bmN0aW9uKVxuICpcbiAqIEBwYXJhbSBvcHRpb25zIEZ1bmN0aW9uIGNhbGwgb3B0aW9ucy5cbiAqIEBwYXJhbSBvcHRpb25zLmNvbnRyYWN0SWQgTkVBUiBhY2NvdW50IHdoZXJlIHRoZSBjb250cmFjdCBpcyBkZXBsb3llZFxuICogQHBhcmFtIG9wdGlvbnMubWV0aG9kTmFtZSBUaGUgdmlldy1vbmx5IG1ldGhvZCAobm8gc3RhdGUgbXV0YXRpb25zKSBuYW1lIG9uIHRoZSBjb250cmFjdCBhcyBpdCBpcyB3cml0dGVuIGluIHRoZSBjb250cmFjdCBjb2RlXG4gKiBAcGFyYW0gb3B0aW9ucy5hcmdzIEFueSBhcmd1bWVudHMgdG8gdGhlIHZpZXcgY29udHJhY3QgbWV0aG9kLCB3cmFwcGVkIGluIEpTT05cbiAqIEBwYXJhbSBvcHRpb25zLnBhcnNlIFBhcnNlIHRoZSByZXN1bHQgb2YgdGhlIGNhbGwuIFJlY2VpdmVzIGEgQnVmZmVyIChieXRlcyBhcnJheSkgYW5kIGNvbnZlcnRzIGl0IHRvIGFueSBvYmplY3QuIEJ5IGRlZmF1bHQgcmVzdWx0IHdpbGwgYmUgdHJlYXRlZCBhcyBqc29uLlxuICogQHBhcmFtIG9wdGlvbnMuc3RyaW5naWZ5IENvbnZlcnQgaW5wdXQgYXJndW1lbnRzIGludG8gYSBieXRlcyBhcnJheS4gQnkgZGVmYXVsdCB0aGUgaW5wdXQgaXMgdHJlYXRlZCBhcyBhIEpTT04uXG4gKiBAcGFyYW0gb3B0aW9ucy5qc0NvbnRyYWN0IElzIGNvbnRyYWN0IGZyb20gSlMgU0RLLCBhdXRvbWF0aWNhbGx5IGVuY29kZXMgYXJncyBmcm9tIEpTIFNESyB0byBiaW5hcnkuXG4gKiBAcGFyYW0gb3B0aW9ucy5ibG9ja1F1ZXJ5IHNwZWNpZmllcyB3aGljaCBibG9jayB0byBxdWVyeSBzdGF0ZSBhdC4gQnkgZGVmYXVsdCByZXR1cm5zIGxhc3QgXCJvcHRpbWlzdGljXCIgYmxvY2sgKGkuZS4gbm90IG5lY2Vzc2FyaWx5IGZpbmFsaXplZCkuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICovXG5hc3luYyBmdW5jdGlvbiB2aWV3RnVuY3Rpb24oY29ubmVjdGlvbiwgeyBjb250cmFjdElkLCBtZXRob2ROYW1lLCBhcmdzID0ge30sIHBhcnNlID0gcGFyc2VKc29uRnJvbVJhd1Jlc3BvbnNlLCBzdHJpbmdpZnkgPSBieXRlc0pzb25TdHJpbmdpZnksIGpzQ29udHJhY3QgPSBmYWxzZSwgYmxvY2tRdWVyeSA9IHsgZmluYWxpdHk6ICdvcHRpbWlzdGljJyB9IH0pIHtcbiAgICBsZXQgZW5jb2RlZEFyZ3M7XG4gICAgdmFsaWRhdGVBcmdzKGFyZ3MpO1xuICAgIGlmIChqc0NvbnRyYWN0KSB7XG4gICAgICAgIGVuY29kZWRBcmdzID0gZW5jb2RlSlNDb250cmFjdEFyZ3MoY29udHJhY3RJZCwgbWV0aG9kTmFtZSwgT2JqZWN0LmtleXMoYXJncykubGVuZ3RoID4gMCA/IEpTT04uc3RyaW5naWZ5KGFyZ3MpIDogJycpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZW5jb2RlZEFyZ3MgPSBzdHJpbmdpZnkoYXJncyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbm5lY3Rpb24ucHJvdmlkZXIucXVlcnkoe1xuICAgICAgICByZXF1ZXN0X3R5cGU6ICdjYWxsX2Z1bmN0aW9uJyxcbiAgICAgICAgLi4uYmxvY2tRdWVyeSxcbiAgICAgICAgYWNjb3VudF9pZDoganNDb250cmFjdCA/IGNvbm5lY3Rpb24uanN2bUFjY291bnRJZCA6IGNvbnRyYWN0SWQsXG4gICAgICAgIG1ldGhvZF9uYW1lOiBqc0NvbnRyYWN0ID8gJ3ZpZXdfanNfY29udHJhY3QnIDogbWV0aG9kTmFtZSxcbiAgICAgICAgYXJnc19iYXNlNjQ6IGVuY29kZWRBcmdzLnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgIH0pO1xuICAgIGlmIChyZXN1bHQubG9ncykge1xuICAgICAgICAoMCwgdXRpbHNfMS5wcmludFR4T3V0Y29tZUxvZ3MpKHsgY29udHJhY3RJZCwgbG9nczogcmVzdWx0LmxvZ3MgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQucmVzdWx0ICYmIHJlc3VsdC5yZXN1bHQubGVuZ3RoID4gMCAmJiBwYXJzZShCdWZmZXIuZnJvbShyZXN1bHQucmVzdWx0KSk7XG59XG5leHBvcnRzLnZpZXdGdW5jdGlvbiA9IHZpZXdGdW5jdGlvbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+accounts@1.3.1/node_modules/@near-js/accounts/lib/commonjs/utils.cjs\n");

/***/ })

};
;